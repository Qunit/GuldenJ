<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>StoredPaymentChannelClientStates.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">guldenj</a> &gt; <a href="index.source.html" class="el_package">org.guldenj.protocols.channels</a> &gt; <span class="el_source">StoredPaymentChannelClientStates.java</span></div><h1>StoredPaymentChannelClientStates.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.guldenj.protocols.channels;

import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.Multimap;
import org.guldenj.core.*;
import org.guldenj.script.Script;
import org.guldenj.script.ScriptBuilder;
import org.guldenj.utils.Threading;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.HashMultimap;
import com.google.common.util.concurrent.SettableFuture;
import com.google.protobuf.ByteString;
import net.jcip.annotations.GuardedBy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.util.*;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.ReentrantLock;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

/**
 * This class maintains a set of {@link StoredClientChannel}s, automatically (re)broadcasting the contract transaction
 * and broadcasting the refund transaction over the given {@link TransactionBroadcaster}.
 */
public class StoredPaymentChannelClientStates implements WalletExtension {
<span class="fc" id="L48">    private static final Logger log = LoggerFactory.getLogger(StoredPaymentChannelClientStates.class);</span>
<span class="fc" id="L49">    static final String EXTENSION_ID = StoredPaymentChannelClientStates.class.getName();</span>
    static final int MAX_SECONDS_TO_WAIT_FOR_BROADCASTER_TO_BE_SET = 10;

<span class="pc" id="L52">    @GuardedBy(&quot;lock&quot;) @VisibleForTesting final HashMultimap&lt;Sha256Hash, StoredClientChannel&gt; mapChannels = HashMultimap.create();</span>
<span class="pc" id="L53">    @VisibleForTesting final Timer channelTimeoutHandler = new Timer(true);</span>

    private Wallet containingWallet;
<span class="pc" id="L56">    private final SettableFuture&lt;TransactionBroadcaster&gt; announcePeerGroupFuture = SettableFuture.create();</span>

<span class="pc" id="L58">    protected final ReentrantLock lock = Threading.lock(&quot;StoredPaymentChannelClientStates&quot;);</span>

    /**
     * Creates a new StoredPaymentChannelClientStates and associates it with the given {@link Wallet} and
     * {@link TransactionBroadcaster} which are used to complete and announce contract and refund
     * transactions.
     */
<span class="fc" id="L65">    public StoredPaymentChannelClientStates(@Nullable Wallet containingWallet, TransactionBroadcaster announcePeerGroup) {</span>
<span class="fc" id="L66">        setTransactionBroadcaster(announcePeerGroup);</span>
<span class="fc" id="L67">        this.containingWallet = containingWallet;</span>
<span class="fc" id="L68">    }</span>

    /**
     * Creates a new StoredPaymentChannelClientStates and associates it with the given {@link Wallet}
     *
     * Use this constructor if you use WalletAppKit, it will provide the broadcaster for you (no need to call the setter)
     */
<span class="nc" id="L75">    public StoredPaymentChannelClientStates(@Nullable Wallet containingWallet) {</span>
<span class="nc" id="L76">        this.containingWallet = containingWallet;</span>
<span class="nc" id="L77">    }</span>

    /**
     * Use this setter if the broadcaster is not available during instantiation and you're not using WalletAppKit.
     * This setter will let you delay the setting of the broadcaster until the Bitcoin network is ready.
     *
     * @param transactionBroadcaster which is used to complete and announce contract and refund transactions.
     */
    public final void setTransactionBroadcaster(TransactionBroadcaster transactionBroadcaster) {
<span class="fc" id="L86">        this.announcePeerGroupFuture.set(checkNotNull(transactionBroadcaster));</span>
<span class="fc" id="L87">    }</span>

    /** Returns this extension from the given wallet, or null if no such extension was added. */
    @Nullable
    public static StoredPaymentChannelClientStates getFromWallet(Wallet wallet) {
<span class="fc" id="L92">        return (StoredPaymentChannelClientStates) wallet.getExtensions().get(EXTENSION_ID);</span>
    }

    /** Returns the outstanding amount of money sent back to us for all channels to this server added together. */
    public Coin getBalanceForServer(Sha256Hash id) {
<span class="nc" id="L97">        Coin balance = Coin.ZERO;</span>
<span class="nc" id="L98">        lock.lock();</span>
        try {
<span class="nc" id="L100">            Set&lt;StoredClientChannel&gt; setChannels = mapChannels.get(id);</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">            for (StoredClientChannel channel : setChannels) {</span>
<span class="nc" id="L102">                synchronized (channel) {</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">                    if (channel.close != null) continue;</span>
<span class="nc" id="L104">                    balance = balance.add(channel.valueToMe);</span>
<span class="nc" id="L105">                }</span>
<span class="nc" id="L106">            }</span>
<span class="nc" id="L107">            return balance;</span>
        } finally {
<span class="nc" id="L109">            lock.unlock();</span>
        }
    }

    /**
     * Returns the number of seconds from now until this servers next channel will expire, or zero if no unexpired
     * channels found.
     */
    public long getSecondsUntilExpiry(Sha256Hash id) {
<span class="fc" id="L118">        lock.lock();</span>
        try {
<span class="fc" id="L120">            final Set&lt;StoredClientChannel&gt; setChannels = mapChannels.get(id);</span>
<span class="fc" id="L121">            final long nowSeconds = Utils.currentTimeSeconds();</span>
<span class="fc" id="L122">            int earliestTime = Integer.MAX_VALUE;</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">            for (StoredClientChannel channel : setChannels) {</span>
<span class="fc" id="L124">                synchronized (channel) {</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">                    if (channel.expiryTimeSeconds() &gt; nowSeconds)</span>
<span class="fc" id="L126">                        earliestTime = Math.min(earliestTime, (int) channel.expiryTimeSeconds());</span>
<span class="pc" id="L127">                }</span>
<span class="fc" id="L128">            }</span>
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">            return earliestTime == Integer.MAX_VALUE ? 0 : earliestTime - nowSeconds;</span>
        } finally {
<span class="pc" id="L131">            lock.unlock();</span>
        }
    }

    /**
     * Finds an inactive channel with the given id and returns it, or returns null.
     */
    @Nullable
    StoredClientChannel getUsableChannelForServerID(Sha256Hash id) {
<span class="fc" id="L140">        lock.lock();</span>
        try {
<span class="fc" id="L142">            Set&lt;StoredClientChannel&gt; setChannels = mapChannels.get(id);</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">            for (StoredClientChannel channel : setChannels) {</span>
<span class="fc" id="L144">                synchronized (channel) {</span>
                    // Check if the channel is usable (has money, inactive) and if so, activate it.
<span class="fc" id="L146">                    log.info(&quot;Considering channel {} contract {}&quot;, channel.hashCode(), channel.contract.getHash());</span>
<span class="fc bfc" id="L147" title="All 4 branches covered.">                    if (channel.close != null || channel.valueToMe.equals(Coin.ZERO)) {</span>
<span class="fc" id="L148">                        log.info(&quot;  ... but is closed or empty&quot;);</span>
<span class="fc" id="L149">                        continue;</span>
                    }
<span class="fc bfc" id="L151" title="All 2 branches covered.">                    if (!channel.active) {</span>
<span class="fc" id="L152">                        log.info(&quot;  ... activating&quot;);</span>
<span class="fc" id="L153">                        channel.active = true;</span>
<span class="fc" id="L154">                        return channel;</span>
                    }
<span class="fc" id="L156">                    log.info(&quot;  ... but is already active&quot;);</span>
<span class="pc" id="L157">                }</span>
<span class="fc" id="L158">            }</span>
        } finally {
<span class="pc" id="L160">            lock.unlock();</span>
<span class="fc" id="L161">        }</span>
<span class="fc" id="L162">        return null;</span>
    }

    /**
     * Finds a channel with the given id and contract hash and returns it, or returns null.
     */
    @Nullable
    public StoredClientChannel getChannel(Sha256Hash id, Sha256Hash contractHash) {
<span class="fc" id="L170">        lock.lock();</span>
        try {
<span class="fc" id="L172">            Set&lt;StoredClientChannel&gt; setChannels = mapChannels.get(id);</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">            for (StoredClientChannel channel : setChannels) {</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">                if (channel.contract.getHash().equals(contractHash))</span>
<span class="fc" id="L175">                    return channel;</span>
<span class="fc" id="L176">            }</span>
<span class="fc" id="L177">            return null;</span>
        } finally {
<span class="pc" id="L179">            lock.unlock();</span>
        }
    }

    /**
     * Get a copy of all {@link StoredClientChannel}s
     */
    public Multimap&lt;Sha256Hash, StoredClientChannel&gt; getChannelMap() {
<span class="nc" id="L187">        lock.lock();</span>
        try {
<span class="nc" id="L189">            return ImmutableMultimap.copyOf(mapChannels);</span>
        } finally {
<span class="nc" id="L191">            lock.unlock();</span>
        }
    }

    /**
     * Notifies the set of stored states that a channel has been updated. Use to notify the wallet of an update to this
     * wallet extension.
     */
    void updatedChannel(final StoredClientChannel channel) {
<span class="fc" id="L200">        log.info(&quot;Stored client channel {} was updated&quot;, channel.hashCode());</span>
<span class="fc" id="L201">        containingWallet.addOrUpdateExtension(this);</span>
<span class="fc" id="L202">    }</span>

    /**
     * Adds the given channel to this set of stored states, broadcasting the contract and refund transactions when the
     * channel expires and notifies the wallet of an update to this wallet extension
     */
    void putChannel(final StoredClientChannel channel) {
<span class="fc" id="L209">        putChannel(channel, true);</span>
<span class="fc" id="L210">    }</span>

    // Adds this channel and optionally notifies the wallet of an update to this extension (used during deserialize)
    private void putChannel(final StoredClientChannel channel, boolean updateWallet) {
<span class="fc" id="L214">        lock.lock();</span>
        try {
<span class="fc" id="L216">            mapChannels.put(channel.id, channel);</span>
<span class="fc" id="L217">            channelTimeoutHandler.schedule(new TimerTask() {</span>
                @Override
                public void run() {
                    try {
<span class="fc" id="L221">                        TransactionBroadcaster announcePeerGroup = getAnnouncePeerGroup();</span>
<span class="fc" id="L222">                        removeChannel(channel);</span>
<span class="fc" id="L223">                        announcePeerGroup.broadcastTransaction(channel.contract);</span>
<span class="fc" id="L224">                        announcePeerGroup.broadcastTransaction(channel.refund);</span>
<span class="nc" id="L225">                    } catch (Exception e) {</span>
                        // Something went wrong closing the channel - we catch
                        // here or else we take down the whole Timer.
<span class="nc" id="L228">                        log.error(&quot;Auto-closing channel failed&quot;, e);</span>
<span class="fc" id="L229">                    }</span>
<span class="fc" id="L230">                }</span>
                // Add the difference between real time and Utils.now() so that test-cases can use a mock clock.
<span class="fc" id="L232">            }, new Date(channel.expiryTimeSeconds() * 1000 + (System.currentTimeMillis() - Utils.currentTimeMillis())));</span>
        } finally {
<span class="pc" id="L234">            lock.unlock();</span>
<span class="fc" id="L235">        }</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (updateWallet)</span>
<span class="fc" id="L237">            updatedChannel(channel);</span>
<span class="fc" id="L238">    }</span>

    /**
     * If the peer group has not been set for MAX_SECONDS_TO_WAIT_FOR_BROADCASTER_TO_BE_SET seconds, then
     * the programmer probably forgot to set it and we should throw exception.
     */
    private TransactionBroadcaster getAnnouncePeerGroup() {
        try {
<span class="fc" id="L246">            return announcePeerGroupFuture.get(MAX_SECONDS_TO_WAIT_FOR_BROADCASTER_TO_BE_SET, TimeUnit.SECONDS);</span>
<span class="nc" id="L247">        } catch (InterruptedException e) {</span>
<span class="nc" id="L248">            throw new RuntimeException(e);</span>
<span class="nc" id="L249">        } catch (ExecutionException e) {</span>
<span class="nc" id="L250">            throw new RuntimeException(e);</span>
<span class="nc" id="L251">        } catch (TimeoutException e) {</span>
<span class="nc" id="L252">            String err = &quot;Transaction broadcaster not set&quot;;</span>
<span class="nc" id="L253">            log.error(err);</span>
<span class="nc" id="L254">            throw new RuntimeException(err, e);</span>
        }
    }

    /**
     * &lt;p&gt;Removes the channel with the given id from this set of stored states and notifies the wallet of an update to
     * this wallet extension.&lt;/p&gt;
     *
     * &lt;p&gt;Note that the channel will still have its contract and refund transactions broadcast via the connected
     * {@link TransactionBroadcaster} as long as this {@link StoredPaymentChannelClientStates} continues to
     * exist in memory.&lt;/p&gt;
     */
    void removeChannel(StoredClientChannel channel) {
<span class="fc" id="L267">        lock.lock();</span>
        try {
<span class="fc" id="L269">            mapChannels.remove(channel.id, channel);</span>
        } finally {
<span class="pc" id="L271">            lock.unlock();</span>
<span class="fc" id="L272">        }</span>
<span class="fc" id="L273">        updatedChannel(channel);</span>
<span class="fc" id="L274">    }</span>

    @Override
    public String getWalletExtensionID() {
<span class="fc" id="L278">        return EXTENSION_ID;</span>
    }

    @Override
    public boolean isWalletExtensionMandatory() {
<span class="fc" id="L283">        return false;</span>
    }

    @Override
    public byte[] serializeWalletExtension() {
<span class="fc" id="L288">        lock.lock();</span>
        try {
<span class="fc" id="L290">            final NetworkParameters params = getNetworkParameters();</span>
<span class="fc" id="L291">            ClientState.StoredClientPaymentChannels.Builder builder = ClientState.StoredClientPaymentChannels.newBuilder();</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">            for (StoredClientChannel channel : mapChannels.values()) {</span>
                // First a few asserts to make sure things won't break
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">                checkState(channel.valueToMe.signum() &gt;= 0 &amp;&amp;</span>
<span class="pc bpc" id="L295" title="2 of 4 branches missed.">                        (!params.hasMaxMoney() || channel.valueToMe.compareTo(params.getMaxMoney()) &lt;= 0));</span>
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">                checkState(channel.refundFees.signum() &gt;= 0 &amp;&amp;</span>
<span class="pc bpc" id="L297" title="2 of 4 branches missed.">                        (!params.hasMaxMoney() || channel.refundFees.compareTo(params.getMaxMoney()) &lt;= 0));</span>
<span class="fc" id="L298">                checkNotNull(channel.myKey.getPubKey());</span>
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">                checkState(channel.refund.getConfidence().getSource() == TransactionConfidence.Source.SELF);</span>
<span class="fc" id="L300">                checkNotNull(channel.myKey.getPubKey());</span>
<span class="fc" id="L301">                final ClientState.StoredClientPaymentChannel.Builder value = ClientState.StoredClientPaymentChannel.newBuilder()</span>
<span class="fc" id="L302">                        .setMajorVersion(channel.majorVersion)</span>
<span class="fc" id="L303">                        .setId(ByteString.copyFrom(channel.id.getBytes()))</span>
<span class="fc" id="L304">                        .setContractTransaction(ByteString.copyFrom(channel.contract.bitcoinSerialize()))</span>
<span class="fc" id="L305">                        .setRefundFees(channel.refundFees.value)</span>
<span class="fc" id="L306">                        .setRefundTransaction(ByteString.copyFrom(channel.refund.bitcoinSerialize()))</span>
<span class="fc" id="L307">                        .setMyKey(ByteString.copyFrom(new byte[0])) // Not  used, but protobuf message requires</span>
<span class="fc" id="L308">                        .setMyPublicKey(ByteString.copyFrom(channel.myKey.getPubKey()))</span>
<span class="fc" id="L309">                        .setServerKey(ByteString.copyFrom(channel.serverKey.getPubKey()))</span>
<span class="fc" id="L310">                        .setValueToMe(channel.valueToMe.value)</span>
<span class="fc" id="L311">                        .setExpiryTime(channel.expiryTime);</span>
<span class="pc bpc" id="L312" title="1 of 2 branches missed.">                if (channel.close != null)</span>
<span class="nc" id="L313">                    value.setCloseTransactionHash(ByteString.copyFrom(channel.close.getHash().getBytes()));</span>
<span class="fc" id="L314">                builder.addChannels(value);</span>
<span class="fc" id="L315">            }</span>
<span class="fc" id="L316">            return builder.build().toByteArray();</span>
        } finally {
<span class="pc" id="L318">            lock.unlock();</span>
        }
    }

    @Override
    public void deserializeWalletExtension(Wallet containingWallet, byte[] data) throws Exception {
<span class="fc" id="L324">        lock.lock();</span>
        try {
<span class="pc bpc" id="L326" title="1 of 4 branches missed.">            checkState(this.containingWallet == null || this.containingWallet == containingWallet);</span>
<span class="fc" id="L327">            this.containingWallet = containingWallet;</span>
<span class="fc" id="L328">            NetworkParameters params = containingWallet.getParams();</span>
<span class="fc" id="L329">            ClientState.StoredClientPaymentChannels states = ClientState.StoredClientPaymentChannels.parseFrom(data);</span>
<span class="fc bfc" id="L330" title="All 2 branches covered.">            for (ClientState.StoredClientPaymentChannel storedState : states.getChannelsList()) {</span>
<span class="fc" id="L331">                Transaction refundTransaction = params.getDefaultSerializer().makeTransaction(storedState.getRefundTransaction().toByteArray());</span>
<span class="fc" id="L332">                refundTransaction.getConfidence().setSource(TransactionConfidence.Source.SELF);</span>
<span class="pc bpc" id="L333" title="1 of 2 branches missed.">                ECKey myKey = (storedState.getMyKey().isEmpty()) ?</span>
<span class="pc" id="L334">                        containingWallet.findKeyFromPubKey(storedState.getMyPublicKey().toByteArray()) :</span>
<span class="pc" id="L335">                        ECKey.fromPrivate(storedState.getMyKey().toByteArray());</span>
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">                ECKey serverKey = storedState.hasServerKey() ? ECKey.fromPublicOnly(storedState.getServerKey().toByteArray()) : null;</span>
<span class="fc" id="L337">                StoredClientChannel channel = new StoredClientChannel(storedState.getMajorVersion(),</span>
<span class="fc" id="L338">                        Sha256Hash.wrap(storedState.getId().toByteArray()),</span>
<span class="fc" id="L339">                        params.getDefaultSerializer().makeTransaction(storedState.getContractTransaction().toByteArray()),</span>
                        refundTransaction,
                        myKey,
                        serverKey,
<span class="fc" id="L343">                        Coin.valueOf(storedState.getValueToMe()),</span>
<span class="fc" id="L344">                        Coin.valueOf(storedState.getRefundFees()),</span>
<span class="fc" id="L345">                        storedState.getExpiryTime(),</span>
                        false);
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">                if (storedState.hasCloseTransactionHash()) {</span>
<span class="nc" id="L348">                    Sha256Hash closeTxHash = Sha256Hash.wrap(storedState.getCloseTransactionHash().toByteArray());</span>
<span class="nc" id="L349">                    channel.close = containingWallet.getTransaction(closeTxHash);</span>
                }
<span class="fc" id="L351">                putChannel(channel, false);</span>
<span class="fc" id="L352">            }</span>
        } finally {
<span class="pc" id="L354">            lock.unlock();</span>
<span class="fc" id="L355">        }</span>
<span class="fc" id="L356">    }</span>

    @Override
    public String toString() {
<span class="nc" id="L360">        lock.lock();</span>
        try {
<span class="nc" id="L362">            StringBuilder buf = new StringBuilder(&quot;Client payment channel states:\n&quot;);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            for (StoredClientChannel channel : mapChannels.values())</span>
<span class="nc" id="L364">                buf.append(&quot;  &quot;).append(channel).append(&quot;\n&quot;);</span>
<span class="nc" id="L365">            return buf.toString();</span>
        } finally {
<span class="nc" id="L367">            lock.unlock();</span>
        }
    }

    private NetworkParameters getNetworkParameters() {
<span class="fc" id="L372">        return this.containingWallet.getNetworkParameters();</span>
    }
}

/**
 * Represents the state of a channel once it has been opened in such a way that it can be stored and used to resume a
 * channel which was interrupted (eg on connection failure) or keep track of refund transactions which need broadcast
 * when they expire.
 */
class StoredClientChannel {
    int majorVersion;
    Sha256Hash id;
    Transaction contract, refund;
    // The expiry time of the contract in protocol v2.
    long expiryTime;
    // The transaction that closed the channel (generated by the server)
    Transaction close;
    ECKey myKey;
    ECKey serverKey;
    Coin valueToMe, refundFees;

    // In-memory flag to indicate intent to resume this channel (or that the channel is already in use)
<span class="fc" id="L394">    boolean active = false;</span>

    StoredClientChannel(int majorVersion, Sha256Hash id, Transaction contract, Transaction refund, ECKey myKey, ECKey serverKey, Coin valueToMe,
<span class="fc" id="L397">                        Coin refundFees, long expiryTime, boolean active) {</span>
<span class="fc" id="L398">        this.majorVersion = majorVersion;</span>
<span class="fc" id="L399">        this.id = id;</span>
<span class="fc" id="L400">        this.contract = contract;</span>
<span class="fc" id="L401">        this.refund = refund;</span>
<span class="fc" id="L402">        this.myKey = myKey;</span>
<span class="fc" id="L403">        this.serverKey = serverKey;</span>
<span class="fc" id="L404">        this.valueToMe = valueToMe;</span>
<span class="fc" id="L405">        this.refundFees = refundFees;</span>
<span class="fc" id="L406">        this.expiryTime = expiryTime;</span>
<span class="fc" id="L407">        this.active = active;</span>
<span class="fc" id="L408">    }</span>

    long expiryTimeSeconds() {
<span class="pc bpc" id="L411" title="1 of 3 branches missed.">        switch (majorVersion) {</span>
            case 1:
<span class="fc" id="L413">                return refund.getLockTime() + 60 * 5;</span>
            case 2:
<span class="fc" id="L415">                return expiryTime + 60 * 5;</span>
            default:
<span class="nc" id="L417">                throw new IllegalStateException(&quot;Invalid version&quot;);</span>
        }
    }

    @Override
    public String toString() {
<span class="nc" id="L423">        final String newline = String.format(Locale.US, &quot;%n&quot;);</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">        final String closeStr = close == null ? &quot;still open&quot; : close.toString().replaceAll(newline, newline + &quot;   &quot;);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">        return String.format(Locale.US, &quot;Stored client channel for server ID %s (%s)%n&quot; +</span>
                &quot;    Version:     %d%n&quot; +
                &quot;    Key:         %s%n&quot; +
                &quot;    Server key:  %s%n&quot; +
                &quot;    Value left:  %s%n&quot; +
                &quot;    Refund fees: %s%n&quot; +
                &quot;    Expiry     : %s%n&quot; +
                &quot;    Contract:  %s&quot; +
                &quot;Refund:    %s&quot; +
                &quot;Close:     %s&quot;,
<span class="nc" id="L435">                id, active ? &quot;active&quot; : &quot;inactive&quot;, majorVersion, myKey, serverKey, valueToMe, refundFees, expiryTime,</span>
<span class="nc" id="L436">                contract.toString().replaceAll(newline, newline + &quot;    &quot;),</span>
<span class="nc" id="L437">                refund.toString().replaceAll(newline, newline + &quot;    &quot;),</span>
                closeStr);
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>