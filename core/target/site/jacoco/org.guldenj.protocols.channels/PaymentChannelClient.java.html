<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PaymentChannelClient.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">guldenj</a> &gt; <a href="index.source.html" class="el_package">org.guldenj.protocols.channels</a> &gt; <span class="el_source">PaymentChannelClient.java</span></div><h1>PaymentChannelClient.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.guldenj.protocols.channels;

import org.guldenj.core.*;
import org.guldenj.protocols.channels.PaymentChannelCloseException.CloseReason;
import org.guldenj.utils.Threading;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.MoreExecutors;
import com.google.common.util.concurrent.SettableFuture;
import com.google.protobuf.ByteString;
import net.jcip.annotations.GuardedBy;
import org.bitcoin.paymentchannel.Protos;
import org.slf4j.LoggerFactory;
import org.spongycastle.crypto.params.KeyParameter;

import javax.annotation.Nullable;
import java.util.concurrent.locks.ReentrantLock;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

/**
 * &lt;p&gt;A class which handles most of the complexity of creating a payment channel connection by providing a
 * simple in/out interface which is provided with protobufs from the server and which generates protobufs which should
 * be sent to the server.&lt;/p&gt;
 *
 * &lt;p&gt;Does all required verification of server messages and properly stores state objects in the wallet-attached
 * {@link StoredPaymentChannelClientStates} so that they are automatically closed when necessary and refund
 * transactions are not lost if the application crashes before it unlocks.&lt;/p&gt;
 *
 * &lt;p&gt;Though this interface is largely designed with stateful protocols (eg simple TCP connections) in mind, it is also
 * possible to use it with stateless protocols (eg sending protobufs when required over HTTP headers). In this case, the
 * &quot;connection&quot; translates roughly into the server-client relationship. See the javadocs for specific functions for more
 * details.&lt;/p&gt;
 */
public class PaymentChannelClient implements IPaymentChannelClient {
<span class="fc" id="L54">    private static final org.slf4j.Logger log = LoggerFactory.getLogger(PaymentChannelClient.class);</span>

<span class="fc" id="L56">    protected final ReentrantLock lock = Threading.lock(&quot;channelclient&quot;);</span>

    // Used to track the negotiated version number
    @GuardedBy(&quot;lock&quot;) private int majorVersion;

    @GuardedBy(&quot;lock&quot;) private final ClientConnection conn;

    // Used to keep track of whether or not the &quot;socket&quot; ie connection is open and we can generate messages
<span class="fc" id="L64">    @VisibleForTesting @GuardedBy(&quot;lock&quot;) boolean connectionOpen = false;</span>

    // The state object used to step through initialization and pay the server
    @GuardedBy(&quot;lock&quot;) private PaymentChannelClientState state;

    // The step we are at in initialization, this is partially duplicated in the state object
<span class="pc" id="L70">    private enum InitStep {</span>
<span class="fc" id="L71">        WAITING_FOR_CONNECTION_OPEN,</span>
<span class="fc" id="L72">        WAITING_FOR_VERSION_NEGOTIATION,</span>
<span class="fc" id="L73">        WAITING_FOR_INITIATE,</span>
<span class="fc" id="L74">        WAITING_FOR_REFUND_RETURN,</span>
<span class="fc" id="L75">        WAITING_FOR_CHANNEL_OPEN,</span>
<span class="fc" id="L76">        CHANNEL_OPEN,</span>
<span class="fc" id="L77">        WAITING_FOR_CHANNEL_CLOSE,</span>
<span class="fc" id="L78">        CHANNEL_CLOSED,</span>
    }
<span class="fc" id="L80">    @GuardedBy(&quot;lock&quot;) private InitStep step = InitStep.WAITING_FOR_CONNECTION_OPEN;</span>

<span class="pc" id="L82">    public enum VersionSelector {</span>
<span class="fc" id="L83">        VERSION_1,</span>
<span class="fc" id="L84">        VERSION_2_ALLOW_1,</span>
<span class="fc" id="L85">        VERSION_2;</span>

        public int getRequestedMajorVersion() {
<span class="pc bfc" id="L88" title="All 2 branches covered.">            switch (this) {</span>
                case VERSION_1:
<span class="fc" id="L90">                    return 1;</span>
                case VERSION_2_ALLOW_1:
                case VERSION_2:
                default:
<span class="fc" id="L94">                    return 2;</span>
            }
        }

        public int getRequestedMinorVersion() {
<span class="fc" id="L99">            return 0;</span>
        }

        public boolean isServerVersionAccepted(int major, int minor) {
<span class="pc bpc" id="L103" title="2 of 4 branches missed.">            switch (this) {</span>
                case VERSION_1:
<span class="fc bfc" id="L105" title="All 2 branches covered.">                    return major == 1;</span>
                case VERSION_2_ALLOW_1:
<span class="pc bpc" id="L107" title="1 of 4 branches missed.">                    return major == 1 || major == 2;</span>
                case VERSION_2:
<span class="nc bnc" id="L109" title="All 2 branches missed.">                    return major == 2;</span>
                default:
<span class="nc" id="L111">                    return false;</span>
            }
        }
    }

    private final VersionSelector versionSelector;

    // Will either hold the StoredClientChannel of this channel or null after connectionOpen
    private StoredClientChannel storedChannel;
    // An arbitrary hash which identifies this channel (specified by the API user)
    private final Sha256Hash serverId;

    // The wallet associated with this channel
    private final Wallet wallet;

    // Information used during channel initialization to send to the server or check what the server sends to us
    private final ECKey myKey;
    private final Coin maxValue;

    private Coin missing;

    // key to decrypt myKey, if it is encrypted, during setup.
    private KeyParameter userKeySetup;

    private final long timeWindow;

    @GuardedBy(&quot;lock&quot;) private long minPayment;

    @GuardedBy(&quot;lock&quot;) SettableFuture&lt;PaymentIncrementAck&gt; increasePaymentFuture;
    @GuardedBy(&quot;lock&quot;) Coin lastPaymentActualAmount;

    /**
     * &lt;p&gt;The default maximum amount of time for which we will accept the server locking up our funds for the multisig
     * contract.&lt;/p&gt;
     *
     * &lt;p&gt;24 hours less a minute  is the default as it is expected that clients limit risk exposure by limiting channel size instead of
     * limiting lock time when dealing with potentially malicious servers.&lt;/p&gt;
     */
    public static final long DEFAULT_TIME_WINDOW = 24*60*60-60;

    /**
     * Constructs a new channel manager which waits for {@link PaymentChannelClient#connectionOpen()} before acting.
     * A default time window of {@link #DEFAULT_TIME_WINDOW} will be used.
     *
     * @param wallet The wallet which will be paid from, and where completed transactions will be committed.
     *               Must already have a {@link StoredPaymentChannelClientStates} object in its extensions set.
     * @param myKey A freshly generated keypair used for the multisig contract and refund output.
     * @param maxValue The maximum value the server is allowed to request that we lock into this channel until the
     *                 refund transaction unlocks. Note that if there is a previously open channel, the refund
     *                 transaction used in this channel may be larger than maxValue. Thus, maxValue is not a method for
     *                 limiting the amount payable through this channel.
     * @param serverId An arbitrary hash representing this channel. This must uniquely identify the server. If an
     *                 existing stored channel exists in the wallet's {@link StoredPaymentChannelClientStates}, then an
     *                 attempt will be made to resume that channel.
     * @param conn A callback listener which represents the connection to the server (forwards messages we generate to
     *             the server)
     */
    public PaymentChannelClient(Wallet wallet, ECKey myKey, Coin maxValue, Sha256Hash serverId,
                                ClientConnection conn) {
<span class="nc" id="L170">        this(wallet,myKey,maxValue,serverId, conn, VersionSelector.VERSION_2_ALLOW_1);</span>
<span class="nc" id="L171">    }</span>

    /**
     * Constructs a new channel manager which waits for {@link PaymentChannelClient#connectionOpen()} before acting.
     * A default time window of {@link #DEFAULT_TIME_WINDOW} will be used.
     *
     * @param wallet The wallet which will be paid from, and where completed transactions will be committed.
     *               Must already have a {@link StoredPaymentChannelClientStates} object in its extensions set.
     * @param myKey A freshly generated keypair used for the multisig contract and refund output.
     * @param maxValue The maximum value the server is allowed to request that we lock into this channel until the
     *                 refund transaction unlocks. Note that if there is a previously open channel, the refund
     *                 transaction used in this channel may be larger than maxValue. Thus, maxValue is not a method for
     *                 limiting the amount payable through this channel.
     * @param serverId An arbitrary hash representing this channel. This must uniquely identify the server. If an
     *                 existing stored channel exists in the wallet's {@link StoredPaymentChannelClientStates}, then an
     *                 attempt will be made to resume that channel.
     * @param conn A callback listener which represents the connection to the server (forwards messages we generate to
     *             the server)
     * @param versionSelector An enum indicating which versions to support:
     *                        VERSION_1: use only version 1 of the protocol
     *                        VERSION_2_ALLOW_1: suggest version 2 but allow downgrade to version 1
     *                        VERSION_2: suggest version 2 and enforce use of version 2
     *
     */
    public PaymentChannelClient(Wallet wallet, ECKey myKey, Coin maxValue, Sha256Hash serverId,
                                ClientConnection conn, VersionSelector versionSelector) {
<span class="fc" id="L197">      this(wallet,myKey,maxValue,serverId, DEFAULT_TIME_WINDOW, null, conn, versionSelector);</span>
<span class="fc" id="L198">    }</span>

    /**
     * Constructs a new channel manager which waits for {@link PaymentChannelClient#connectionOpen()} before acting.
     *
     * @param wallet The wallet which will be paid from, and where completed transactions will be committed.
     *               Must already have a {@link StoredPaymentChannelClientStates} object in its extensions set.
     * @param myKey A freshly generated keypair used for the multisig contract and refund output.
     * @param maxValue The maximum value the server is allowed to request that we lock into this channel until the
     *                 refund transaction unlocks. Note that if there is a previously open channel, the refund
     *                 transaction used in this channel may be larger than maxValue. Thus, maxValue is not a method for
     *                 limiting the amount payable through this channel.
     * @param serverId An arbitrary hash representing this channel. This must uniquely identify the server. If an
     *                 existing stored channel exists in the wallet's {@link StoredPaymentChannelClientStates}, then an
     *                 attempt will be made to resume that channel.
     * @param timeWindow The time in seconds, relative to now, on how long this channel should be kept open. Note that is is
     *                   a proposal to the server. The server may in turn propose something different.
     *                   See {@link org.guldenj.protocols.channels.IPaymentChannelClient.ClientConnection#acceptExpireTime(long)}
     * @param userKeySetup Key derived from a user password, used to decrypt myKey, if it is encrypted, during setup.
     * @param conn A callback listener which represents the connection to the server (forwards messages we generate to
     *             the server)
     */
    public PaymentChannelClient(Wallet wallet, ECKey myKey, Coin maxValue, Sha256Hash serverId, long timeWindow,
                                @Nullable KeyParameter userKeySetup, ClientConnection conn) {
<span class="nc" id="L222">        this(wallet, myKey, maxValue, serverId, timeWindow, userKeySetup, conn, VersionSelector.VERSION_2_ALLOW_1);</span>
<span class="nc" id="L223">    }</span>

    /**
     * Constructs a new channel manager which waits for {@link PaymentChannelClient#connectionOpen()} before acting.
     *
     * @param wallet The wallet which will be paid from, and where completed transactions will be committed.
     *               Must already have a {@link StoredPaymentChannelClientStates} object in its extensions set.
     * @param myKey A freshly generated keypair used for the multisig contract and refund output.
     * @param maxValue The maximum value the server is allowed to request that we lock into this channel until the
     *                 refund transaction unlocks. Note that if there is a previously open channel, the refund
     *                 transaction used in this channel may be larger than maxValue. Thus, maxValue is not a method for
     *                 limiting the amount payable through this channel.
     * @param serverId An arbitrary hash representing this channel. This must uniquely identify the server. If an
     *                 existing stored channel exists in the wallet's {@link StoredPaymentChannelClientStates}, then an
     *                 attempt will be made to resume that channel.
     * @param timeWindow The time in seconds, relative to now, on how long this channel should be kept open. Note that is is
     *                   a proposal to the server. The server may in turn propose something different.
     *                   See {@link org.guldenj.protocols.channels.IPaymentChannelClient.ClientConnection#acceptExpireTime(long)}
     * @param userKeySetup Key derived from a user password, used to decrypt myKey, if it is encrypted, during setup.
     * @param conn A callback listener which represents the connection to the server (forwards messages we generate to
     *             the server)
     * @param versionSelector An enum indicating which versions to support:
     *                        VERSION_1: use only version 1 of the protocol
     *                        VERSION_2_ALLOW_1: suggest version 2 but allow downgrade to version 1
     *                        VERSION_2: suggest version 2 and enforce use of version 2
     */
    public PaymentChannelClient(Wallet wallet, ECKey myKey, Coin maxValue, Sha256Hash serverId, long timeWindow,
<span class="fc" id="L250">                                @Nullable KeyParameter userKeySetup, ClientConnection conn, VersionSelector versionSelector) {</span>
<span class="fc" id="L251">        this.wallet = checkNotNull(wallet);</span>
<span class="fc" id="L252">        this.myKey = checkNotNull(myKey);</span>
<span class="fc" id="L253">        this.maxValue = checkNotNull(maxValue);</span>
<span class="fc" id="L254">        this.serverId = checkNotNull(serverId);</span>
<span class="pc bpc" id="L255" title="1 of 2 branches missed.">        checkState(timeWindow &gt;= 0);</span>
<span class="fc" id="L256">        this.timeWindow = timeWindow;</span>
<span class="fc" id="L257">        this.conn = checkNotNull(conn);</span>
<span class="fc" id="L258">        this.userKeySetup = userKeySetup;</span>
<span class="fc" id="L259">        this.versionSelector = versionSelector;</span>
<span class="fc" id="L260">    }</span>

    /** 
     * &lt;p&gt;Returns the amount of satoshis missing when a server requests too much value.&lt;/p&gt;
     *
     * &lt;p&gt;When InsufficientMoneyException is thrown due to the server requesting too much value, an instance of 
     * PaymentChannelClient needs access to how many satoshis are missing.&lt;/p&gt;
     */
    public Coin getMissing() {
<span class="nc" id="L269">        return missing;</span>
    }

    @Nullable
    @GuardedBy(&quot;lock&quot;)
    private CloseReason receiveInitiate(Protos.Initiate initiate, Coin contractValue, Protos.Error.Builder errorBuilder)
            throws VerificationException, InsufficientMoneyException, ECKey.KeyIsEncryptedException {
<span class="fc" id="L276">        log.info(&quot;Got INITIATE message:\n{}&quot;, initiate.toString());</span>

<span class="pc bpc" id="L278" title="1 of 4 branches missed.">        if (wallet.isEncrypted() &amp;&amp; this.userKeySetup == null)</span>
<span class="nc" id="L279">            throw new ECKey.KeyIsEncryptedException();</span>

<span class="fc" id="L281">        final long expireTime = initiate.getExpireTimeSecs();</span>
<span class="pc bpc" id="L282" title="2 of 4 branches missed.">        checkState( expireTime &gt;= 0 &amp;&amp; initiate.getMinAcceptedChannelSize() &gt;= 0);</span>

<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (! conn.acceptExpireTime(expireTime)) {</span>
<span class="fc" id="L285">            log.error(&quot;Server suggested expire time was out of our allowed bounds: {} ({} s)&quot;, Utils.dateTimeFormat(expireTime * 1000), expireTime);</span>
<span class="fc" id="L286">            errorBuilder.setCode(Protos.Error.ErrorCode.TIME_WINDOW_UNACCEPTABLE);</span>
<span class="fc" id="L287">            return CloseReason.TIME_WINDOW_UNACCEPTABLE;</span>
        }

<span class="fc" id="L290">        Coin minChannelSize = Coin.valueOf(initiate.getMinAcceptedChannelSize());</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        if (contractValue.compareTo(minChannelSize) &lt; 0) {</span>
<span class="fc" id="L292">            log.error(&quot;Server requested too much value&quot;);</span>
<span class="fc" id="L293">            errorBuilder.setCode(Protos.Error.ErrorCode.CHANNEL_VALUE_TOO_LARGE);</span>
<span class="fc" id="L294">            missing = minChannelSize.subtract(contractValue);</span>
<span class="fc" id="L295">            return CloseReason.SERVER_REQUESTED_TOO_MUCH_VALUE;</span>
        }

        // For now we require a hard-coded value. In future this will have to get more complex and dynamic as the fees
        // start to float.
<span class="fc" id="L300">        final long MIN_PAYMENT = Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.value;</span>
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (initiate.getMinPayment() != MIN_PAYMENT) {</span>
<span class="nc" id="L302">            log.error(&quot;Server requested a min payment of {} but we expected {}&quot;, initiate.getMinPayment(), MIN_PAYMENT);</span>
<span class="nc" id="L303">            errorBuilder.setCode(Protos.Error.ErrorCode.MIN_PAYMENT_TOO_LARGE);</span>
<span class="nc" id="L304">            errorBuilder.setExpectedValue(MIN_PAYMENT);</span>
<span class="nc" id="L305">            missing = Coin.valueOf(initiate.getMinPayment() - MIN_PAYMENT);</span>
<span class="nc" id="L306">            return CloseReason.SERVER_REQUESTED_TOO_MUCH_VALUE;</span>
        }

<span class="fc" id="L309">        final byte[] pubKeyBytes = initiate.getMultisigKey().toByteArray();</span>
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (!ECKey.isPubKeyCanonical(pubKeyBytes))</span>
<span class="fc" id="L311">            throw new VerificationException(&quot;Server gave us a non-canonical public key, protocol error.&quot;);</span>
<span class="pc bpc" id="L312" title="1 of 3 branches missed.">        switch (majorVersion) {</span>
            case 1:
<span class="fc" id="L314">                state = new PaymentChannelV1ClientState(wallet, myKey, ECKey.fromPublicOnly(pubKeyBytes), contractValue, expireTime);</span>
<span class="fc" id="L315">                break;</span>
            case 2:
<span class="fc" id="L317">                state = new PaymentChannelV2ClientState(wallet, myKey, ECKey.fromPublicOnly(pubKeyBytes), contractValue, expireTime);</span>
<span class="fc" id="L318">                break;</span>
            default:
<span class="nc" id="L320">                return CloseReason.NO_ACCEPTABLE_VERSION;</span>
        }
        try {
<span class="fc" id="L323">            state.initiate(userKeySetup);</span>
<span class="nc" id="L324">        } catch (ValueOutOfRangeException e) {</span>
<span class="nc" id="L325">            log.error(&quot;Value out of range when trying to initiate&quot;, e);</span>
<span class="nc" id="L326">            errorBuilder.setCode(Protos.Error.ErrorCode.CHANNEL_VALUE_TOO_LARGE);</span>
<span class="nc" id="L327">            return CloseReason.SERVER_REQUESTED_TOO_MUCH_VALUE;</span>
<span class="fc" id="L328">        }</span>
<span class="fc" id="L329">        minPayment = initiate.getMinPayment();</span>
<span class="pc bpc" id="L330" title="1 of 3 branches missed.">        switch (majorVersion) {</span>
            case 1:
<span class="fc" id="L332">                step = InitStep.WAITING_FOR_REFUND_RETURN;</span>

<span class="fc" id="L334">                Protos.ProvideRefund.Builder provideRefundBuilder = Protos.ProvideRefund.newBuilder()</span>
<span class="fc" id="L335">                        .setMultisigKey(ByteString.copyFrom(myKey.getPubKey()))</span>
<span class="fc" id="L336">                        .setTx(ByteString.copyFrom(((PaymentChannelV1ClientState)state).getIncompleteRefundTransaction().bitcoinSerialize()));</span>

<span class="fc" id="L338">                conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L339">                        .setProvideRefund(provideRefundBuilder)</span>
<span class="fc" id="L340">                        .setType(Protos.TwoWayChannelMessage.MessageType.PROVIDE_REFUND)</span>
<span class="fc" id="L341">                        .build());</span>
<span class="fc" id="L342">                break;</span>
            case 2:
<span class="fc" id="L344">                step = InitStep.WAITING_FOR_CHANNEL_OPEN;</span>

                // Before we can send the server the contract (ie send it to the network), we must ensure that our refund
                // transaction is safely in the wallet - thus we store it (this also keeps it up-to-date when we pay)
<span class="fc" id="L348">                state.storeChannelInWallet(serverId);</span>

<span class="fc" id="L350">                Protos.ProvideContract.Builder provideContractBuilder = Protos.ProvideContract.newBuilder()</span>
<span class="fc" id="L351">                        .setTx(ByteString.copyFrom(state.getContract().bitcoinSerialize()))</span>
<span class="fc" id="L352">                        .setClientKey(ByteString.copyFrom(myKey.getPubKey()));</span>
                try {
                    // Make an initial payment of the dust limit, and put it into the message as well. The size of the
                    // server-requested dust limit was already sanity checked by this point.
<span class="fc" id="L356">                    PaymentChannelClientState.IncrementedPayment payment = state().incrementPaymentBy(Coin.valueOf(minPayment), userKeySetup);</span>
<span class="fc" id="L357">                    Protos.UpdatePayment.Builder initialMsg = provideContractBuilder.getInitialPaymentBuilder();</span>
<span class="fc" id="L358">                    initialMsg.setSignature(ByteString.copyFrom(payment.signature.encodeToBitcoin()));</span>
<span class="fc" id="L359">                    initialMsg.setClientChangeValue(state.getValueRefunded().value);</span>
<span class="nc" id="L360">                } catch (ValueOutOfRangeException e) {</span>
<span class="nc" id="L361">                    throw new IllegalStateException(e);  // This cannot happen.</span>
<span class="fc" id="L362">                }</span>

                // Not used any more
<span class="fc" id="L365">                userKeySetup = null;</span>

<span class="fc" id="L367">                final Protos.TwoWayChannelMessage.Builder msg = Protos.TwoWayChannelMessage.newBuilder();</span>
<span class="fc" id="L368">                msg.setProvideContract(provideContractBuilder);</span>
<span class="fc" id="L369">                msg.setType(Protos.TwoWayChannelMessage.MessageType.PROVIDE_CONTRACT);</span>
<span class="fc" id="L370">                conn.sendToServer(msg.build());</span>
<span class="fc" id="L371">                break;</span>
            default:
<span class="nc" id="L373">                return CloseReason.NO_ACCEPTABLE_VERSION;</span>
        }
<span class="fc" id="L375">        return null;</span>
    }

    @GuardedBy(&quot;lock&quot;)
    private void receiveRefund(Protos.TwoWayChannelMessage refundMsg, @Nullable KeyParameter userKey) throws VerificationException {
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        checkState(majorVersion == 1);</span>
<span class="pc bpc" id="L381" title="2 of 4 branches missed.">        checkState(step == InitStep.WAITING_FOR_REFUND_RETURN &amp;&amp; refundMsg.hasReturnRefund());</span>
<span class="fc" id="L382">        log.info(&quot;Got RETURN_REFUND message, providing signed contract&quot;);</span>
<span class="fc" id="L383">        Protos.ReturnRefund returnedRefund = refundMsg.getReturnRefund();</span>
        // Cast is safe since we've checked the version number
<span class="fc" id="L385">        ((PaymentChannelV1ClientState)state).provideRefundSignature(returnedRefund.getSignature().toByteArray(), userKey);</span>
<span class="fc" id="L386">        step = InitStep.WAITING_FOR_CHANNEL_OPEN;</span>

        // Before we can send the server the contract (ie send it to the network), we must ensure that our refund
        // transaction is safely in the wallet - thus we store it (this also keeps it up-to-date when we pay)
<span class="fc" id="L390">        state.storeChannelInWallet(serverId);</span>

<span class="fc" id="L392">        Protos.ProvideContract.Builder contractMsg = Protos.ProvideContract.newBuilder()</span>
<span class="fc" id="L393">                .setTx(ByteString.copyFrom(state.getContract().bitcoinSerialize()));</span>
        try {
            // Make an initial payment of the dust limit, and put it into the message as well. The size of the
            // server-requested dust limit was already sanity checked by this point.
<span class="fc" id="L397">            PaymentChannelClientState.IncrementedPayment payment = state().incrementPaymentBy(Coin.valueOf(minPayment), userKey);</span>
<span class="fc" id="L398">            Protos.UpdatePayment.Builder initialMsg = contractMsg.getInitialPaymentBuilder();</span>
<span class="fc" id="L399">            initialMsg.setSignature(ByteString.copyFrom(payment.signature.encodeToBitcoin()));</span>
<span class="fc" id="L400">            initialMsg.setClientChangeValue(state.getValueRefunded().value);</span>
<span class="nc" id="L401">        } catch (ValueOutOfRangeException e) {</span>
<span class="nc" id="L402">            throw new IllegalStateException(e);  // This cannot happen.</span>
<span class="fc" id="L403">        }</span>

<span class="fc" id="L405">        final Protos.TwoWayChannelMessage.Builder msg = Protos.TwoWayChannelMessage.newBuilder();</span>
<span class="fc" id="L406">        msg.setProvideContract(contractMsg);</span>
<span class="fc" id="L407">        msg.setType(Protos.TwoWayChannelMessage.MessageType.PROVIDE_CONTRACT);</span>
<span class="fc" id="L408">        conn.sendToServer(msg.build());</span>
<span class="fc" id="L409">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void receiveChannelOpen() throws VerificationException {
<span class="pc bpc" id="L413" title="1 of 6 branches missed.">        checkState(step == InitStep.WAITING_FOR_CHANNEL_OPEN || (step == InitStep.WAITING_FOR_INITIATE &amp;&amp; storedChannel != null), step);</span>
<span class="fc" id="L414">        log.info(&quot;Got CHANNEL_OPEN message, ready to pay&quot;);</span>

<span class="fc" id="L416">        boolean wasInitiated = true;</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (step == InitStep.WAITING_FOR_INITIATE) {</span>
            // We skipped the initiate step, because a previous channel that's still valid was resumed.
<span class="fc" id="L419">            wasInitiated  = false;</span>
<span class="pc bpc" id="L420" title="1 of 3 branches missed.">            switch (majorVersion) {</span>
                case 1:
<span class="fc" id="L422">                    state = new PaymentChannelV1ClientState(storedChannel, wallet);</span>
<span class="fc" id="L423">                    break;</span>
                case 2:
<span class="fc" id="L425">                    state = new PaymentChannelV2ClientState(storedChannel, wallet);</span>
<span class="fc" id="L426">                    break;</span>
                default:
<span class="nc" id="L428">                    throw new IllegalStateException(&quot;Invalid version number &quot; + majorVersion);</span>
            }
        }
<span class="fc" id="L431">        step = InitStep.CHANNEL_OPEN;</span>
        // channelOpen should disable timeouts, but
        // TODO accomodate high latency between PROVIDE_CONTRACT and here
<span class="fc" id="L434">        conn.channelOpen(wasInitiated);</span>
<span class="fc" id="L435">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void receiveMessage(Protos.TwoWayChannelMessage msg) throws InsufficientMoneyException {
<span class="fc" id="L442">        lock.lock();</span>
        try {
<span class="fc" id="L444">            checkState(connectionOpen);</span>
            // If we generate an error, we set errorBuilder and closeReason and break, otherwise we return
            Protos.Error.Builder errorBuilder;
            CloseReason closeReason;
            try {
<span class="pc bfc" id="L449" title="All 8 branches covered.">                switch (msg.getType()) {</span>
                    case SERVER_VERSION:
<span class="pc bpc" id="L451" title="2 of 4 branches missed.">                        checkState(step == InitStep.WAITING_FOR_VERSION_NEGOTIATION &amp;&amp; msg.hasServerVersion());</span>
                        // Server might send back a major version lower than our own if they want to fallback to a
                        // lower version. We can't handle that, so we just close the channel.
<span class="fc" id="L454">                        majorVersion = msg.getServerVersion().getMajor();</span>
<span class="fc bfc" id="L455" title="All 2 branches covered.">                        if (!versionSelector.isServerVersionAccepted(majorVersion, msg.getServerVersion().getMinor())) {</span>
<span class="fc" id="L456">                            errorBuilder = Protos.Error.newBuilder()</span>
<span class="fc" id="L457">                                    .setCode(Protos.Error.ErrorCode.NO_ACCEPTABLE_VERSION);</span>
<span class="fc" id="L458">                            closeReason = CloseReason.NO_ACCEPTABLE_VERSION;</span>
<span class="fc" id="L459">                            break;</span>
                        }
<span class="fc" id="L461">                        log.info(&quot;Got version handshake, awaiting INITIATE or resume CHANNEL_OPEN&quot;);</span>
<span class="fc" id="L462">                        step = InitStep.WAITING_FOR_INITIATE;</span>
<span class="fc" id="L463">                        return;</span>
                    case INITIATE:
<span class="pc bpc" id="L465" title="1 of 4 branches missed.">                        checkState(step == InitStep.WAITING_FOR_INITIATE &amp;&amp; msg.hasInitiate());</span>
<span class="fc" id="L466">                        Protos.Initiate initiate = msg.getInitiate();</span>
<span class="fc" id="L467">                        errorBuilder = Protos.Error.newBuilder();</span>
<span class="fc" id="L468">                        closeReason = receiveInitiate(initiate, maxValue, errorBuilder);</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">                        if (closeReason == null)</span>
<span class="fc" id="L470">                            return;</span>
<span class="fc" id="L471">                        log.error(&quot;Initiate failed with error: {}&quot;, errorBuilder.build().toString());</span>
<span class="fc" id="L472">                        break;</span>
                    case RETURN_REFUND:
<span class="fc" id="L474">                        receiveRefund(msg, userKeySetup);</span>
                        // Key not used anymore
<span class="fc" id="L476">                        userKeySetup = null;</span>
<span class="fc" id="L477">                        return;</span>
                    case CHANNEL_OPEN:
<span class="fc" id="L479">                        receiveChannelOpen();</span>
<span class="fc" id="L480">                        return;</span>
                    case PAYMENT_ACK:
<span class="fc" id="L482">                        receivePaymentAck(msg.getPaymentAck());</span>
<span class="fc" id="L483">                        return;</span>
                    case CLOSE:
<span class="fc" id="L485">                        receiveClose(msg);</span>
<span class="fc" id="L486">                        return;</span>
                    case ERROR:
<span class="fc" id="L488">                        checkState(msg.hasError());</span>
<span class="fc" id="L489">                        log.error(&quot;Server sent ERROR {} with explanation {}&quot;, msg.getError().getCode().name(),</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">                                msg.getError().hasExplanation() ? msg.getError().getExplanation() : &quot;&quot;);</span>
<span class="fc" id="L491">                        setIncreasePaymentFutureIfNeeded(CloseReason.REMOTE_SENT_ERROR, msg.getError().getCode().name());</span>
<span class="fc" id="L492">                        conn.destroyConnection(CloseReason.REMOTE_SENT_ERROR);</span>
<span class="fc" id="L493">                        return;</span>
                    default:
<span class="fc" id="L495">                        log.error(&quot;Got unknown message type or type that doesn't apply to clients.&quot;);</span>
<span class="fc" id="L496">                        errorBuilder = Protos.Error.newBuilder()</span>
<span class="fc" id="L497">                                .setCode(Protos.Error.ErrorCode.SYNTAX_ERROR);</span>
<span class="fc" id="L498">                        setIncreasePaymentFutureIfNeeded(CloseReason.REMOTE_SENT_INVALID_MESSAGE, &quot;&quot;);</span>
<span class="fc" id="L499">                        closeReason = CloseReason.REMOTE_SENT_INVALID_MESSAGE;</span>
                        break;
                }
<span class="fc" id="L502">            } catch (VerificationException e) {</span>
<span class="fc" id="L503">                log.error(&quot;Caught verification exception handling message from server&quot;, e);</span>
<span class="fc" id="L504">                errorBuilder = Protos.Error.newBuilder()</span>
<span class="fc" id="L505">                        .setCode(Protos.Error.ErrorCode.BAD_TRANSACTION)</span>
<span class="fc" id="L506">                        .setExplanation(e.getMessage());</span>
<span class="fc" id="L507">                closeReason = CloseReason.REMOTE_SENT_INVALID_MESSAGE;</span>
<span class="fc" id="L508">            } catch (IllegalStateException e) {</span>
<span class="fc" id="L509">                log.error(&quot;Caught illegal state exception handling message from server&quot;, e);</span>
<span class="fc" id="L510">                errorBuilder = Protos.Error.newBuilder()</span>
<span class="fc" id="L511">                        .setCode(Protos.Error.ErrorCode.SYNTAX_ERROR);</span>
<span class="fc" id="L512">                closeReason = CloseReason.REMOTE_SENT_INVALID_MESSAGE;</span>
<span class="fc" id="L513">            }</span>
<span class="fc" id="L514">            conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L515">                    .setError(errorBuilder)</span>
<span class="fc" id="L516">                    .setType(Protos.TwoWayChannelMessage.MessageType.ERROR)</span>
<span class="fc" id="L517">                    .build());</span>
<span class="fc" id="L518">            conn.destroyConnection(closeReason);</span>
        } finally {
<span class="fc" id="L520">            lock.unlock();</span>
<span class="fc" id="L521">        }</span>
<span class="fc" id="L522">    }</span>

    /*
     * If this is an ongoing payment channel increase we need to call setException() on its future.
     *
     * @param reason is the reason for aborting
     * @param message is the detailed message
     */
    private void setIncreasePaymentFutureIfNeeded(PaymentChannelCloseException.CloseReason reason, String message) {
<span class="pc bpc" id="L531" title="1 of 4 branches missed.">        if (increasePaymentFuture != null &amp;&amp; !increasePaymentFuture.isDone()) {</span>
<span class="fc" id="L532">            increasePaymentFuture.setException(new PaymentChannelCloseException(message, reason));</span>
        }
<span class="fc" id="L534">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void receiveClose(Protos.TwoWayChannelMessage msg) throws VerificationException {
<span class="fc" id="L538">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc bfc" id="L539" title="All 2 branches covered.">        if (msg.hasSettlement()) {</span>
<span class="fc" id="L540">            Transaction settleTx = wallet.getParams().getDefaultSerializer().makeTransaction(msg.getSettlement().getTx().toByteArray());</span>
<span class="fc" id="L541">            log.info(&quot;CLOSE message received with settlement tx {}&quot;, settleTx.getHash());</span>
            // TODO: set source
<span class="pc bpc" id="L543" title="2 of 4 branches missed.">            if (state != null &amp;&amp; state().isSettlementTransaction(settleTx)) {</span>
                // The wallet has a listener on it that the state object will use to do the right thing at this
                // point (like watching it for confirmations). The tx has been checked by now for syntactical validity
                // and that it correctly spends the multisig contract.
<span class="fc" id="L547">                wallet.receivePending(settleTx, null);</span>
            }
<span class="fc" id="L549">        } else {</span>
<span class="fc" id="L550">            log.info(&quot;CLOSE message received without settlement tx&quot;);</span>
        }
<span class="fc bfc" id="L552" title="All 2 branches covered.">        if (step == InitStep.WAITING_FOR_CHANNEL_CLOSE)</span>
<span class="fc" id="L553">            conn.destroyConnection(CloseReason.CLIENT_REQUESTED_CLOSE);</span>
        else
<span class="fc" id="L555">            conn.destroyConnection(CloseReason.SERVER_REQUESTED_CLOSE);</span>
<span class="fc" id="L556">        step = InitStep.CHANNEL_CLOSED;</span>
<span class="fc" id="L557">    }</span>

    /**
     * &lt;p&gt;Called when the connection terminates. Notifies the {@link StoredClientChannel} object that we can attempt to
     * resume this channel in the future and stops generating messages for the server.&lt;/p&gt;
     *
     * &lt;p&gt;For stateless protocols, this translates to a client not using the channel for the immediate future, but
     * intending to reopen the channel later. There is likely little reason to use this in a stateless protocol.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this &lt;b&gt;MUST&lt;/b&gt; still be called even after either
     * {@link ClientConnection#destroyConnection(org.guldenj.protocols.channels.PaymentChannelCloseException.CloseReason)} or
     * {@link PaymentChannelClient#settle()} is called, to actually handle the connection close logic.&lt;/p&gt;
     */
    @Override
    public void connectionClosed() {
<span class="fc" id="L572">        lock.lock();</span>
        try {
<span class="fc" id="L574">            connectionOpen = false;</span>
<span class="pc bpc" id="L575" title="1 of 2 branches missed.">            if (state != null)</span>
<span class="fc" id="L576">                state.disconnectFromChannel();</span>
        } finally {
<span class="pc" id="L578">            lock.unlock();</span>
<span class="fc" id="L579">        }</span>
<span class="fc" id="L580">    }</span>

    /**
     * &lt;p&gt;Closes the connection, notifying the server it should settle the channel by broadcasting the most recent
     * payment transaction.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this only generates a CLOSE message for the server and calls
     * {@link ClientConnection#destroyConnection(CloseReason)} to settle the connection, it does not
     * actually handle connection close logic, and {@link PaymentChannelClient#connectionClosed()} must still be called
     * after the connection fully closes.&lt;/p&gt;
     *
     * @throws IllegalStateException If the connection is not currently open (ie the CLOSE message cannot be sent)
     */
    @Override
    public void settle() throws IllegalStateException {
<span class="fc" id="L595">        lock.lock();</span>
        try {
<span class="fc" id="L597">            checkState(connectionOpen);</span>
<span class="fc" id="L598">            step = InitStep.WAITING_FOR_CHANNEL_CLOSE;</span>
<span class="fc" id="L599">            log.info(&quot;Sending a CLOSE message to the server and waiting for response indicating successful settlement.&quot;);</span>
<span class="fc" id="L600">            conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L601">                    .setType(Protos.TwoWayChannelMessage.MessageType.CLOSE)</span>
<span class="fc" id="L602">                    .build());</span>
        } finally {
<span class="pc" id="L604">            lock.unlock();</span>
<span class="fc" id="L605">        }</span>
<span class="fc" id="L606">    }</span>

    /**
     * &lt;p&gt;Called to indicate the connection has been opened and messages can now be generated for the server.&lt;/p&gt;
     *
     * &lt;p&gt;Attempts to find a channel to resume and generates a CLIENT_VERSION message for the server based on the
     * result.&lt;/p&gt;
     */
    @Override
    public void connectionOpen() {
<span class="fc" id="L616">        lock.lock();</span>
        try {
<span class="fc" id="L618">            connectionOpen = true;</span>

<span class="fc" id="L620">            StoredPaymentChannelClientStates channels = (StoredPaymentChannelClientStates) wallet.getExtensions().get(StoredPaymentChannelClientStates.EXTENSION_ID);</span>
<span class="fc bfc" id="L621" title="All 2 branches covered.">            if (channels != null)</span>
<span class="fc" id="L622">                storedChannel = channels.getUsableChannelForServerID(serverId);</span>

<span class="fc" id="L624">            step = InitStep.WAITING_FOR_VERSION_NEGOTIATION;</span>

<span class="fc" id="L626">            Protos.ClientVersion.Builder versionNegotiationBuilder = Protos.ClientVersion.newBuilder()</span>
<span class="fc" id="L627">                    .setMajor(versionSelector.getRequestedMajorVersion())</span>
<span class="fc" id="L628">                    .setMinor(versionSelector.getRequestedMinorVersion())</span>
<span class="fc" id="L629">                    .setTimeWindowSecs(timeWindow);</span>

<span class="fc bfc" id="L631" title="All 2 branches covered.">            if (storedChannel != null) {</span>
<span class="fc" id="L632">                versionNegotiationBuilder.setPreviousChannelContractHash(ByteString.copyFrom(storedChannel.contract.getHash().getBytes()));</span>
<span class="fc" id="L633">                log.info(&quot;Begun version handshake, attempting to reopen channel with contract hash {}&quot;, storedChannel.contract.getHash());</span>
            } else
<span class="fc" id="L635">                log.info(&quot;Begun version handshake creating new channel&quot;);</span>

<span class="fc" id="L637">            conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L638">                    .setType(Protos.TwoWayChannelMessage.MessageType.CLIENT_VERSION)</span>
<span class="fc" id="L639">                    .setClientVersion(versionNegotiationBuilder)</span>
<span class="fc" id="L640">                    .build());</span>
        } finally {
<span class="pc" id="L642">            lock.unlock();</span>
<span class="fc" id="L643">        }</span>
<span class="fc" id="L644">    }</span>

    /**
     * &lt;p&gt;Gets the {@link PaymentChannelClientState} object which stores the current state of the connection with the
     * server.&lt;/p&gt;
     *
     * &lt;p&gt;Note that if you call any methods which update state directly the server will not be notified and channel
     * initialization logic in the connection may fail unexpectedly.&lt;/p&gt;
     */
    public PaymentChannelClientState state() {
<span class="fc" id="L654">        lock.lock();</span>
        try {
<span class="fc" id="L656">            return state;</span>
        } finally {
<span class="pc" id="L658">            lock.unlock();</span>
        }
    }

    /**
     * Increments the total value which we pay the server. Note that the amount of money sent may not be the same as the
     * amount of money actually requested. It can be larger if the amount left over in the channel would be too small to
     * be accepted by the Bitcoin network. ValueOutOfRangeException will be thrown, however, if there's not enough money
     * left in the channel to make the payment at all. Only one payment can be in-flight at once. You have to ensure
     * you wait for the previous increase payment future to complete before incrementing the payment again.
     *
     * @param size How many satoshis to increment the payment by (note: not the new total).
     * @return a future that completes when the server acknowledges receipt and acceptance of the payment.
     * @throws ValueOutOfRangeException If the size is negative or would pay more than this channel's total value
     *                                  ({@link PaymentChannelClientConnection#state()}.getTotalValue())
     * @throws IllegalStateException If the channel has been closed or is not yet open
     *                               (see {@link PaymentChannelClientConnection#getChannelOpenFuture()} for the second)
     */
    public ListenableFuture&lt;PaymentIncrementAck&gt; incrementPayment(Coin size) throws ValueOutOfRangeException, IllegalStateException {
<span class="fc" id="L677">        return incrementPayment(size, null, null);</span>
    }

    /**
     * Increments the total value which we pay the server. Note that the amount of money sent may not be the same as the
     * amount of money actually requested. It can be larger if the amount left over in the channel would be too small to
     * be accepted by the Bitcoin network. ValueOutOfRangeException will be thrown, however, if there's not enough money
     * left in the channel to make the payment at all. Only one payment can be in-flight at once. You have to ensure
     * you wait for the previous increase payment future to complete before incrementing the payment again.
     *
     * @param size How many satoshis to increment the payment by (note: not the new total).
     * @param info Information about this update, used to extend this protocol.
     * @param userKey Key derived from a user password, needed for any signing when the wallet is encrypted.
     *                The wallet KeyCrypter is assumed.
     * @return a future that completes when the server acknowledges receipt and acceptance of the payment.
     * @throws ValueOutOfRangeException If the size is negative or would pay more than this channel's total value
     *                                  ({@link PaymentChannelClientConnection#state()}.getTotalValue())
     * @throws IllegalStateException If the channel has been closed or is not yet open
     *                               (see {@link PaymentChannelClientConnection#getChannelOpenFuture()} for the second)
     * @throws ECKey.KeyIsEncryptedException If the keys are encrypted and no AES key has been provided,
     */
    @Override
    public ListenableFuture&lt;PaymentIncrementAck&gt; incrementPayment(Coin size, @Nullable ByteString info, @Nullable KeyParameter userKey)
            throws ValueOutOfRangeException, IllegalStateException, ECKey.KeyIsEncryptedException {
<span class="fc" id="L701">        lock.lock();</span>
        try {
<span class="pc bpc" id="L703" title="2 of 6 branches missed.">            if (state() == null || !connectionOpen || step != InitStep.CHANNEL_OPEN)</span>
<span class="fc" id="L704">                throw new IllegalStateException(&quot;Channel is not fully initialized/has already been closed&quot;);</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">            if (increasePaymentFuture != null)</span>
<span class="nc" id="L706">                throw new IllegalStateException(&quot;Already incrementing paying, wait for previous payment to complete.&quot;);</span>
<span class="pc bpc" id="L707" title="1 of 4 branches missed.">            if (wallet.isEncrypted() &amp;&amp; userKey == null)</span>
<span class="nc" id="L708">                throw new ECKey.KeyIsEncryptedException();</span>

<span class="fc" id="L710">            PaymentChannelV1ClientState.IncrementedPayment payment = state().incrementPaymentBy(size, userKey);</span>
<span class="fc" id="L711">            Protos.UpdatePayment.Builder updatePaymentBuilder = Protos.UpdatePayment.newBuilder()</span>
<span class="fc" id="L712">                    .setSignature(ByteString.copyFrom(payment.signature.encodeToBitcoin()))</span>
<span class="fc" id="L713">                    .setClientChangeValue(state.getValueRefunded().value);</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">            if (info != null) updatePaymentBuilder.setInfo(info);</span>

<span class="fc" id="L716">            increasePaymentFuture = SettableFuture.create();</span>
<span class="fc" id="L717">            increasePaymentFuture.addListener(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L720">                    lock.lock();</span>
<span class="fc" id="L721">                    increasePaymentFuture = null;</span>
<span class="fc" id="L722">                    lock.unlock();</span>
<span class="fc" id="L723">                }</span>
<span class="fc" id="L724">            }, MoreExecutors.sameThreadExecutor());</span>

<span class="fc" id="L726">            conn.sendToServer(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L727">                    .setUpdatePayment(updatePaymentBuilder)</span>
<span class="fc" id="L728">                    .setType(Protos.TwoWayChannelMessage.MessageType.UPDATE_PAYMENT)</span>
<span class="fc" id="L729">                    .build());</span>
<span class="fc" id="L730">            lastPaymentActualAmount = payment.amount;</span>
<span class="fc" id="L731">            return increasePaymentFuture;</span>
        } finally {
<span class="fc" id="L733">            lock.unlock();</span>
        }
    }

    private void receivePaymentAck(Protos.PaymentAck paymentAck) {
        SettableFuture&lt;PaymentIncrementAck&gt; future;
        Coin value;

<span class="fc" id="L741">        lock.lock();</span>
        try {
<span class="pc bpc" id="L743" title="1 of 2 branches missed.">            if (increasePaymentFuture == null) return;</span>
<span class="fc" id="L744">            checkNotNull(increasePaymentFuture, &quot;Server sent a PAYMENT_ACK with no outstanding payment&quot;);</span>
<span class="fc" id="L745">            log.info(&quot;Received a PAYMENT_ACK from the server&quot;);</span>
<span class="fc" id="L746">            future = increasePaymentFuture;</span>
<span class="fc" id="L747">            value = lastPaymentActualAmount;</span>
        } finally {
<span class="pc" id="L749">            lock.unlock();</span>
<span class="fc" id="L750">        }</span>

        // Ensure the future runs without the client lock held.
<span class="fc" id="L753">        future.set(new PaymentIncrementAck(value, paymentAck.getInfo()));</span>
<span class="fc" id="L754">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>