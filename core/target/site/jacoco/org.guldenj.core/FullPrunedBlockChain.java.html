<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FullPrunedBlockChain.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">guldenj</a> &gt; <a href="index.source.html" class="el_package">org.guldenj.core</a> &gt; <span class="el_source">FullPrunedBlockChain.java</span></div><h1>FullPrunedBlockChain.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2012 Matt Corallo.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.guldenj.core;

import org.guldenj.script.Script;
import org.guldenj.script.Script.VerifyFlag;
import org.guldenj.store.BlockStoreException;
import org.guldenj.store.FullPrunedBlockStore;
import org.guldenj.utils.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;
import java.util.concurrent.*;

import static com.google.common.base.Preconditions.checkState;

/**
 * &lt;p&gt;A FullPrunedBlockChain works in conjunction with a {@link FullPrunedBlockStore} to verify all the rules of the
 * Bitcoin system, with the downside being a large cost in system resources. Fully verifying means all unspent
 * transaction outputs are stored. Once a transaction output is spent and that spend is buried deep enough, the data
 * related to it is deleted to ensure disk space usage doesn't grow forever. For this reason a pruning node cannot
 * serve the full block chain to other clients, but it nevertheless provides the same security guarantees as Bitcoin
 * Core does.&lt;/p&gt;
 */
public class FullPrunedBlockChain extends AbstractBlockChain {
<span class="fc" id="L47">    private static final Logger log = LoggerFactory.getLogger(FullPrunedBlockChain.class);</span>

    /**
     * Keeps a map of block hashes to StoredBlocks.
     */
    protected final FullPrunedBlockStore blockStore;

    // Whether or not to execute scriptPubKeys before accepting a transaction (i.e. check signatures).
<span class="fc" id="L55">    private boolean runScripts = true;</span>

    /**
     * Constructs a block chain connected to the given wallet and store. To obtain a {@link Wallet} you can construct
     * one from scratch, or you can deserialize a saved wallet from disk using
     * {@link Wallet#loadFromFile(java.io.File, WalletExtension...)}
     */
    public FullPrunedBlockChain(Context context, Wallet wallet, FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="nc" id="L63">        this(context, new ArrayList&lt;Wallet&gt;(), blockStore);</span>
<span class="nc" id="L64">        addWallet(wallet);</span>
<span class="nc" id="L65">    }</span>

    /**
     * Constructs a block chain connected to the given wallet and store. To obtain a {@link Wallet} you can construct
     * one from scratch, or you can deserialize a saved wallet from disk using
     * {@link Wallet#loadFromFile(java.io.File, WalletExtension...)}
     */
    public FullPrunedBlockChain(NetworkParameters params, Wallet wallet, FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="nc" id="L73">        this(Context.getOrCreate(params), wallet, blockStore);</span>
<span class="nc" id="L74">    }</span>

    /**
     * Constructs a block chain connected to the given store.
     */
    public FullPrunedBlockChain(Context context, FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="fc" id="L80">        this(context, new ArrayList&lt;Wallet&gt;(), blockStore);</span>
<span class="fc" id="L81">    }</span>

    /**
     * See {@link #FullPrunedBlockChain(Context, Wallet, FullPrunedBlockStore)}
     */
    public FullPrunedBlockChain(NetworkParameters params, FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="fc" id="L87">        this(Context.getOrCreate(params), blockStore);</span>
<span class="fc" id="L88">    }</span>

    /**
     * Constructs a block chain connected to the given list of wallets and a store.
     */
    public FullPrunedBlockChain(Context context, List&lt;Wallet&gt; listeners, FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="fc" id="L94">        super(context, listeners, blockStore);</span>
<span class="fc" id="L95">        this.blockStore = blockStore;</span>
        // Ignore upgrading for now
<span class="fc" id="L97">        this.chainHead = blockStore.getVerifiedChainHead();</span>
<span class="fc" id="L98">    }</span>

    /**
     * See {@link #FullPrunedBlockChain(Context, List, FullPrunedBlockStore)}
     */
    public FullPrunedBlockChain(NetworkParameters params, List&lt;Wallet&gt; listeners,
                                FullPrunedBlockStore blockStore) throws BlockStoreException {
<span class="nc" id="L105">        this(Context.getOrCreate(params), listeners, blockStore);</span>
<span class="nc" id="L106">    }</span>

    @Override
    protected StoredBlock addToBlockStore(StoredBlock storedPrev, Block header, TransactionOutputChanges txOutChanges)
            throws BlockStoreException, VerificationException {
<span class="fc" id="L111">        StoredBlock newBlock = storedPrev.build(header);</span>
<span class="fc" id="L112">        blockStore.put(newBlock, new StoredUndoableBlock(newBlock.getHeader().getHash(), txOutChanges));</span>
<span class="fc" id="L113">        return newBlock;</span>
    }

    @Override
    protected StoredBlock addToBlockStore(StoredBlock storedPrev, Block block)
            throws BlockStoreException, VerificationException {
<span class="fc" id="L119">        StoredBlock newBlock = storedPrev.build(block);</span>
<span class="fc" id="L120">        blockStore.put(newBlock, new StoredUndoableBlock(newBlock.getHeader().getHash(), block.transactions));</span>
<span class="fc" id="L121">        return newBlock;</span>
    }

    @Override
    protected void rollbackBlockStore(int height) throws BlockStoreException {
<span class="nc" id="L126">        throw new BlockStoreException(&quot;Unsupported&quot;);</span>
    }

    @Override
    protected boolean shouldVerifyTransactions() {
<span class="fc" id="L131">        return true;</span>
    }

    /**
     * Whether or not to run scripts whilst accepting blocks (i.e. checking signatures, for most transactions).
     * If you're accepting data from an untrusted node, such as one found via the P2P network, this should be set
     * to true (which is the default). If you're downloading a chain from a node you control, script execution
     * is redundant because you know the connected node won't relay bad data to you. In that case it's safe to set
     * this to false and obtain a significant speedup.
     */
    public void setRunScripts(boolean value) {
<span class="fc" id="L142">        this.runScripts = value;</span>
<span class="fc" id="L143">    }</span>

    // TODO: Remove lots of duplicated code in the two connectTransactions

    // TODO: execute in order of largest transaction (by input count) first
<span class="fc" id="L148">    ExecutorService scriptVerificationExecutor = Executors.newFixedThreadPool(</span>
<span class="fc" id="L149">            Runtime.getRuntime().availableProcessors(), new ContextPropagatingThreadFactory(&quot;Script verification&quot;));</span>

    /**
     * A job submitted to the executor which verifies signatures.
     */
    private static class Verifier implements Callable&lt;VerificationException&gt; {
        final Transaction tx;
        final List&lt;Script&gt; prevOutScripts;
        final Set&lt;VerifyFlag&gt; verifyFlags;

<span class="fc" id="L159">        public Verifier(final Transaction tx, final List&lt;Script&gt; prevOutScripts, final Set&lt;VerifyFlag&gt; verifyFlags) {</span>
<span class="fc" id="L160">            this.tx = tx;</span>
<span class="fc" id="L161">            this.prevOutScripts = prevOutScripts;</span>
<span class="fc" id="L162">            this.verifyFlags = verifyFlags;</span>
<span class="fc" id="L163">        }</span>

        @Nullable
        @Override
        public VerificationException call() throws Exception {
            try {
<span class="fc" id="L169">                ListIterator&lt;Script&gt; prevOutIt = prevOutScripts.listIterator();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">                for (int index = 0; index &lt; tx.getInputs().size(); index++) {</span>
<span class="fc" id="L171">                    tx.getInputs().get(index).getScriptSig().correctlySpends(tx, index, prevOutIt.next(), verifyFlags);</span>
                }
<span class="fc" id="L173">            } catch (VerificationException e) {</span>
<span class="fc" id="L174">                return e;</span>
<span class="fc" id="L175">            }</span>
<span class="fc" id="L176">            return null;</span>
        }
    }

    /**
     * Get the {@link Script} from the script bytes or return Script of empty byte array.
     */
    private Script getScript(byte[] scriptBytes) {
        try {
<span class="fc" id="L185">            return new Script(scriptBytes);</span>
<span class="fc" id="L186">        } catch (Exception e) {</span>
<span class="fc" id="L187">            return new Script(new byte[0]);</span>
        }
    }

    /**
     * Get the address from the {@link Script} if it exists otherwise return empty string &quot;&quot;.
     *
     * @param script The script.
     * @return The address.
     */
    private String getScriptAddress(@Nullable Script script) {
<span class="fc" id="L198">        String address = &quot;&quot;;</span>
        try {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">            if (script != null) {</span>
<span class="fc" id="L201">                address = script.getToAddress(params, true).toString();</span>
            }
<span class="fc" id="L203">        } catch (Exception e) {</span>
<span class="fc" id="L204">        }</span>
<span class="fc" id="L205">        return address;</span>
    }

    @Override
    protected TransactionOutputChanges connectTransactions(int height, Block block)
            throws VerificationException, BlockStoreException {
<span class="fc" id="L211">        checkState(lock.isHeldByCurrentThread());</span>
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">        if (block.transactions == null)</span>
<span class="nc" id="L213">            throw new RuntimeException(&quot;connectTransactions called with Block that didn't have transactions!&quot;);</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        if (!params.passesCheckpoint(height, block.getHash()))</span>
<span class="nc" id="L215">            throw new VerificationException(&quot;Block failed checkpoint lockin at &quot; + height);</span>

<span class="fc" id="L217">        blockStore.beginDatabaseBatchWrite();</span>

<span class="fc" id="L219">        LinkedList&lt;UTXO&gt; txOutsSpent = new LinkedList&lt;UTXO&gt;();</span>
<span class="fc" id="L220">        LinkedList&lt;UTXO&gt; txOutsCreated = new LinkedList&lt;UTXO&gt;();</span>
<span class="fc" id="L221">        long sigOps = 0;</span>

<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (scriptVerificationExecutor.isShutdown())</span>
<span class="fc" id="L224">            scriptVerificationExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span>

<span class="fc" id="L226">        List&lt;Future&lt;VerificationException&gt;&gt; listScriptVerificationResults = new ArrayList&lt;Future&lt;VerificationException&gt;&gt;(block.transactions.size());</span>
        try {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">            if (!params.isCheckpoint(height)) {</span>
                // BIP30 violator blocks are ones that contain a duplicated transaction. They are all in the
                // checkpoints list and we therefore only check non-checkpoints for duplicated transactions here. See the
                // BIP30 document for more details on this: https://github.com/bitcoin/bips/blob/master/bip-0030.mediawiki
<span class="fc bfc" id="L232" title="All 2 branches covered.">                for (Transaction tx : block.transactions) {</span>
<span class="fc" id="L233">                    final Set&lt;VerifyFlag&gt; verifyFlags = params.getTransactionVerificationFlags(block, tx, getVersionTally(), height);</span>
<span class="fc" id="L234">                    Sha256Hash hash = tx.getHash();</span>
                    // If we already have unspent outputs for this hash, we saw the tx already. Either the block is
                    // being added twice (bug) or the block is a BIP30 violator.
<span class="fc bfc" id="L237" title="All 2 branches covered.">                    if (blockStore.hasUnspentOutputs(hash, tx.getOutputs().size()))</span>
<span class="fc" id="L238">                        throw new VerificationException(&quot;Block failed BIP30 test!&quot;);</span>
<span class="fc bfc" id="L239" title="All 2 branches covered.">                    if (verifyFlags.contains(VerifyFlag.P2SH)) // We already check non-BIP16 sigops in Block.verifyTransactions(true)</span>
<span class="fc" id="L240">                        sigOps += tx.getSigOpCount();</span>
<span class="fc" id="L241">                }</span>
            }
<span class="fc" id="L243">            Coin totalFees = Coin.ZERO;</span>
<span class="fc" id="L244">            Coin coinbaseValue = null;</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">            for (final Transaction tx : block.transactions) {</span>
<span class="fc" id="L246">                boolean isCoinBase = tx.isCoinBase();</span>
<span class="fc" id="L247">                Coin valueIn = Coin.ZERO;</span>
<span class="fc" id="L248">                Coin valueOut = Coin.ZERO;</span>
<span class="fc" id="L249">                final List&lt;Script&gt; prevOutScripts = new LinkedList&lt;Script&gt;();</span>
<span class="fc" id="L250">                final Set&lt;VerifyFlag&gt; verifyFlags = params.getTransactionVerificationFlags(block, tx, getVersionTally(), height);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">                if (!isCoinBase) {</span>
                    // For each input of the transaction remove the corresponding output from the set of unspent
                    // outputs.
<span class="fc bfc" id="L254" title="All 2 branches covered.">                    for (int index = 0; index &lt; tx.getInputs().size(); index++) {</span>
<span class="fc" id="L255">                        TransactionInput in = tx.getInputs().get(index);</span>
<span class="fc" id="L256">                        UTXO prevOut = blockStore.getTransactionOutput(in.getOutpoint().getHash(),</span>
<span class="fc" id="L257">                                in.getOutpoint().getIndex());</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">                        if (prevOut == null)</span>
<span class="fc" id="L259">                            throw new VerificationException(&quot;Attempted to spend a non-existent or already spent output!&quot;);</span>
                        // Coinbases can't be spent until they mature, to avoid re-orgs destroying entire transaction
                        // chains. The assumption is there will ~never be re-orgs deeper than the spendable coinbase
                        // chain depth.
<span class="fc bfc" id="L263" title="All 2 branches covered.">                        if (prevOut.isCoinbase()) {</span>
<span class="fc bfc" id="L264" title="All 2 branches covered.">                            if (height - prevOut.getHeight() &lt; params.getSpendableCoinbaseDepth()) {</span>
<span class="fc" id="L265">                                throw new VerificationException(&quot;Tried to spend coinbase at depth &quot; + (height - prevOut.getHeight()));</span>
                            }
                        }
                        // TODO: Check we're not spending the genesis transaction here. Bitcoin Core won't allow it.
<span class="fc" id="L269">                        valueIn = valueIn.add(prevOut.getValue());</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">                        if (verifyFlags.contains(VerifyFlag.P2SH)) {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">                            if (prevOut.getScript().isPayToScriptHash())</span>
<span class="fc" id="L272">                                sigOps += Script.getP2SHSigOpCount(in.getScriptBytes());</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">                            if (sigOps &gt; Block.MAX_BLOCK_SIGOPS)</span>
<span class="fc" id="L274">                                throw new VerificationException(&quot;Too many P2SH SigOps in block&quot;);</span>
                        }

<span class="fc" id="L277">                        prevOutScripts.add(prevOut.getScript());</span>
<span class="fc" id="L278">                        blockStore.removeUnspentTransactionOutput(prevOut);</span>
<span class="fc" id="L279">                        txOutsSpent.add(prevOut);</span>
                    }
                }
<span class="fc" id="L282">                Sha256Hash hash = tx.getHash();</span>
<span class="fc bfc" id="L283" title="All 2 branches covered.">                for (TransactionOutput out : tx.getOutputs()) {</span>
<span class="fc" id="L284">                    valueOut = valueOut.add(out.getValue());</span>
                    // For each output, add it to the set of unspent outputs so it can be consumed in future.
<span class="fc" id="L286">                    Script script = getScript(out.getScriptBytes());</span>
<span class="fc" id="L287">                    UTXO newOut = new UTXO(hash,</span>
<span class="fc" id="L288">                            out.getIndex(),</span>
<span class="fc" id="L289">                            out.getValue(),</span>
                            height, isCoinBase,
                            script,
<span class="fc" id="L292">                            getScriptAddress(script));</span>
<span class="fc" id="L293">                    blockStore.addUnspentTransactionOutput(newOut);</span>
<span class="fc" id="L294">                    txOutsCreated.add(newOut);</span>
<span class="fc" id="L295">                }</span>
                // All values were already checked for being non-negative (as it is verified in Transaction.verify())
                // but we check again here just for defence in depth. Transactions with zero output value are OK.
<span class="pc bpc" id="L298" title="2 of 4 branches missed.">                if (valueOut.signum() &lt; 0 || valueOut.compareTo(params.getMaxMoney()) &gt; 0)</span>
<span class="nc" id="L299">                    throw new VerificationException(&quot;Transaction output value out of range&quot;);</span>
<span class="fc bfc" id="L300" title="All 2 branches covered.">                if (isCoinBase) {</span>
<span class="fc" id="L301">                    coinbaseValue = valueOut;</span>
                } else {
<span class="pc bpc" id="L303" title="1 of 4 branches missed.">                    if (valueIn.compareTo(valueOut) &lt; 0 || valueIn.compareTo(params.getMaxMoney()) &gt; 0)</span>
<span class="fc" id="L304">                        throw new VerificationException(&quot;Transaction input value out of range&quot;);</span>
<span class="fc" id="L305">                    totalFees = totalFees.add(valueIn.subtract(valueOut));</span>
                }

<span class="fc bfc" id="L308" title="All 4 branches covered.">                if (!isCoinBase &amp;&amp; runScripts) {</span>
                    // Because correctlySpends modifies transactions, this must come after we are done with tx
<span class="fc" id="L310">                    FutureTask&lt;VerificationException&gt; future = new FutureTask&lt;VerificationException&gt;(new Verifier(tx, prevOutScripts, verifyFlags));</span>
<span class="fc" id="L311">                    scriptVerificationExecutor.execute(future);</span>
<span class="fc" id="L312">                    listScriptVerificationResults.add(future);</span>
                }
<span class="fc" id="L314">            }</span>
<span class="pc bpc" id="L315" title="1 of 4 branches missed.">            if (totalFees.compareTo(params.getMaxMoney()) &gt; 0 || block.getBlockInflation(height).add(totalFees).compareTo(coinbaseValue) &lt; 0)</span>
<span class="fc" id="L316">                throw new VerificationException(&quot;Transaction fees out of range&quot;);</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">            for (Future&lt;VerificationException&gt; future : listScriptVerificationResults) {</span>
                VerificationException e;
                try {
<span class="fc" id="L320">                    e = future.get();</span>
<span class="nc" id="L321">                } catch (InterruptedException thrownE) {</span>
<span class="nc" id="L322">                    throw new RuntimeException(thrownE); // Shouldn't happen</span>
<span class="nc" id="L323">                } catch (ExecutionException thrownE) {</span>
<span class="nc" id="L324">                    log.error(&quot;Script.correctlySpends threw a non-normal exception: &quot; + thrownE.getCause());</span>
<span class="nc" id="L325">                    throw new VerificationException(&quot;Bug in Script.correctlySpends, likely script malformed in some new and interesting way.&quot;, thrownE);</span>
<span class="fc" id="L326">                }</span>
<span class="fc bfc" id="L327" title="All 2 branches covered.">                if (e != null)</span>
<span class="fc" id="L328">                    throw e;</span>
<span class="fc" id="L329">            }</span>
<span class="fc" id="L330">        } catch (VerificationException e) {</span>
<span class="fc" id="L331">            scriptVerificationExecutor.shutdownNow();</span>
<span class="fc" id="L332">            blockStore.abortDatabaseBatchWrite();</span>
<span class="fc" id="L333">            throw e;</span>
<span class="nc" id="L334">        } catch (BlockStoreException e) {</span>
<span class="nc" id="L335">            scriptVerificationExecutor.shutdownNow();</span>
<span class="nc" id="L336">            blockStore.abortDatabaseBatchWrite();</span>
<span class="nc" id="L337">            throw e;</span>
<span class="fc" id="L338">        }</span>
<span class="fc" id="L339">        return new TransactionOutputChanges(txOutsCreated, txOutsSpent);</span>
    }

    @Override
    /**
     * Used during reorgs to connect a block previously on a fork
     */
    protected synchronized TransactionOutputChanges connectTransactions(StoredBlock newBlock)
            throws VerificationException, BlockStoreException, PrunedException {
<span class="fc" id="L348">        checkState(lock.isHeldByCurrentThread());</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">        if (!params.passesCheckpoint(newBlock.getHeight(), newBlock.getHeader().getHash()))</span>
<span class="nc" id="L350">            throw new VerificationException(&quot;Block failed checkpoint lockin at &quot; + newBlock.getHeight());</span>

<span class="fc" id="L352">        blockStore.beginDatabaseBatchWrite();</span>
<span class="fc" id="L353">        StoredUndoableBlock block = blockStore.getUndoBlock(newBlock.getHeader().getHash());</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (block == null) {</span>
            // We're trying to re-org too deep and the data needed has been deleted.
<span class="nc" id="L356">            blockStore.abortDatabaseBatchWrite();</span>
<span class="nc" id="L357">            throw new PrunedException(newBlock.getHeader().getHash());</span>
        }
        TransactionOutputChanges txOutChanges;
        try {
<span class="fc" id="L361">            List&lt;Transaction&gt; transactions = block.getTransactions();</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            if (transactions != null) {</span>
<span class="fc" id="L363">                LinkedList&lt;UTXO&gt; txOutsSpent = new LinkedList&lt;UTXO&gt;();</span>
<span class="fc" id="L364">                LinkedList&lt;UTXO&gt; txOutsCreated = new LinkedList&lt;UTXO&gt;();</span>
<span class="fc" id="L365">                long sigOps = 0;</span>

<span class="pc bpc" id="L367" title="1 of 2 branches missed.">                if (!params.isCheckpoint(newBlock.getHeight())) {</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">                    for (Transaction tx : transactions) {</span>
<span class="fc" id="L369">                        Sha256Hash hash = tx.getHash();</span>
<span class="pc bpc" id="L370" title="1 of 2 branches missed.">                        if (blockStore.hasUnspentOutputs(hash, tx.getOutputs().size()))</span>
<span class="nc" id="L371">                            throw new VerificationException(&quot;Block failed BIP30 test!&quot;);</span>
<span class="fc" id="L372">                    }</span>
                }
<span class="fc" id="L374">                Coin totalFees = Coin.ZERO;</span>
<span class="fc" id="L375">                Coin coinbaseValue = null;</span>

<span class="fc bfc" id="L377" title="All 2 branches covered.">                if (scriptVerificationExecutor.isShutdown())</span>
<span class="fc" id="L378">                    scriptVerificationExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());</span>
<span class="fc" id="L379">                List&lt;Future&lt;VerificationException&gt;&gt; listScriptVerificationResults = new ArrayList&lt;Future&lt;VerificationException&gt;&gt;(transactions.size());</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">                for (final Transaction tx : transactions) {</span>
<span class="fc" id="L381">                    final Set&lt;VerifyFlag&gt; verifyFlags =</span>
<span class="fc" id="L382">                        params.getTransactionVerificationFlags(newBlock.getHeader(), tx, getVersionTally(), Integer.SIZE);</span>
<span class="fc" id="L383">                    boolean isCoinBase = tx.isCoinBase();</span>
<span class="fc" id="L384">                    Coin valueIn = Coin.ZERO;</span>
<span class="fc" id="L385">                    Coin valueOut = Coin.ZERO;</span>
<span class="fc" id="L386">                    final List&lt;Script&gt; prevOutScripts = new LinkedList&lt;Script&gt;();</span>

<span class="fc bfc" id="L388" title="All 2 branches covered.">                    if (!isCoinBase) {</span>
<span class="fc bfc" id="L389" title="All 2 branches covered.">                        for (int index = 0; index &lt; tx.getInputs().size(); index++) {</span>
<span class="fc" id="L390">                            final TransactionInput in = tx.getInputs().get(index);</span>
<span class="fc" id="L391">                            final UTXO prevOut = blockStore.getTransactionOutput(in.getOutpoint().getHash(),</span>
<span class="fc" id="L392">                                    in.getOutpoint().getIndex());</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">                            if (prevOut == null)</span>
<span class="fc" id="L394">                                throw new VerificationException(&quot;Attempted spend of a non-existent or already spent output!&quot;);</span>
<span class="fc bfc" id="L395" title="All 4 branches covered.">                            if (prevOut.isCoinbase() &amp;&amp; newBlock.getHeight() - prevOut.getHeight() &lt; params.getSpendableCoinbaseDepth())</span>
<span class="fc" id="L396">                                throw new VerificationException(&quot;Tried to spend coinbase at depth &quot; + (newBlock.getHeight() - prevOut.getHeight()));</span>
<span class="fc" id="L397">                            valueIn = valueIn.add(prevOut.getValue());</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">                            if (verifyFlags.contains(VerifyFlag.P2SH)) {</span>
<span class="pc bpc" id="L399" title="1 of 2 branches missed.">                                if (prevOut.getScript().isPayToScriptHash())</span>
<span class="nc" id="L400">                                    sigOps += Script.getP2SHSigOpCount(in.getScriptBytes());</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">                                if (sigOps &gt; Block.MAX_BLOCK_SIGOPS)</span>
<span class="nc" id="L402">                                    throw new VerificationException(&quot;Too many P2SH SigOps in block&quot;);</span>
                            }

                            // TODO: Enforce DER signature format

<span class="fc" id="L407">                            prevOutScripts.add(prevOut.getScript());</span>

<span class="fc" id="L409">                            blockStore.removeUnspentTransactionOutput(prevOut);</span>
<span class="fc" id="L410">                            txOutsSpent.add(prevOut);</span>
                        }
                    }
<span class="fc" id="L413">                    Sha256Hash hash = tx.getHash();</span>
<span class="fc bfc" id="L414" title="All 2 branches covered.">                    for (TransactionOutput out : tx.getOutputs()) {</span>
<span class="fc" id="L415">                        valueOut = valueOut.add(out.getValue());</span>
<span class="fc" id="L416">                        Script script = getScript(out.getScriptBytes());</span>
<span class="fc" id="L417">                        UTXO newOut = new UTXO(hash,</span>
<span class="fc" id="L418">                                out.getIndex(),</span>
<span class="fc" id="L419">                                out.getValue(),</span>
<span class="fc" id="L420">                                newBlock.getHeight(),</span>
                                isCoinBase,
                                script,
<span class="fc" id="L423">                                getScriptAddress(script));</span>
<span class="fc" id="L424">                        blockStore.addUnspentTransactionOutput(newOut);</span>
<span class="fc" id="L425">                        txOutsCreated.add(newOut);</span>
<span class="fc" id="L426">                    }</span>
                    // All values were already checked for being non-negative (as it is verified in Transaction.verify())
                    // but we check again here just for defence in depth. Transactions with zero output value are OK.
<span class="pc bpc" id="L429" title="2 of 4 branches missed.">                    if (valueOut.signum() &lt; 0 || valueOut.compareTo(params.getMaxMoney()) &gt; 0)</span>
<span class="nc" id="L430">                        throw new VerificationException(&quot;Transaction output value out of range&quot;);</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">                    if (isCoinBase) {</span>
<span class="fc" id="L432">                        coinbaseValue = valueOut;</span>
                    } else {
<span class="pc bpc" id="L434" title="2 of 4 branches missed.">                        if (valueIn.compareTo(valueOut) &lt; 0 || valueIn.compareTo(params.getMaxMoney()) &gt; 0)</span>
<span class="nc" id="L435">                            throw new VerificationException(&quot;Transaction input value out of range&quot;);</span>
<span class="fc" id="L436">                        totalFees = totalFees.add(valueIn.subtract(valueOut));</span>
                    }

<span class="fc bfc" id="L439" title="All 2 branches covered.">                    if (!isCoinBase) {</span>
                        // Because correctlySpends modifies transactions, this must come after we are done with tx
<span class="fc" id="L441">                        FutureTask&lt;VerificationException&gt; future = new FutureTask&lt;VerificationException&gt;(new Verifier(tx, prevOutScripts, verifyFlags));</span>
<span class="fc" id="L442">                        scriptVerificationExecutor.execute(future);</span>
<span class="fc" id="L443">                        listScriptVerificationResults.add(future);</span>
                    }
<span class="fc" id="L445">                }</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">                if (totalFees.compareTo(params.getMaxMoney()) &gt; 0 ||</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">                        newBlock.getHeader().getBlockInflation(newBlock.getHeight()).add(totalFees).compareTo(coinbaseValue) &lt; 0)</span>
<span class="nc" id="L448">                    throw new VerificationException(&quot;Transaction fees out of range&quot;);</span>
<span class="fc" id="L449">                txOutChanges = new TransactionOutputChanges(txOutsCreated, txOutsSpent);</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">                for (Future&lt;VerificationException&gt; future : listScriptVerificationResults) {</span>
                    VerificationException e;
                    try {
<span class="fc" id="L453">                        e = future.get();</span>
<span class="nc" id="L454">                    } catch (InterruptedException thrownE) {</span>
<span class="nc" id="L455">                        throw new RuntimeException(thrownE); // Shouldn't happen</span>
<span class="nc" id="L456">                    } catch (ExecutionException thrownE) {</span>
<span class="nc" id="L457">                        log.error(&quot;Script.correctlySpends threw a non-normal exception: &quot; + thrownE.getCause());</span>
<span class="nc" id="L458">                        throw new VerificationException(&quot;Bug in Script.correctlySpends, likely script malformed in some new and interesting way.&quot;, thrownE);</span>
<span class="fc" id="L459">                    }</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">                    if (e != null)</span>
<span class="nc" id="L461">                        throw e;</span>
<span class="fc" id="L462">                }</span>
<span class="fc" id="L463">            } else {</span>
<span class="fc" id="L464">                txOutChanges = block.getTxOutChanges();</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">                if (!params.isCheckpoint(newBlock.getHeight()))</span>
<span class="fc bfc" id="L466" title="All 2 branches covered.">                    for (UTXO out : txOutChanges.txOutsCreated) {</span>
<span class="fc" id="L467">                        Sha256Hash hash = out.getHash();</span>
<span class="pc bpc" id="L468" title="1 of 2 branches missed.">                        if (blockStore.getTransactionOutput(hash, out.getIndex()) != null)</span>
<span class="nc" id="L469">                            throw new VerificationException(&quot;Block failed BIP30 test!&quot;);</span>
<span class="fc" id="L470">                    }</span>
<span class="fc bfc" id="L471" title="All 2 branches covered.">                for (UTXO out : txOutChanges.txOutsCreated)</span>
<span class="fc" id="L472">                    blockStore.addUnspentTransactionOutput(out);</span>
<span class="fc bfc" id="L473" title="All 2 branches covered.">                for (UTXO out : txOutChanges.txOutsSpent)</span>
<span class="fc" id="L474">                    blockStore.removeUnspentTransactionOutput(out);</span>
            }
<span class="fc" id="L476">        } catch (VerificationException e) {</span>
<span class="fc" id="L477">            scriptVerificationExecutor.shutdownNow();</span>
<span class="fc" id="L478">            blockStore.abortDatabaseBatchWrite();</span>
<span class="fc" id="L479">            throw e;</span>
<span class="nc" id="L480">        } catch (BlockStoreException e) {</span>
<span class="nc" id="L481">            scriptVerificationExecutor.shutdownNow();</span>
<span class="nc" id="L482">            blockStore.abortDatabaseBatchWrite();</span>
<span class="nc" id="L483">            throw e;</span>
<span class="fc" id="L484">        }</span>
<span class="fc" id="L485">        return txOutChanges;</span>
    }

    /**
     * This is broken for blocks that do not pass BIP30, so all BIP30-failing blocks which are allowed to fail BIP30
     * must be checkpointed.
     */
    @Override
    protected void disconnectTransactions(StoredBlock oldBlock) throws PrunedException, BlockStoreException {
<span class="fc" id="L494">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L495">        blockStore.beginDatabaseBatchWrite();</span>
        try {
<span class="fc" id="L497">            StoredUndoableBlock undoBlock = blockStore.getUndoBlock(oldBlock.getHeader().getHash());</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">            if (undoBlock == null) throw new PrunedException(oldBlock.getHeader().getHash());</span>
<span class="fc" id="L499">            TransactionOutputChanges txOutChanges = undoBlock.getTxOutChanges();</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">            for (UTXO out : txOutChanges.txOutsSpent)</span>
<span class="fc" id="L501">                blockStore.addUnspentTransactionOutput(out);</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">            for (UTXO out : txOutChanges.txOutsCreated)</span>
<span class="fc" id="L503">                blockStore.removeUnspentTransactionOutput(out);</span>
<span class="nc" id="L504">        } catch (PrunedException e) {</span>
<span class="nc" id="L505">            blockStore.abortDatabaseBatchWrite();</span>
<span class="nc" id="L506">            throw e;</span>
<span class="nc" id="L507">        } catch (BlockStoreException e) {</span>
<span class="nc" id="L508">            blockStore.abortDatabaseBatchWrite();</span>
<span class="nc" id="L509">            throw e;</span>
<span class="fc" id="L510">        }</span>
<span class="fc" id="L511">    }</span>

    @Override
    protected void doSetChainHead(StoredBlock chainHead) throws BlockStoreException {
<span class="fc" id="L515">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L516">        blockStore.setVerifiedChainHead(chainHead);</span>
<span class="fc" id="L517">        blockStore.commitDatabaseBatchWrite();</span>
<span class="fc" id="L518">    }</span>

    @Override
    protected void notSettingChainHead() throws BlockStoreException {
<span class="fc" id="L522">        blockStore.abortDatabaseBatchWrite();</span>
<span class="fc" id="L523">    }</span>

    @Override
    protected StoredBlock getStoredBlockInCurrentScope(Sha256Hash hash) throws BlockStoreException {
<span class="fc" id="L527">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L528">        return blockStore.getOnceUndoableStoredBlock(hash);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>