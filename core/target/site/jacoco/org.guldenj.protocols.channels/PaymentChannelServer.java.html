<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PaymentChannelServer.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">guldenj</a> &gt; <a href="index.source.html" class="el_package">org.guldenj.protocols.channels</a> &gt; <span class="el_source">PaymentChannelServer.java</span></div><h1>PaymentChannelServer.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.guldenj.protocols.channels;

import com.google.common.collect.ImmutableMap;
import org.guldenj.core.*;
import org.guldenj.protocols.channels.PaymentChannelCloseException.CloseReason;
import org.guldenj.utils.Threading;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.protobuf.ByteString;
import net.jcip.annotations.GuardedBy;
import org.bitcoin.paymentchannel.Protos;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;

import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.base.Preconditions.checkState;

/**
 * &lt;p&gt;A handler class which handles most of the complexity of creating a payment channel connection by providing a
 * simple in/out interface which is provided with protobufs from the client and which generates protobufs which should
 * be sent to the client.&lt;/p&gt;
 *
 * &lt;p&gt;Does all required verification of messages and properly stores state objects in the wallet-attached
 * {@link StoredPaymentChannelServerStates} so that they are automatically closed when necessary and payment
 * transactions are not lost if the application crashes before it unlocks.&lt;/p&gt;
 */
public class PaymentChannelServer {
    //TODO: Update JavaDocs with notes for communication over stateless protocols
<span class="fc" id="L49">    private static final org.slf4j.Logger log = LoggerFactory.getLogger(PaymentChannelServer.class);</span>

<span class="fc" id="L51">    protected final ReentrantLock lock = Threading.lock(&quot;channelserver&quot;);</span>

    /**
     * A map of supported versions; keys are major versions, and the corresponding
     * value is the minor version at that major level.
     */
<span class="fc" id="L57">    public static final Map&lt;Integer, Integer&gt; SERVER_VERSIONS = ImmutableMap.of(1, 0, 2, 0);</span>

    // The step in the initialization process we are in, some of this is duplicated in the PaymentChannelServerState
<span class="pc" id="L60">    private enum InitStep {</span>
<span class="fc" id="L61">        WAITING_ON_CLIENT_VERSION,</span>
        // This step is only used in V1 of the protocol.
<span class="fc" id="L63">        WAITING_ON_UNSIGNED_REFUND,</span>
<span class="fc" id="L64">        WAITING_ON_CONTRACT,</span>
<span class="fc" id="L65">        WAITING_ON_MULTISIG_ACCEPTANCE,</span>
<span class="fc" id="L66">        CHANNEL_OPEN</span>
    }
<span class="fc" id="L68">    @GuardedBy(&quot;lock&quot;) private InitStep step = InitStep.WAITING_ON_CLIENT_VERSION;</span>

    /**
     * Implements the connection between this server and the client, providing an interface which allows messages to be
     * sent to the client, requests for the connection to the client to be closed, and callbacks which occur when the
     * channel is fully open or the client completes a payment.
     */
    public interface ServerConnection {
        /**
         * &lt;p&gt;Requests that the given message be sent to the client. There are no blocking requirements for this method,
         * however the order of messages must be preserved.&lt;/p&gt;
         *
         * &lt;p&gt;If the send fails, no exception should be thrown, however
         * {@link PaymentChannelServer#connectionClosed()} should be called immediately.&lt;/p&gt;
         *
         * &lt;p&gt;Called while holding a lock on the {@link PaymentChannelServer} object - be careful about reentrancy&lt;/p&gt;
         */
        void sendToClient(Protos.TwoWayChannelMessage msg);

        /**
         * &lt;p&gt;Requests that the connection to the client be closed&lt;/p&gt;
         *
         * &lt;p&gt;Called while holding a lock on the {@link PaymentChannelServer} object - be careful about reentrancy&lt;/p&gt;
         *
         * @param reason The reason for the closure, see the individual values for more details.
         *               It is usually safe to ignore this value.
         */
        void destroyConnection(CloseReason reason);

        /**
         * &lt;p&gt;Triggered when the channel is opened and payments can begin&lt;/p&gt;
         *
         * &lt;p&gt;Called while holding a lock on the {@link PaymentChannelServer} object - be careful about reentrancy&lt;/p&gt;
         *
         * @param contractHash A unique identifier which represents this channel (actually the hash of the multisig contract)
         */
        void channelOpen(Sha256Hash contractHash);

        /**
         * &lt;p&gt;Called when the payment in this channel was successfully incremented by the client&lt;/p&gt;
         *
         * &lt;p&gt;Called while holding a lock on the {@link PaymentChannelServer} object - be careful about reentrancy&lt;/p&gt;
         *
         * @param by The increase in total payment
         * @param to The new total payment to us (not including fees which may be required to claim the payment)
         * @param info Information about this payment increase, used to extend this protocol.
         * @return A future that completes with the ack message that will be included in the PaymentAck message to the client. Use null for no ack message.
         */
        @Nullable
        ListenableFuture&lt;ByteString&gt; paymentIncrease(Coin by, Coin to, @Nullable ByteString info);
    }
    private final ServerConnection conn;

    // Used to track the negotiated version number
    @GuardedBy(&quot;lock&quot;) private int majorVersion;

    // Used to keep track of whether or not the &quot;socket&quot; ie connection is open and we can generate messages
<span class="fc" id="L125">    @GuardedBy(&quot;lock&quot;) private boolean connectionOpen = false;</span>
    // Indicates that no further messages should be sent and we intend to settle the connection
<span class="fc" id="L127">    @GuardedBy(&quot;lock&quot;) private boolean channelSettling = false;</span>

    // The wallet and peergroup which are used to complete/broadcast transactions
    private final Wallet wallet;
    private final TransactionBroadcaster broadcaster;

    // The key used for multisig in this channel
    @GuardedBy(&quot;lock&quot;) private ECKey myKey;

    // The minimum accepted channel value
    private final Coin minAcceptedChannelSize;

    // The state manager for this channel
    @GuardedBy(&quot;lock&quot;) private PaymentChannelServerState state;

    // The time this channel expires (ie the refund transaction's locktime)
    @GuardedBy(&quot;lock&quot;) private long expireTime;

    public static final long DEFAULT_MAX_TIME_WINDOW = 7 * 24 * 60 * 60;

    /**
     * Maximum channel duration, in seconds, that the client can request. Defaults to 1 week.
     * Note that the server needs to be online for the whole time the channel is open.
     * Failure to do this could cause loss of all payments received on the channel.
     */
    protected final long maxTimeWindow;

    public static final long DEFAULT_MIN_TIME_WINDOW = 4 * 60 * 60;
    public static final long HARD_MIN_TIME_WINDOW = -StoredPaymentChannelServerStates.CHANNEL_EXPIRE_OFFSET;
    /**
     * Minimum channel duration, in seconds, that the client can request. Should always be larger than  than 2 hours, defaults to 4 hours
     */
    protected final long minTimeWindow;

    /**
     * Creates a new server-side state manager which handles a single client connection. The server will only accept
     * a channel with time window between 4 hours and 1 week. Note that the server need to be online for the whole time the channel is open.
     * Failure to do this could cause loss of all payments received on the channel.
     *
     * @param broadcaster The PeerGroup on which transactions will be broadcast - should have multiple connections.
     * @param wallet The wallet which will be used to complete transactions.
     *               Unlike {@link PaymentChannelClient}, this does not have to already contain a StoredState manager
     * @param minAcceptedChannelSize The minimum value the client must lock into this channel. A value too large will be
     *                               rejected by clients, and a value too low will require excessive channel reopening
     *                               and may cause fees to be require to settle the channel. A reasonable value depends
     *                               entirely on the expected maximum for the channel, and should likely be somewhere
     *                               between a few bitcents and a bitcoin.
     * @param conn A callback listener which represents the connection to the client (forwards messages we generate to
     *             the client and will close the connection on request)
     */
    public PaymentChannelServer(TransactionBroadcaster broadcaster, Wallet wallet,
                                Coin minAcceptedChannelSize, ServerConnection conn) {
<span class="fc" id="L179">        this(broadcaster, wallet, minAcceptedChannelSize, DEFAULT_MIN_TIME_WINDOW, DEFAULT_MAX_TIME_WINDOW, conn);</span>
<span class="fc" id="L180">    }</span>

    /**
     * Creates a new server-side state manager which handles a single client connection.
     *
     * @param broadcaster The PeerGroup on which transactions will be broadcast - should have multiple connections.
     * @param wallet The wallet which will be used to complete transactions.
     *               Unlike {@link PaymentChannelClient}, this does not have to already contain a StoredState manager
     * @param minAcceptedChannelSize The minimum value the client must lock into this channel. A value too large will be
     *                               rejected by clients, and a value too low will require excessive channel reopening
     *                               and may cause fees to be require to settle the channel. A reasonable value depends
     *                               entirely on the expected maximum for the channel, and should likely be somewhere
     *                               between a few bitcents and a bitcoin.
     * @param minTimeWindow The minimum allowed channel time window in seconds, must be larger than 7200.
     * @param maxTimeWindow The maximum allowed channel time window in seconds. Note that the server need to be online for the whole time the channel is open.
     *                              Failure to do this could cause loss of all payments received on the channel.
     * @param conn A callback listener which represents the connection to the client (forwards messages we generate to
     *              the client and will close the connection on request)
     */
    public PaymentChannelServer(TransactionBroadcaster broadcaster, Wallet wallet,
<span class="fc" id="L200">                                Coin minAcceptedChannelSize, long minTimeWindow, long maxTimeWindow, ServerConnection conn) {</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">        if (minTimeWindow &gt; maxTimeWindow) throw new IllegalArgumentException(&quot;minTimeWindow must be less or equal to maxTimeWindow&quot;);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (minTimeWindow &lt; HARD_MIN_TIME_WINDOW) throw new IllegalArgumentException(&quot;minTimeWindow must be larger than&quot; + HARD_MIN_TIME_WINDOW  + &quot; seconds&quot;);</span>
<span class="fc" id="L203">        this.broadcaster = checkNotNull(broadcaster);</span>
<span class="fc" id="L204">        this.wallet = checkNotNull(wallet);</span>
<span class="fc" id="L205">        this.minAcceptedChannelSize = checkNotNull(minAcceptedChannelSize);</span>
<span class="fc" id="L206">        this.conn = checkNotNull(conn);</span>
<span class="fc" id="L207">        this.minTimeWindow = minTimeWindow;</span>
<span class="fc" id="L208">        this.maxTimeWindow = maxTimeWindow;</span>
<span class="fc" id="L209">    }</span>

    /**
     * Returns the underlying {@link PaymentChannelServerState} object that is being manipulated. This object allows
     * you to learn how much money has been transferred, etc. May be null if the channel wasn't negotiated yet.
     */
    @Nullable
    public PaymentChannelServerState state() {
<span class="nc" id="L217">        return state;</span>
    }

    @GuardedBy(&quot;lock&quot;)
    private void receiveVersionMessage(Protos.TwoWayChannelMessage msg) throws VerificationException {
<span class="pc bpc" id="L222" title="2 of 4 branches missed.">        checkState(step == InitStep.WAITING_ON_CLIENT_VERSION &amp;&amp; msg.hasClientVersion());</span>
<span class="fc" id="L223">        final Protos.ClientVersion clientVersion = msg.getClientVersion();</span>
<span class="fc" id="L224">        majorVersion = clientVersion.getMajor();</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        if (!SERVER_VERSIONS.containsKey(majorVersion)) {</span>
<span class="nc" id="L226">            error(&quot;This server needs one of protocol versions &quot; + SERVER_VERSIONS.keySet() + &quot; , client offered &quot; + majorVersion,</span>
                    Protos.Error.ErrorCode.NO_ACCEPTABLE_VERSION, CloseReason.NO_ACCEPTABLE_VERSION);
<span class="nc" id="L228">            return;</span>
        }

<span class="fc" id="L231">        Protos.ServerVersion.Builder versionNegotiationBuilder = Protos.ServerVersion.newBuilder()</span>
<span class="fc" id="L232">                .setMajor(majorVersion).setMinor(SERVER_VERSIONS.get(majorVersion));</span>
<span class="fc" id="L233">        conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L234">                .setType(Protos.TwoWayChannelMessage.MessageType.SERVER_VERSION)</span>
<span class="fc" id="L235">                .setServerVersion(versionNegotiationBuilder)</span>
<span class="fc" id="L236">                .build());</span>
<span class="fc" id="L237">        ByteString reopenChannelContractHash = clientVersion.getPreviousChannelContractHash();</span>
<span class="pc bpc" id="L238" title="1 of 4 branches missed.">        if (reopenChannelContractHash != null &amp;&amp; reopenChannelContractHash.size() == 32) {</span>
<span class="fc" id="L239">            Sha256Hash contractHash = Sha256Hash.wrap(reopenChannelContractHash.toByteArray());</span>
<span class="fc" id="L240">            log.info(&quot;New client that wants to resume {}&quot;, contractHash);</span>
<span class="fc" id="L241">            StoredPaymentChannelServerStates channels = (StoredPaymentChannelServerStates)</span>
<span class="fc" id="L242">                    wallet.getExtensions().get(StoredPaymentChannelServerStates.EXTENSION_ID);</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">            if (channels != null) {</span>
<span class="fc" id="L244">                StoredServerChannel storedServerChannel = channels.getChannel(contractHash);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">                if (storedServerChannel != null) {</span>
<span class="fc" id="L246">                    final PaymentChannelServer existingHandler = storedServerChannel.setConnectedHandler(this, false);</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">                    if (existingHandler != this) {</span>
<span class="fc" id="L248">                        log.warn(&quot;  ... and that channel is already in use, disconnecting other user.&quot;);</span>
<span class="fc" id="L249">                        existingHandler.close();</span>
<span class="fc" id="L250">                        storedServerChannel.setConnectedHandler(this, true);</span>
                    }

<span class="fc" id="L253">                    log.info(&quot;Got resume version message, responding with VERSIONS and CHANNEL_OPEN&quot;);</span>
<span class="fc" id="L254">                    state = storedServerChannel.getOrCreateState(wallet, broadcaster);</span>
<span class="fc" id="L255">                    step = InitStep.CHANNEL_OPEN;</span>
<span class="fc" id="L256">                    conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L257">                            .setType(Protos.TwoWayChannelMessage.MessageType.CHANNEL_OPEN)</span>
<span class="fc" id="L258">                            .build());</span>
<span class="fc" id="L259">                    conn.channelOpen(contractHash);</span>
<span class="fc" id="L260">                    return;</span>
                } else {
<span class="fc" id="L262">                    log.error(&quot; ... but we do not have any record of that contract! Resume failed.&quot;);</span>
                }
<span class="fc" id="L264">            } else {</span>
<span class="nc" id="L265">                log.error(&quot; ... but we do not have any stored channels! Resume failed.&quot;);</span>
            }
        }
<span class="fc" id="L268">        log.info(&quot;Got initial version message, responding with VERSIONS and INITIATE: min value={}&quot;,</span>
<span class="fc" id="L269">                minAcceptedChannelSize.value);</span>

<span class="fc" id="L271">        myKey = new ECKey();</span>
<span class="fc" id="L272">        wallet.freshReceiveKey();</span>

<span class="fc" id="L274">        expireTime = Utils.currentTimeSeconds() + truncateTimeWindow(clientVersion.getTimeWindowSecs());</span>
<span class="pc bpc" id="L275" title="1 of 3 branches missed.">        switch (majorVersion) {</span>
            case 1:
<span class="fc" id="L277">                step = InitStep.WAITING_ON_UNSIGNED_REFUND;</span>
<span class="fc" id="L278">                break;</span>
            case 2:
<span class="fc" id="L280">                step = InitStep.WAITING_ON_CONTRACT;</span>
<span class="fc" id="L281">                break;</span>
            default:
<span class="nc" id="L283">                error(&quot;Protocol version &quot; + majorVersion + &quot; not supported&quot;, Protos.Error.ErrorCode.NO_ACCEPTABLE_VERSION, CloseReason.NO_ACCEPTABLE_VERSION);</span>
                break;
        }

<span class="fc" id="L287">        Protos.Initiate.Builder initiateBuilder = Protos.Initiate.newBuilder()</span>
<span class="fc" id="L288">                .setMultisigKey(ByteString.copyFrom(myKey.getPubKey()))</span>
<span class="fc" id="L289">                .setExpireTimeSecs(expireTime)</span>
<span class="fc" id="L290">                .setMinAcceptedChannelSize(minAcceptedChannelSize.value)</span>
<span class="fc" id="L291">                .setMinPayment(Transaction.REFERENCE_DEFAULT_MIN_TX_FEE.value);</span>

<span class="fc" id="L293">        conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L294">                .setInitiate(initiateBuilder)</span>
<span class="fc" id="L295">                .setType(Protos.TwoWayChannelMessage.MessageType.INITIATE)</span>
<span class="fc" id="L296">                .build());</span>
<span class="fc" id="L297">    }</span>

    private long truncateTimeWindow(long timeWindow) {
<span class="fc bfc" id="L300" title="All 2 branches covered.">        if (timeWindow &lt; minTimeWindow) {</span>
<span class="fc" id="L301">            log.info(&quot;client requested time window {} s to short, offering {} s&quot;, timeWindow, minTimeWindow);</span>
<span class="fc" id="L302">            return minTimeWindow;</span>
        }
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (timeWindow &gt; maxTimeWindow) {</span>
<span class="fc" id="L305">            log.info(&quot;client requested time window {} s to long, offering {} s&quot;, timeWindow, minTimeWindow);</span>
<span class="fc" id="L306">            return maxTimeWindow;</span>
        }
<span class="fc" id="L308">        return timeWindow;</span>
    }

    @GuardedBy(&quot;lock&quot;)
    private void receiveRefundMessage(Protos.TwoWayChannelMessage msg) throws VerificationException {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        checkState(majorVersion == 1);</span>
<span class="pc bpc" id="L314" title="2 of 4 branches missed.">        checkState(step == InitStep.WAITING_ON_UNSIGNED_REFUND &amp;&amp; msg.hasProvideRefund());</span>
<span class="fc" id="L315">        log.info(&quot;Got refund transaction, returning signature&quot;);</span>

<span class="fc" id="L317">        Protos.ProvideRefund providedRefund = msg.getProvideRefund();</span>
<span class="fc" id="L318">        state = new PaymentChannelV1ServerState(broadcaster, wallet, myKey, expireTime);</span>
        // We can cast to V1 state since this state is only used in the V1 protocol
<span class="fc" id="L320">        byte[] signature = ((PaymentChannelV1ServerState) state)</span>
<span class="fc" id="L321">                .provideRefundTransaction(wallet.getParams().getDefaultSerializer().makeTransaction(providedRefund.getTx().toByteArray()),</span>
<span class="fc" id="L322">                        providedRefund.getMultisigKey().toByteArray());</span>

<span class="fc" id="L324">        step = InitStep.WAITING_ON_CONTRACT;</span>

<span class="fc" id="L326">        Protos.ReturnRefund.Builder returnRefundBuilder = Protos.ReturnRefund.newBuilder()</span>
<span class="fc" id="L327">                .setSignature(ByteString.copyFrom(signature));</span>

<span class="fc" id="L329">        conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L330">                .setReturnRefund(returnRefundBuilder)</span>
<span class="fc" id="L331">                .setType(Protos.TwoWayChannelMessage.MessageType.RETURN_REFUND)</span>
<span class="fc" id="L332">                .build());</span>
<span class="fc" id="L333">    }</span>

    private void multisigContractPropogated(Protos.ProvideContract providedContract, Sha256Hash contractHash) {
<span class="fc" id="L336">        lock.lock();</span>
        try {
<span class="pc bpc" id="L338" title="2 of 4 branches missed.">            if (!connectionOpen || channelSettling)</span>
<span class="nc" id="L339">                return;</span>
<span class="fc" id="L340">            state.storeChannelInWallet(PaymentChannelServer.this);</span>
            try {
<span class="fc" id="L342">                receiveUpdatePaymentMessage(providedContract.getInitialPayment(), false /* no ack msg */);</span>
<span class="nc" id="L343">            } catch (VerificationException e) {</span>
<span class="nc" id="L344">                log.error(&quot;Initial payment failed to verify&quot;, e);</span>
<span class="nc" id="L345">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L346">                return;</span>
<span class="nc" id="L347">            } catch (ValueOutOfRangeException e) {</span>
<span class="nc" id="L348">                log.error(&quot;Initial payment value was out of range&quot;, e);</span>
<span class="nc" id="L349">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L350">                return;</span>
<span class="nc" id="L351">            } catch (InsufficientMoneyException e) {</span>
                // This shouldn't happen because the server shouldn't allow itself to get into this situation in the
                // first place, by specifying a min up front payment.
<span class="nc" id="L354">                log.error(&quot;Tried to settle channel and could not afford the fees whilst updating payment&quot;, e);</span>
<span class="nc" id="L355">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L356">                return;</span>
<span class="fc" id="L357">            }</span>
<span class="fc" id="L358">            conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L359">                    .setType(Protos.TwoWayChannelMessage.MessageType.CHANNEL_OPEN)</span>
<span class="fc" id="L360">                    .build());</span>
<span class="fc" id="L361">            step = InitStep.CHANNEL_OPEN;</span>
<span class="fc" id="L362">            conn.channelOpen(contractHash);</span>
        } finally {
<span class="pc" id="L364">            lock.unlock();</span>
<span class="fc" id="L365">        }</span>
<span class="fc" id="L366">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void receiveContractMessage(Protos.TwoWayChannelMessage msg) throws VerificationException {
<span class="pc bpc" id="L370" title="1 of 4 branches missed.">        checkState(majorVersion == 1 || majorVersion == 2);</span>
<span class="pc bpc" id="L371" title="2 of 4 branches missed.">        checkState(step == InitStep.WAITING_ON_CONTRACT &amp;&amp; msg.hasProvideContract());</span>
<span class="fc" id="L372">        log.info(&quot;Got contract, broadcasting and responding with CHANNEL_OPEN&quot;);</span>
<span class="fc" id="L373">        final Protos.ProvideContract providedContract = msg.getProvideContract();</span>

<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (majorVersion == 2) {</span>
<span class="fc" id="L376">            state = new PaymentChannelV2ServerState(broadcaster, wallet, myKey, expireTime);</span>
<span class="fc" id="L377">            checkState(providedContract.hasClientKey(), &quot;ProvideContract didn't have a client key in protocol v2&quot;);</span>
<span class="fc" id="L378">            ((PaymentChannelV2ServerState)state).provideClientKey(providedContract.getClientKey().toByteArray());</span>
        }

        //TODO notify connection handler that timeout should be significantly extended as we wait for network propagation?
<span class="fc" id="L382">        final Transaction contract = wallet.getParams().getDefaultSerializer().makeTransaction(providedContract.getTx().toByteArray());</span>
<span class="fc" id="L383">        step = InitStep.WAITING_ON_MULTISIG_ACCEPTANCE;</span>
<span class="fc" id="L384">        state.provideContract(contract)</span>
<span class="fc" id="L385">                .addListener(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L388">                        multisigContractPropogated(providedContract, contract.getHash());</span>
<span class="fc" id="L389">                    }</span>
                }, Threading.SAME_THREAD);
<span class="fc" id="L391">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void receiveUpdatePaymentMessage(Protos.UpdatePayment msg, boolean sendAck) throws VerificationException, ValueOutOfRangeException, InsufficientMoneyException {
<span class="fc" id="L395">        log.info(&quot;Got a payment update&quot;);</span>

<span class="fc" id="L397">        Coin lastBestPayment = state.getBestValueToMe();</span>
<span class="fc" id="L398">        final Coin refundSize = Coin.valueOf(msg.getClientChangeValue());</span>
<span class="fc" id="L399">        boolean stillUsable = state.incrementPayment(refundSize, msg.getSignature().toByteArray());</span>
<span class="fc" id="L400">        Coin bestPaymentChange = state.getBestValueToMe().subtract(lastBestPayment);</span>

<span class="fc" id="L402">        ListenableFuture&lt;ByteString&gt; ackInfoFuture = null;</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if (bestPaymentChange.signum() &gt; 0) {</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">            ByteString info = (msg.hasInfo()) ? msg.getInfo() : null;</span>
<span class="fc" id="L405">            ackInfoFuture = conn.paymentIncrease(bestPaymentChange, state.getBestValueToMe(), info);</span>
        }

<span class="fc bfc" id="L408" title="All 2 branches covered.">        if (sendAck) {</span>
<span class="fc" id="L409">            final Protos.TwoWayChannelMessage.Builder ack = Protos.TwoWayChannelMessage.newBuilder();</span>
<span class="fc" id="L410">            ack.setType(Protos.TwoWayChannelMessage.MessageType.PAYMENT_ACK);</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">            if (ackInfoFuture == null) {</span>
<span class="nc" id="L412">                conn.sendToClient(ack.build());</span>
            } else {
<span class="fc" id="L414">                Futures.addCallback(ackInfoFuture, new FutureCallback&lt;ByteString&gt;() {</span>
                    @Override
                    public void onSuccess(@Nullable ByteString result) {
<span class="fc bfc" id="L417" title="All 2 branches covered.">                        if (result != null) ack.setPaymentAck(ack.getPaymentAckBuilder().setInfo(result));</span>
<span class="fc" id="L418">                        conn.sendToClient(ack.build());</span>
<span class="fc" id="L419">                    }</span>

                    @Override
                    public void onFailure(Throwable t) {
<span class="nc" id="L423">                        log.info(&quot;Failed retrieving paymentIncrease info future&quot;);</span>
<span class="nc" id="L424">                        error(&quot;Failed processing payment update&quot;, Protos.Error.ErrorCode.OTHER, CloseReason.UPDATE_PAYMENT_FAILED);</span>
<span class="nc" id="L425">                    }</span>
                });
            }
        }

<span class="fc bfc" id="L430" title="All 2 branches covered.">        if (!stillUsable) {</span>
<span class="fc" id="L431">            log.info(&quot;Channel is now fully exhausted, closing/initiating settlement&quot;);</span>
<span class="fc" id="L432">            settlePayment(CloseReason.CHANNEL_EXHAUSTED);</span>
        }
<span class="fc" id="L434">    }</span>

    /**
     * Called when a message is received from the client. Processes the given message and generates events based on its
     * content.
     */
    public void receiveMessage(Protos.TwoWayChannelMessage msg) {
<span class="fc" id="L441">        lock.lock();</span>
        try {
<span class="fc" id="L443">            checkState(connectionOpen);</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">            if (channelSettling)</span>
<span class="nc" id="L445">                return;</span>
            try {
<span class="pc bpc" id="L447" title="1 of 7 branches missed.">                switch (msg.getType()) {</span>
                    case CLIENT_VERSION:
<span class="fc" id="L449">                        receiveVersionMessage(msg);</span>
<span class="fc" id="L450">                        return;</span>
                    case PROVIDE_REFUND:
<span class="fc" id="L452">                        receiveRefundMessage(msg);</span>
<span class="fc" id="L453">                        return;</span>
                    case PROVIDE_CONTRACT:
<span class="fc" id="L455">                        receiveContractMessage(msg);</span>
<span class="fc" id="L456">                        return;</span>
                    case UPDATE_PAYMENT:
<span class="pc bpc" id="L458" title="2 of 4 branches missed.">                        checkState(step == InitStep.CHANNEL_OPEN &amp;&amp; msg.hasUpdatePayment());</span>
<span class="fc" id="L459">                        receiveUpdatePaymentMessage(msg.getUpdatePayment(), true);</span>
<span class="fc" id="L460">                        return;</span>
                    case CLOSE:
<span class="fc" id="L462">                        receiveCloseMessage();</span>
<span class="fc" id="L463">                        return;</span>
                    case ERROR:
<span class="fc" id="L465">                        checkState(msg.hasError());</span>
<span class="fc" id="L466">                        log.error(&quot;Client sent ERROR {} with explanation {}&quot;, msg.getError().getCode().name(),</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">                                msg.getError().hasExplanation() ? msg.getError().getExplanation() : &quot;&quot;);</span>
<span class="fc" id="L468">                        conn.destroyConnection(CloseReason.REMOTE_SENT_ERROR);</span>
<span class="fc" id="L469">                        return;</span>
                    default:
<span class="nc" id="L471">                        final String errorText = &quot;Got unknown message type or type that doesn't apply to servers.&quot;;</span>
<span class="nc" id="L472">                        error(errorText, Protos.Error.ErrorCode.SYNTAX_ERROR, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
                }
<span class="fc" id="L474">            } catch (VerificationException e) {</span>
<span class="fc" id="L475">                log.error(&quot;Caught verification exception handling message from client&quot;, e);</span>
<span class="fc" id="L476">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L477">            } catch (ValueOutOfRangeException e) {</span>
<span class="nc" id="L478">                log.error(&quot;Caught value out of range exception handling message from client&quot;, e);</span>
<span class="nc" id="L479">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L480">            } catch (InsufficientMoneyException e) {</span>
<span class="nc" id="L481">                log.error(&quot;Caught insufficient money exception handling message from client&quot;, e);</span>
<span class="nc" id="L482">                error(e.getMessage(), Protos.Error.ErrorCode.BAD_TRANSACTION, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="nc" id="L483">            } catch (IllegalStateException e) {</span>
<span class="nc" id="L484">                log.error(&quot;Caught illegal state exception handling message from client&quot;, e);</span>
<span class="nc" id="L485">                error(e.getMessage(), Protos.Error.ErrorCode.SYNTAX_ERROR, CloseReason.REMOTE_SENT_INVALID_MESSAGE);</span>
<span class="pc" id="L486">            }</span>
        } finally {
<span class="pc" id="L488">            lock.unlock();</span>
<span class="fc" id="L489">        }</span>
<span class="fc" id="L490">    }</span>

    private void error(String message, Protos.Error.ErrorCode errorCode, CloseReason closeReason) {
<span class="fc" id="L493">        log.error(message);</span>
        Protos.Error.Builder errorBuilder;
<span class="fc" id="L495">        errorBuilder = Protos.Error.newBuilder()</span>
<span class="fc" id="L496">                .setCode(errorCode)</span>
<span class="fc" id="L497">                .setExplanation(message);</span>
<span class="fc" id="L498">        conn.sendToClient(Protos.TwoWayChannelMessage.newBuilder()</span>
<span class="fc" id="L499">                .setError(errorBuilder)</span>
<span class="fc" id="L500">                .setType(Protos.TwoWayChannelMessage.MessageType.ERROR)</span>
<span class="fc" id="L501">                .build());</span>
<span class="fc" id="L502">        conn.destroyConnection(closeReason);</span>
<span class="fc" id="L503">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void receiveCloseMessage() throws InsufficientMoneyException {
<span class="fc" id="L507">        log.info(&quot;Got CLOSE message, closing channel&quot;);</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">        if (state != null) {</span>
<span class="fc" id="L509">            settlePayment(CloseReason.CLIENT_REQUESTED_CLOSE);</span>
        } else {
<span class="fc" id="L511">            conn.destroyConnection(CloseReason.CLIENT_REQUESTED_CLOSE);</span>
        }
<span class="fc" id="L513">    }</span>

    @GuardedBy(&quot;lock&quot;)
    private void settlePayment(final CloseReason clientRequestedClose) throws InsufficientMoneyException {
        // Setting channelSettling here prevents us from sending another CLOSE when state.close() calls
        // close() on us here below via the stored channel state.
        // TODO: Strongly separate the lifecycle of the payment channel from the TCP connection in these classes.
<span class="fc" id="L520">        channelSettling = true;</span>
<span class="fc" id="L521">        Futures.addCallback(state.close(), new FutureCallback&lt;Transaction&gt;() {</span>
            @Override
            public void onSuccess(Transaction result) {
                // Send the successfully accepted transaction back to the client.
<span class="fc" id="L525">                final Protos.TwoWayChannelMessage.Builder msg = Protos.TwoWayChannelMessage.newBuilder();</span>
<span class="fc" id="L526">                msg.setType(Protos.TwoWayChannelMessage.MessageType.CLOSE);</span>
<span class="pc bpc" id="L527" title="1 of 2 branches missed.">                if (result != null) {</span>
                    // Result can be null on various error paths, like if we never actually opened
                    // properly and so on.
<span class="fc" id="L530">                    msg.getSettlementBuilder().setTx(ByteString.copyFrom(result.bitcoinSerialize()));</span>
<span class="fc" id="L531">                    log.info(&quot;Sending CLOSE back with broadcast settlement tx.&quot;);</span>
                } else {
<span class="nc" id="L533">                    log.info(&quot;Sending CLOSE back without broadcast settlement tx.&quot;);</span>
                }
<span class="fc" id="L535">                conn.sendToClient(msg.build());</span>
<span class="fc" id="L536">                conn.destroyConnection(clientRequestedClose);</span>
<span class="fc" id="L537">            }</span>

            @Override
            public void onFailure(Throwable t) {
<span class="nc" id="L541">                log.error(&quot;Failed to broadcast settlement tx&quot;, t);</span>
<span class="nc" id="L542">                conn.destroyConnection(clientRequestedClose);</span>
<span class="nc" id="L543">            }</span>
        });
<span class="fc" id="L545">    }</span>

    /**
     * &lt;p&gt;Called when the connection terminates. Notifies the {@link StoredServerChannel} object that we can attempt to
     * resume this channel in the future and stops generating messages for the client.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this &lt;b&gt;MUST&lt;/b&gt; still be called even after either
     * {@link ServerConnection#destroyConnection(CloseReason)} or
     * {@link PaymentChannelServer#close()} is called to actually handle the connection close logic.&lt;/p&gt;
     */
    public void connectionClosed() {
<span class="fc" id="L556">        lock.lock();</span>
        try {
<span class="fc" id="L558">            log.info(&quot;Server channel closed.&quot;);</span>
<span class="fc" id="L559">            connectionOpen = false;</span>

            try {
<span class="pc bpc" id="L562" title="2 of 4 branches missed.">                if (state != null &amp;&amp; state.getContract() != null) {</span>
<span class="fc" id="L563">                    StoredPaymentChannelServerStates channels = (StoredPaymentChannelServerStates)</span>
<span class="fc" id="L564">                            wallet.getExtensions().get(StoredPaymentChannelServerStates.EXTENSION_ID);</span>
<span class="pc bpc" id="L565" title="1 of 2 branches missed.">                    if (channels != null) {</span>
<span class="fc" id="L566">                        StoredServerChannel storedServerChannel = channels.getChannel(state.getContract().getHash());</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">                        if (storedServerChannel != null) {</span>
<span class="fc" id="L568">                            storedServerChannel.clearConnectedHandler();</span>
                        }
                    }
                }
<span class="nc" id="L572">            } catch (IllegalStateException e) {</span>
                // Expected when we call getContract() sometimes
<span class="fc" id="L574">            }</span>
        } finally {
<span class="pc" id="L576">            lock.unlock();</span>
<span class="fc" id="L577">        }</span>
<span class="fc" id="L578">    }</span>

    /**
     * Called to indicate the connection has been opened and messages can now be generated for the client.
     */
    public void connectionOpen() {
<span class="fc" id="L584">        lock.lock();</span>
        try {
<span class="fc" id="L586">            log.info(&quot;New server channel active.&quot;);</span>
<span class="fc" id="L587">            connectionOpen = true;</span>
        } finally {
<span class="pc" id="L589">            lock.unlock();</span>
<span class="fc" id="L590">        }</span>
<span class="fc" id="L591">    }</span>

    /**
     * &lt;p&gt;Closes the connection by generating a settle message for the client and calls
     * {@link ServerConnection#destroyConnection(CloseReason)}. Note that this does not broadcast
     * the payment transaction and the client may still resume the same channel if they reconnect&lt;/p&gt;
     * &lt;p&gt;
     * &lt;p&gt;Note that {@link PaymentChannelServer#connectionClosed()} must still be called after the connection fully
     * closes.&lt;/p&gt;
     */
    public void close() {
<span class="fc" id="L602">        lock.lock();</span>
        try {
<span class="pc bpc" id="L604" title="1 of 4 branches missed.">            if (connectionOpen &amp;&amp; !channelSettling) {</span>
<span class="fc" id="L605">                final Protos.TwoWayChannelMessage.Builder msg = Protos.TwoWayChannelMessage.newBuilder();</span>
<span class="fc" id="L606">                msg.setType(Protos.TwoWayChannelMessage.MessageType.CLOSE);</span>
<span class="fc" id="L607">                conn.sendToClient(msg.build());</span>
<span class="fc" id="L608">                conn.destroyConnection(CloseReason.SERVER_REQUESTED_CLOSE);</span>
            }
        } finally {
<span class="pc" id="L611">            lock.unlock();</span>
<span class="fc" id="L612">        }</span>
<span class="fc" id="L613">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>