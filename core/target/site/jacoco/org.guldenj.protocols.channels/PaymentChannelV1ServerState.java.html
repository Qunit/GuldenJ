<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PaymentChannelV1ServerState.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">guldenj</a> &gt; <a href="index.source.html" class="el_package">org.guldenj.protocols.channels</a> &gt; <span class="el_source">PaymentChannelV1ServerState.java</span></div><h1>PaymentChannelV1ServerState.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.guldenj.protocols.channels;

import com.google.common.collect.*;
import org.guldenj.core.*;
import org.guldenj.crypto.TransactionSignature;
import org.guldenj.script.Script;
import org.guldenj.script.ScriptBuilder;
import com.google.common.util.concurrent.FutureCallback;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.SettableFuture;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.Locale;

import static com.google.common.base.Preconditions.*;

/**
 * Version 1 of the payment channel server state object. Common functionality is
 * present in the parent class.
 */
public class PaymentChannelV1ServerState extends PaymentChannelServerState {
<span class="fc" id="L41">    private static final Logger log = LoggerFactory.getLogger(PaymentChannelV1ServerState.class);</span>

    // The total value locked into the multi-sig output and the value to us in the last signature the client provided
    private Coin feePaidForPayment;

    // The client key for the multi-sig contract
    // We currently also use the serverKey for payouts, but this is not required
    protected ECKey clientKey;

    // The refund/change transaction output that goes back to the client
    private TransactionOutput clientOutput;
    private long refundTransactionUnlockTimeSecs;

    PaymentChannelV1ServerState(StoredServerChannel storedServerChannel, Wallet wallet, TransactionBroadcaster broadcaster) throws VerificationException {
<span class="fc" id="L55">        super(storedServerChannel, wallet, broadcaster);</span>
<span class="fc" id="L56">        synchronized (storedServerChannel) {</span>
<span class="fc" id="L57">            this.clientKey = ECKey.fromPublicOnly(getContractScript().getChunks().get(1).data);</span>
<span class="fc" id="L58">            this.clientOutput = checkNotNull(storedServerChannel.clientOutput);</span>
<span class="fc" id="L59">            this.refundTransactionUnlockTimeSecs = storedServerChannel.refundTransactionUnlockTimeSecs;</span>
<span class="fc" id="L60">            stateMachine.transition(State.READY);</span>
<span class="pc" id="L61">        }</span>
<span class="fc" id="L62">    }</span>

    /**
     * Creates a new state object to track the server side of a payment channel.
     *
     * @param broadcaster The peer group which we will broadcast transactions to, this should have multiple peers
     * @param wallet The wallet which will be used to complete transactions
     * @param serverKey The private key which we use for our part of the multi-sig contract
     *                  (this MUST be fresh and CANNOT be used elsewhere)
     * @param minExpireTime The earliest time at which the client can claim the refund transaction (UNIX timestamp of block)
     */
    public PaymentChannelV1ServerState(TransactionBroadcaster broadcaster, Wallet wallet, ECKey serverKey, long minExpireTime) {
<span class="fc" id="L74">        super(broadcaster, wallet, serverKey, minExpireTime);</span>
<span class="fc" id="L75">        stateMachine.transition(State.WAITING_FOR_REFUND_TRANSACTION);</span>
<span class="fc" id="L76">    }</span>

    @Override
    public Multimap&lt;State, State&gt; getStateTransitions() {
<span class="fc" id="L80">        Multimap&lt;State, State&gt; result = MultimapBuilder.enumKeys(State.class).arrayListValues().build();</span>
<span class="fc" id="L81">        result.put(State.UNINITIALISED, State.READY);</span>
<span class="fc" id="L82">        result.put(State.UNINITIALISED, State.WAITING_FOR_REFUND_TRANSACTION);</span>
<span class="fc" id="L83">        result.put(State.WAITING_FOR_REFUND_TRANSACTION, State.WAITING_FOR_MULTISIG_CONTRACT);</span>
<span class="fc" id="L84">        result.put(State.WAITING_FOR_MULTISIG_CONTRACT, State.WAITING_FOR_MULTISIG_ACCEPTANCE);</span>
<span class="fc" id="L85">        result.put(State.WAITING_FOR_MULTISIG_ACCEPTANCE, State.READY);</span>
<span class="fc" id="L86">        result.put(State.READY, State.CLOSING);</span>
<span class="fc" id="L87">        result.put(State.CLOSING, State.CLOSED);</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">        for (State state : State.values()) {</span>
<span class="fc" id="L89">            result.put(state, State.ERROR);</span>
        }
<span class="fc" id="L91">        return result;</span>
    }

    @Override
    public int getMajorVersion() {
<span class="fc" id="L96">        return 1;</span>
    }

    @Override
    public TransactionOutput getClientOutput() {
<span class="fc" id="L101">        return clientOutput;</span>
    }

    @Override
    protected Script getSignedScript() {
<span class="fc" id="L106">        return getContractScript();</span>
    }

    /**
     * Called when the client provides the refund transaction.
     * The refund transaction must have one input from the multisig contract (that we don't have yet) and one output
     * that the client creates to themselves. This object will later be modified when we start getting paid.
     *
     * @param refundTx The refund transaction, this object will be mutated when payment is incremented.
     * @param clientMultiSigPubKey The client's pubkey which is required for the multisig output
     * @return Our signature that makes the refund transaction valid
     * @throws VerificationException If the transaction isnt valid or did not meet the requirements of a refund transaction.
     */
    public synchronized byte[] provideRefundTransaction(Transaction refundTx, byte[] clientMultiSigPubKey) throws VerificationException {
<span class="fc" id="L120">        checkNotNull(refundTx);</span>
<span class="fc" id="L121">        checkNotNull(clientMultiSigPubKey);</span>
<span class="fc" id="L122">        stateMachine.checkState(State.WAITING_FOR_REFUND_TRANSACTION);</span>
<span class="fc" id="L123">        log.info(&quot;Provided with refund transaction: {}&quot;, refundTx);</span>
        // Do a few very basic syntax sanity checks.
<span class="fc" id="L125">        refundTx.verify();</span>
        // Verify that the refund transaction has a single input (that we can fill to sign the multisig output).
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (refundTx.getInputs().size() != 1)</span>
<span class="fc" id="L128">            throw new VerificationException(&quot;Refund transaction does not have exactly one input&quot;);</span>
        // Verify that the refund transaction has a time lock on it and a sequence number of zero.
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (refundTx.getInput(0).getSequenceNumber() != 0)</span>
<span class="fc" id="L131">            throw new VerificationException(&quot;Refund transaction's input's sequence number is non-0&quot;);</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (refundTx.getLockTime() &lt; minExpireTime)</span>
<span class="fc" id="L133">            throw new VerificationException(&quot;Refund transaction has a lock time too soon&quot;);</span>
        // Verify the transaction has one output (we don't care about its contents, its up to the client)
        // Note that because we sign with SIGHASH_NONE|SIGHASH_ANYOENCANPAY the client can later add more outputs and
        // inputs, but we will need only one output later to create the paying transactions
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (refundTx.getOutputs().size() != 1)</span>
<span class="fc" id="L138">            throw new VerificationException(&quot;Refund transaction does not have exactly one output&quot;);</span>

<span class="fc" id="L140">        refundTransactionUnlockTimeSecs = refundTx.getLockTime();</span>

        // Sign the refund tx with the scriptPubKey and return the signature. We don't have the spending transaction
        // so do the steps individually.
<span class="fc" id="L144">        clientKey = ECKey.fromPublicOnly(clientMultiSigPubKey);</span>
<span class="fc" id="L145">        Script multisigPubKey = ScriptBuilder.createMultiSigOutputScript(2, ImmutableList.of(clientKey, serverKey));</span>
        // We are really only signing the fact that the transaction has a proper lock time and don't care about anything
        // else, so we sign SIGHASH_NONE and SIGHASH_ANYONECANPAY.
<span class="fc" id="L148">        TransactionSignature sig = refundTx.calculateSignature(0, serverKey, multisigPubKey, Transaction.SigHash.NONE, true);</span>
<span class="fc" id="L149">        log.info(&quot;Signed refund transaction.&quot;);</span>
<span class="fc" id="L150">        this.clientOutput = refundTx.getOutput(0);</span>
<span class="fc" id="L151">        stateMachine.transition(State.WAITING_FOR_MULTISIG_CONTRACT);</span>
<span class="fc" id="L152">        return sig.encodeToBitcoin();</span>
    }

    protected Script createOutputScript() {
<span class="fc" id="L156">        return ScriptBuilder.createMultiSigOutputScript(2, ImmutableList.&lt;ECKey&gt;of(clientKey, serverKey));</span>
    }

    protected ECKey getClientKey() {
<span class="fc" id="L160">        return clientKey;</span>
    }

    // Signs the first input of the transaction which must spend the multisig contract.
    private void signMultisigInput(Transaction tx, Transaction.SigHash hashType, boolean anyoneCanPay) {
<span class="fc" id="L165">        TransactionSignature signature = tx.calculateSignature(0, serverKey, getContractScript(), hashType, anyoneCanPay);</span>
<span class="fc" id="L166">        byte[] mySig = signature.encodeToBitcoin();</span>
<span class="fc" id="L167">        Script scriptSig = ScriptBuilder.createMultiSigInputScriptBytes(ImmutableList.of(bestValueSignature, mySig));</span>
<span class="fc" id="L168">        tx.getInput(0).setScriptSig(scriptSig);</span>
<span class="fc" id="L169">    }</span>

<span class="fc" id="L171">    final SettableFuture&lt;Transaction&gt; closedFuture = SettableFuture.create();</span>
    /**
     * &lt;p&gt;Closes this channel and broadcasts the highest value payment transaction on the network.&lt;/p&gt;
     *
     * &lt;p&gt;This will set the state to {@link State#CLOSED} if the transaction is successfully broadcast on the network.
     * If we fail to broadcast for some reason, the state is set to {@link State#ERROR}.&lt;/p&gt;
     *
     * &lt;p&gt;If the current state is before {@link State#READY} (ie we have not finished initializing the channel), we
     * simply set the state to {@link State#CLOSED} and let the client handle getting its refund transaction confirmed.
     * &lt;/p&gt;
     *
     * @return a future which completes when the provided multisig contract successfully broadcasts, or throws if the
     *         broadcast fails for some reason. Note that if the network simply rejects the transaction, this future
     *         will never complete, a timeout should be used.
     * @throws InsufficientMoneyException If the payment tx would have cost more in fees to spend than it is worth.
     */
    @Override
    public synchronized ListenableFuture&lt;Transaction&gt; close() throws InsufficientMoneyException {
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (storedServerChannel != null) {</span>
<span class="fc" id="L190">            StoredServerChannel temp = storedServerChannel;</span>
<span class="fc" id="L191">            storedServerChannel = null;</span>
<span class="fc" id="L192">            StoredPaymentChannelServerStates channels = (StoredPaymentChannelServerStates)</span>
<span class="fc" id="L193">                    wallet.getExtensions().get(StoredPaymentChannelServerStates.EXTENSION_ID);</span>
<span class="fc" id="L194">            channels.closeChannel(temp); // May call this method again for us (if it wasn't the original caller)</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">            if (getState().compareTo(State.CLOSING) &gt;= 0)</span>
<span class="fc" id="L196">                return closedFuture;</span>
        }

<span class="pc bpc" id="L199" title="1 of 2 branches missed.">        if (getState().ordinal() &lt; State.READY.ordinal()) {</span>
<span class="nc" id="L200">            log.error(&quot;Attempt to settle channel in state &quot; + getState());</span>
<span class="nc" id="L201">            stateMachine.transition(State.CLOSED);</span>
<span class="nc" id="L202">            closedFuture.set(null);</span>
<span class="nc" id="L203">            return closedFuture;</span>
        }
<span class="fc bfc" id="L205" title="All 2 branches covered.">        if (getState() != State.READY) {</span>
            // TODO: What is this codepath for?
<span class="fc" id="L207">            log.warn(&quot;Failed attempt to settle a channel in state &quot; + getState());</span>
<span class="fc" id="L208">            return closedFuture;</span>
        }
<span class="fc" id="L210">        Transaction tx = null;</span>
        try {
<span class="fc" id="L212">            Wallet.SendRequest req = makeUnsignedChannelContract(bestValueToMe);</span>
<span class="fc" id="L213">            tx = req.tx;</span>
            // Provide a throwaway signature so that completeTx won't complain out about unsigned inputs it doesn't
            // know how to sign. Note that this signature does actually have to be valid, so we can't use a dummy
            // signature to save time, because otherwise completeTx will try to re-sign it to make it valid and then
            // die. We could probably add features to the SendRequest API to make this a bit more efficient.
<span class="fc" id="L218">            signMultisigInput(tx, Transaction.SigHash.NONE, true);</span>
            // Let wallet handle adding additional inputs/fee as necessary.
<span class="fc" id="L220">            req.shuffleOutputs = false;</span>
<span class="fc" id="L221">            req.missingSigsMode = Wallet.MissingSigsMode.USE_DUMMY_SIG;</span>
<span class="fc" id="L222">            wallet.completeTx(req);  // TODO: Fix things so shuffling is usable.</span>
<span class="fc" id="L223">            feePaidForPayment = req.tx.getFee();</span>
<span class="fc" id="L224">            log.info(&quot;Calculated fee is {}&quot;, feePaidForPayment);</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">            if (feePaidForPayment.compareTo(bestValueToMe) &gt; 0) {</span>
<span class="fc" id="L226">                final String msg = String.format(Locale.US, &quot;Had to pay more in fees (%s) than the channel was worth (%s)&quot;,</span>
                        feePaidForPayment, bestValueToMe);
<span class="fc" id="L228">                throw new InsufficientMoneyException(feePaidForPayment.subtract(bestValueToMe), msg);</span>
            }
            // Now really sign the multisig input.
<span class="fc" id="L231">            signMultisigInput(tx, Transaction.SigHash.ALL, false);</span>
            // Some checks that shouldn't be necessary but it can't hurt to check.
<span class="fc" id="L233">            tx.verify();  // Sanity check syntax.</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            for (TransactionInput input : tx.getInputs())</span>
<span class="fc" id="L235">                input.verify();  // Run scripts and ensure it is valid.</span>
<span class="fc" id="L236">        } catch (InsufficientMoneyException e) {</span>
<span class="fc" id="L237">            throw e;  // Don't fall through.</span>
<span class="nc" id="L238">        } catch (Exception e) {</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">            log.error(&quot;Could not verify self-built tx\nMULTISIG {}\nCLOSE {}&quot;, contract, tx != null ? tx : &quot;&quot;);</span>
<span class="nc" id="L240">            throw new RuntimeException(e);  // Should never happen.</span>
<span class="fc" id="L241">        }</span>
<span class="fc" id="L242">        stateMachine.transition(State.CLOSING);</span>
<span class="fc" id="L243">        log.info(&quot;Closing channel, broadcasting tx {}&quot;, tx);</span>
        // The act of broadcasting the transaction will add it to the wallet.
<span class="fc" id="L245">        ListenableFuture&lt;Transaction&gt; future = broadcaster.broadcastTransaction(tx).future();</span>
<span class="fc" id="L246">        Futures.addCallback(future, new FutureCallback&lt;Transaction&gt;() {</span>
            @Override public void onSuccess(Transaction transaction) {
<span class="fc" id="L248">                log.info(&quot;TX {} propagated, channel successfully closed.&quot;, transaction.getHash());</span>
<span class="fc" id="L249">                stateMachine.transition(State.CLOSED);</span>
<span class="fc" id="L250">                closedFuture.set(transaction);</span>
<span class="fc" id="L251">            }</span>

            @Override public void onFailure(Throwable throwable) {
<span class="fc" id="L254">                log.error(&quot;Failed to settle channel, could not broadcast: {}&quot;, throwable);</span>
<span class="fc" id="L255">                stateMachine.transition(State.ERROR);</span>
<span class="fc" id="L256">                closedFuture.setException(throwable);</span>
<span class="fc" id="L257">            }</span>
        });
<span class="fc" id="L259">        return closedFuture;</span>
    }

    /**
     * Gets the fee paid in the final payment transaction (only available if settle() did not throw an exception)
     */
    @Override
    public synchronized Coin getFeePaid() {
<span class="fc" id="L267">        stateMachine.checkState(State.CLOSED, State.CLOSING);</span>
<span class="fc" id="L268">        return feePaidForPayment;</span>
    }

    /**
     * Gets the client's refund transaction which they can spend to get the entire channel value back if it reaches its
     * lock time.
     */
    public synchronized long getRefundTransactionUnlockTime() {
<span class="nc bnc" id="L276" title="All 4 branches missed.">        checkState(getState().compareTo(State.WAITING_FOR_MULTISIG_CONTRACT) &gt; 0 &amp;&amp; getState() != State.ERROR);</span>
<span class="nc" id="L277">        return refundTransactionUnlockTimeSecs;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>