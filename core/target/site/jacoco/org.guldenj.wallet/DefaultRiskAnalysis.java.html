<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DefaultRiskAnalysis.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">guldenj</a> &gt; <a href="index.source.html" class="el_package">org.guldenj.wallet</a> &gt; <span class="el_source">DefaultRiskAnalysis.java</span></div><h1>DefaultRiskAnalysis.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2013 Google Inc.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.guldenj.wallet;

import org.guldenj.core.Coin;
import org.guldenj.core.ECKey;
import org.guldenj.core.ECKey.ECDSASignature;
import org.guldenj.core.NetworkParameters;
import org.guldenj.core.Transaction;
import org.guldenj.core.TransactionConfidence;
import org.guldenj.core.TransactionInput;
import org.guldenj.core.TransactionOutput;
import org.guldenj.core.Wallet;
import org.guldenj.crypto.TransactionSignature;
import org.guldenj.script.ScriptChunk;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Nullable;

import java.util.List;

import static com.google.common.base.Preconditions.checkState;

/**
 * &lt;p&gt;The default risk analysis. Currently, it only is concerned with whether a tx/dependency is non-final or not, and
 * whether a tx/dependency violates the dust rules. Outside of specialised protocols you should not encounter non-final
 * transactions.&lt;/p&gt;
 */
public class DefaultRiskAnalysis implements RiskAnalysis {
<span class="fc" id="L46">    private static final Logger log = LoggerFactory.getLogger(DefaultRiskAnalysis.class);</span>

    /**
     * Any standard output smaller than this value (in satoshis) will be considered risky, as it's most likely be
     * rejected by the network. This is usually the same as {@link Transaction#MIN_NONDUST_OUTPUT} but can be
     * different when the fee is about to change in Bitcoin Core.
     */
<span class="fc" id="L53">    public static final Coin MIN_ANALYSIS_NONDUST_OUTPUT = Transaction.MIN_NONDUST_OUTPUT;</span>

    protected final Transaction tx;
    protected final List&lt;Transaction&gt; dependencies;
    @Nullable protected final Wallet wallet;

    private Transaction nonStandard;
    protected Transaction nonFinal;
    protected boolean analyzed;

<span class="fc" id="L63">    private DefaultRiskAnalysis(Wallet wallet, Transaction tx, List&lt;Transaction&gt; dependencies) {</span>
<span class="fc" id="L64">        this.tx = tx;</span>
<span class="fc" id="L65">        this.dependencies = dependencies;</span>
<span class="fc" id="L66">        this.wallet = wallet;</span>
<span class="fc" id="L67">    }</span>

    @Override
    public Result analyze() {
<span class="fc bfc" id="L71" title="All 2 branches covered.">        checkState(!analyzed);</span>
<span class="fc" id="L72">        analyzed = true;</span>

<span class="fc" id="L74">        Result result = analyzeIsFinal();</span>
<span class="pc bpc" id="L75" title="1 of 4 branches missed.">        if (result != null &amp;&amp; result != Result.OK)</span>
<span class="fc" id="L76">            return result;</span>

<span class="fc" id="L78">        return analyzeIsStandard();</span>
    }

    @Nullable
    private Result analyzeIsFinal() {
        // Transactions we create ourselves are, by definition, not at risk of double spending against us.
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (tx.getConfidence().getSource() == TransactionConfidence.Source.SELF)</span>
<span class="fc" id="L85">            return Result.OK;</span>

        // We consider transactions that opt into replace-by-fee at risk of double spending.
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (tx.isOptInFullRBF()) {</span>
<span class="fc" id="L89">            nonFinal = tx;</span>
<span class="fc" id="L90">            return Result.NON_FINAL;</span>
        }

<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (wallet == null)</span>
<span class="nc" id="L94">            return null;</span>

<span class="fc" id="L96">        final int height = wallet.getLastBlockSeenHeight();</span>
<span class="fc" id="L97">        final long time = wallet.getLastBlockSeenTimeSecs();</span>
        // If the transaction has a lock time specified in blocks, we consider that if the tx would become final in the
        // next block it is not risky (as it would confirm normally).
<span class="fc" id="L100">        final int adjustedHeight = height + 1;</span>

<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (!tx.isFinal(adjustedHeight, time)) {</span>
<span class="fc" id="L103">            nonFinal = tx;</span>
<span class="fc" id="L104">            return Result.NON_FINAL;</span>
        }
<span class="fc bfc" id="L106" title="All 2 branches covered.">        for (Transaction dep : dependencies) {</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">            if (!dep.isFinal(adjustedHeight, time)) {</span>
<span class="fc" id="L108">                nonFinal = dep;</span>
<span class="fc" id="L109">                return Result.NON_FINAL;</span>
            }
<span class="nc" id="L111">        }</span>

<span class="fc" id="L113">        return Result.OK;</span>
    }

    /**
     * The reason a transaction is considered non-standard, returned by
     * {@link #isStandard(org.guldenj.core.Transaction)}.
     */
<span class="pc" id="L120">    public enum RuleViolation {</span>
<span class="fc" id="L121">        NONE,</span>
<span class="fc" id="L122">        VERSION,</span>
<span class="fc" id="L123">        DUST,</span>
<span class="fc" id="L124">        SHORTEST_POSSIBLE_PUSHDATA,</span>
<span class="fc" id="L125">        NONEMPTY_STACK, // Not yet implemented (for post 0.12)</span>
<span class="fc" id="L126">        SIGNATURE_CANONICAL_ENCODING</span>
    }

    /**
     * &lt;p&gt;Checks if a transaction is considered &quot;standard&quot; by Bitcoin Core's IsStandardTx and AreInputsStandard
     * functions.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this method currently only implements a minimum of checks. More to be added later.&lt;/p&gt;
     */
    public static RuleViolation isStandard(Transaction tx) {
        // TODO: Finish this function off.
<span class="pc bpc" id="L137" title="2 of 4 branches missed.">        if (tx.getVersion() &gt; 1 || tx.getVersion() &lt; 1) {</span>
<span class="nc" id="L138">            log.warn(&quot;TX considered non-standard due to unknown version number {}&quot;, tx.getVersion());</span>
<span class="nc" id="L139">            return RuleViolation.VERSION;</span>
        }

<span class="fc" id="L142">        final List&lt;TransactionOutput&gt; outputs = tx.getOutputs();</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        for (int i = 0; i &lt; outputs.size(); i++) {</span>
<span class="fc" id="L144">            TransactionOutput output = outputs.get(i);</span>
<span class="fc" id="L145">            RuleViolation violation = isOutputStandard(output);</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (violation != RuleViolation.NONE) {</span>
<span class="fc" id="L147">                log.warn(&quot;TX considered non-standard due to output {} violating rule {}&quot;, i, violation);</span>
<span class="fc" id="L148">                return violation;</span>
            }
        }

<span class="fc" id="L152">        final List&lt;TransactionInput&gt; inputs = tx.getInputs();</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        for (int i = 0; i &lt; inputs.size(); i++) {</span>
<span class="fc" id="L154">            TransactionInput input = inputs.get(i);</span>
<span class="fc" id="L155">            RuleViolation violation = isInputStandard(input);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">            if (violation != RuleViolation.NONE) {</span>
<span class="fc" id="L157">                log.warn(&quot;TX considered non-standard due to input {} violating rule {}&quot;, i, violation);</span>
<span class="fc" id="L158">                return violation;</span>
            }
        }

<span class="fc" id="L162">        return RuleViolation.NONE;</span>
    }

    /**
     * Checks the output to see if the script violates a standardness rule. Not complete.
     */
    public static RuleViolation isOutputStandard(TransactionOutput output) {
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (output.getValue().compareTo(MIN_ANALYSIS_NONDUST_OUTPUT) &lt; 0)</span>
<span class="fc" id="L170">            return RuleViolation.DUST;</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">        for (ScriptChunk chunk : output.getScriptPubKey().getChunks()) {</span>
<span class="fc bfc" id="L172" title="All 4 branches covered.">            if (chunk.isPushData() &amp;&amp; !chunk.isShortestPossiblePushData())</span>
<span class="fc" id="L173">                return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;</span>
<span class="fc" id="L174">        }</span>
<span class="fc" id="L175">        return RuleViolation.NONE;</span>
    }

    /** Checks if the given input passes some of the AreInputsStandard checks. Not complete. */
    public static RuleViolation isInputStandard(TransactionInput input) {
<span class="fc bfc" id="L180" title="All 2 branches covered.">        for (ScriptChunk chunk : input.getScriptSig().getChunks()) {</span>
<span class="pc bpc" id="L181" title="1 of 4 branches missed.">            if (chunk.data != null &amp;&amp; !chunk.isShortestPossiblePushData())</span>
<span class="fc" id="L182">                return RuleViolation.SHORTEST_POSSIBLE_PUSHDATA;</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">            if (chunk.isPushData()) {</span>
                ECDSASignature signature;
                try {
<span class="fc" id="L186">                    signature = ECKey.ECDSASignature.decodeFromDER(chunk.data);</span>
<span class="fc" id="L187">                } catch (RuntimeException x) {</span>
                    // Doesn't look like a signature.
<span class="fc" id="L189">                    signature = null;</span>
<span class="fc" id="L190">                }</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">                if (signature != null) {</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">                    if (!TransactionSignature.isEncodingCanonical(chunk.data))</span>
<span class="fc" id="L193">                        return RuleViolation.SIGNATURE_CANONICAL_ENCODING;</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">                    if (!signature.isCanonical())</span>
<span class="fc" id="L195">                        return RuleViolation.SIGNATURE_CANONICAL_ENCODING;</span>
                }
            }
<span class="fc" id="L198">        }</span>
<span class="fc" id="L199">        return RuleViolation.NONE;</span>
    }

    private Result analyzeIsStandard() {
        // The IsStandard rules don't apply on testnet, because they're just a safety mechanism and we don't want to
        // crush innovation with valueless test coins.
<span class="pc bpc" id="L205" title="1 of 4 branches missed.">        if (wallet != null &amp;&amp; !wallet.getNetworkParameters().getId().equals(NetworkParameters.ID_MAINNET))</span>
<span class="fc" id="L206">            return Result.OK;</span>

<span class="fc" id="L208">        RuleViolation ruleViolation = isStandard(tx);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">        if (ruleViolation != RuleViolation.NONE) {</span>
<span class="fc" id="L210">            nonStandard = tx;</span>
<span class="fc" id="L211">            return Result.NON_STANDARD;</span>
        }

<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        for (Transaction dep : dependencies) {</span>
<span class="nc" id="L215">            ruleViolation = isStandard(dep);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">            if (ruleViolation != RuleViolation.NONE) {</span>
<span class="nc" id="L217">                nonStandard = dep;</span>
<span class="nc" id="L218">                return Result.NON_STANDARD;</span>
            }
<span class="nc" id="L220">        }</span>

<span class="fc" id="L222">        return Result.OK;</span>
    }

    /** Returns the transaction that was found to be non-standard, or null. */
    @Nullable
    public Transaction getNonStandard() {
<span class="nc" id="L228">        return nonStandard;</span>
    }

    /** Returns the transaction that was found to be non-final, or null. */
    @Nullable
    public Transaction getNonFinal() {
<span class="fc" id="L234">        return nonFinal;</span>
    }

    @Override
    public String toString() {
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (!analyzed)</span>
<span class="nc" id="L240">            return &quot;Pending risk analysis for &quot; + tx.getHashAsString();</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">        else if (nonFinal != null)</span>
<span class="nc" id="L242">            return &quot;Risky due to non-finality of &quot; + nonFinal.getHashAsString();</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">        else if (nonStandard != null)</span>
<span class="nc" id="L244">            return &quot;Risky due to non-standard tx &quot; + nonStandard.getHashAsString();</span>
        else
<span class="nc" id="L246">            return &quot;Non-risky&quot;;</span>
    }

<span class="fc" id="L249">    public static class Analyzer implements RiskAnalysis.Analyzer {</span>
        @Override
        public DefaultRiskAnalysis create(Wallet wallet, Transaction tx, List&lt;Transaction&gt; dependencies) {
<span class="fc" id="L252">            return new DefaultRiskAnalysis(wallet, tx, dependencies);</span>
        }
    }

<span class="fc" id="L256">    public static Analyzer FACTORY = new Analyzer();</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>