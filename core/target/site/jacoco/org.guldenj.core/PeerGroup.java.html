<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PeerGroup.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">guldenj</a> &gt; <a href="index.source.html" class="el_package">org.guldenj.core</a> &gt; <span class="el_source">PeerGroup.java</span></div><h1>PeerGroup.java</h1><pre class="source lang-java linenums">/**
 * Copyright 2013 Google Inc.
 * Copyright 2014 Andreas Schildbach
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.guldenj.core;

import com.google.common.annotations.*;
import com.google.common.base.*;
import com.google.common.collect.*;
import com.google.common.net.*;
import com.google.common.primitives.*;
import com.google.common.util.concurrent.*;
import com.squareup.okhttp.*;
import com.subgraph.orchid.*;
import net.jcip.annotations.*;
import org.guldenj.core.listeners.*;
import org.guldenj.crypto.*;
import org.guldenj.net.*;
import org.guldenj.net.discovery.*;
import org.guldenj.script.*;
import org.guldenj.utils.*;
import org.guldenj.utils.Threading;
import org.slf4j.*;

import javax.annotation.*;
import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.locks.*;

import static com.google.common.base.Preconditions.*;
import org.guldenj.wallet.KeyChainEventListener;

/**
 * &lt;p&gt;Runs a set of connections to the P2P network, brings up connections to replace disconnected nodes and manages
 * the interaction between them all. Most applications will want to use one of these.&lt;/p&gt;
 * 
 * &lt;p&gt;PeerGroup tries to maintain a constant number of connections to a set of distinct peers.
 * Each peer runs a network listener in its own thread.  When a connection is lost, a new peer
 * will be tried after a delay as long as the number of connections less than the maximum.&lt;/p&gt;
 * 
 * &lt;p&gt;Connections are made to addresses from a provided list.  When that list is exhausted,
 * we start again from the head of the list.&lt;/p&gt;
 * 
 * &lt;p&gt;The PeerGroup can broadcast a transaction to the currently connected set of peers.  It can
 * also handle download of the blockchain from peers, restarting the process when peers die.&lt;/p&gt;
 *
 * &lt;p&gt;A PeerGroup won't do anything until you call the {@link PeerGroup#start()} method 
 * which will block until peer discovery is completed and some outbound connections 
 * have been initiated (it will return before handshaking is done, however). 
 * You should call {@link PeerGroup#stop()} when finished. Note that not all methods
 * of PeerGroup are safe to call from a UI thread as some may do network IO, 
 * but starting and stopping the service should be fine.&lt;/p&gt;
 */
public class PeerGroup implements TransactionBroadcaster {
<span class="fc" id="L70">    private static final Logger log = LoggerFactory.getLogger(PeerGroup.class);</span>

    // All members in this class should be marked with final, volatile, @GuardedBy or a mix as appropriate to define
    // their thread safety semantics. Volatile requires a Hungarian-style v prefix.

    // By default we don't require any services because any peer will do.
<span class="fc" id="L76">    private long requiredServices = 0;</span>
    /**
     * The default number of connections to the p2p network the library will try to build. This is set to 12 empirically.
     * It used to be 4, but because we divide the connection pool in two for broadcasting transactions, that meant we
     * were only sending transactions to two peers and sometimes this wasn't reliable enough: transactions wouldn't
     * get through.
     */
    public static final int DEFAULT_CONNECTIONS = 12;
    private static final int TOR_TIMEOUT_SECONDS = 60;
<span class="fc" id="L85">    private volatile int vMaxPeersToDiscoverCount = 100;</span>
    private static final long DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS = 5000;
<span class="fc" id="L87">    private volatile long vPeerDiscoveryTimeoutMillis = DEFAULT_PEER_DISCOVERY_TIMEOUT_MILLIS;</span>

<span class="fc" id="L89">    protected final ReentrantLock lock = Threading.lock(&quot;peergroup&quot;);</span>

    protected final NetworkParameters params;
    @Nullable protected final AbstractBlockChain chain;

    // This executor is used to queue up jobs: it's used when we don't want to use locks for mutual exclusion,
    // typically because the job might call in to user provided code that needs/wants the freedom to use the API
    // however it wants, or because a job needs to be ordered relative to other jobs like that.
    protected final ListeningScheduledExecutorService executor;

    // Whether the peer group is currently running. Once shut down it cannot be restarted.
    private volatile boolean vRunning;
    // Whether the peer group has been started or not. An unstarted PG does not try to access the network.
    private volatile boolean vUsedUp;

    // Addresses to try to connect to, excluding active peers.
    @GuardedBy(&quot;lock&quot;) private final PriorityQueue&lt;PeerAddress&gt; inactives;
    @GuardedBy(&quot;lock&quot;) private final Map&lt;PeerAddress, ExponentialBackoff&gt; backoffMap;

    // Currently active peers. This is an ordered list rather than a set to make unit tests predictable.
    private final CopyOnWriteArrayList&lt;Peer&gt; peers;
    // Currently connecting peers.
    private final CopyOnWriteArrayList&lt;Peer&gt; pendingPeers;
    private final ClientConnectionManager channels;
    @Nullable private final TorClient torClient;

    // The peer that has been selected for the purposes of downloading announced data.
    @GuardedBy(&quot;lock&quot;) private Peer downloadPeer;
    // Callback for events related to chain download.
    @Nullable @GuardedBy(&quot;lock&quot;) private PeerDataEventListener downloadListener;
<span class="fc" id="L119">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;BlocksDownloadedEventListener&gt;&gt; peersBlocksDownloadedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;BlocksDownloadedEventListener&gt;&gt;();
<span class="fc" id="L121">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;ChainDownloadStartedEventListener&gt;&gt; peersChainDownloadStartedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;ChainDownloadStartedEventListener&gt;&gt;();
    /** Callbacks for events related to peers connecting */
<span class="fc" id="L124">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerConnectedEventListener&gt;&gt; peerConnectedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerConnectedEventListener&gt;&gt;();
    /** Callbacks for events related to peer connection/disconnection */
<span class="fc" id="L127">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDiscoveredEventListener&gt;&gt; peerDiscoveredEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDiscoveredEventListener&gt;&gt;();
    /** Callbacks for events related to peers disconnecting */
<span class="fc" id="L130">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDisconnectedEventListener&gt;&gt; peerDisconnectedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;PeerDisconnectedEventListener&gt;&gt;();
    /** Callbacks for events related to peer data being received */
<span class="fc" id="L133">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;GetDataEventListener&gt;&gt; peerGetDataEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;GetDataEventListener&gt;&gt;();
<span class="fc" id="L135">    private final CopyOnWriteArrayList&lt;ListenerRegistration&lt;PreMessageReceivedEventListener&gt;&gt; peersPreMessageReceivedEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;PreMessageReceivedEventListener&gt;&gt;();
<span class="fc" id="L137">    protected final CopyOnWriteArrayList&lt;ListenerRegistration&lt;OnTransactionBroadcastListener&gt;&gt; peersTransactionBroadastEventListeners</span>
        = new CopyOnWriteArrayList&lt;ListenerRegistration&lt;OnTransactionBroadcastListener&gt;&gt;();
    // Peer discovery sources, will be polled occasionally if there aren't enough inactives.
    private final CopyOnWriteArraySet&lt;PeerDiscovery&gt; peerDiscoverers;
    // The version message to use for new connections.
    @GuardedBy(&quot;lock&quot;) private VersionMessage versionMessage;
    // Switch for enabling download of pending transaction dependencies.
    @GuardedBy(&quot;lock&quot;) protected boolean downloadTxDependencies;
    // How many connections we want to have open at the current time. If we lose connections, we'll try opening more
    // until we reach this count.
    @GuardedBy(&quot;lock&quot;) private int maxConnections;
    // Minimum protocol version we will allow ourselves to connect to: require Bloom filtering.
    private volatile int vMinRequiredProtocolVersion;

    /** How many milliseconds to wait after receiving a pong before sending another ping. */
    public static final long DEFAULT_PING_INTERVAL_MSEC = 2000;
<span class="fc" id="L153">    @GuardedBy(&quot;lock&quot;) private long pingIntervalMsec = DEFAULT_PING_INTERVAL_MSEC;</span>

<span class="fc" id="L155">    @GuardedBy(&quot;lock&quot;) private boolean useLocalhostPeerWhenPossible = true;</span>
<span class="fc" id="L156">    @GuardedBy(&quot;lock&quot;) private boolean ipv6Unreachable = false;</span>

    @GuardedBy(&quot;lock&quot;) private long fastCatchupTimeSecs;
    private final CopyOnWriteArrayList&lt;Wallet&gt; wallets;
    private final CopyOnWriteArrayList&lt;PeerFilterProvider&gt; peerFilterProviders;

    // This event listener is added to every peer. It's here so when we announce transactions via an &quot;inv&quot;, every
    // peer can fetch them.
<span class="fc" id="L164">    private final PeerListener peerListener = new PeerListener();</span>

<span class="fc" id="L166">    private int minBroadcastConnections = 0;</span>
<span class="fc" id="L167">    private final ScriptsChangeEventListener walletScriptEventListener = new ScriptsChangeEventListener() {</span>
        @Override public void onScriptsChanged(Wallet wallet, List&lt;Script&gt; scripts, boolean isAddingScripts) {
<span class="nc" id="L169">            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
<span class="nc" id="L170">        }</span>
    };

<span class="fc" id="L173">    private final KeyChainEventListener walletKeyEventListener = new KeyChainEventListener() {</span>
        @Override public void onKeysAdded(List&lt;ECKey&gt; keys) {
<span class="fc" id="L175">            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
<span class="fc" id="L176">        }</span>
    };

<span class="fc" id="L179">    private final WalletCoinsReceivedEventListener walletCoinsReceivedEventListener = new WalletCoinsReceivedEventListener() {</span>
        @Override
        public void onCoinsReceived(Wallet wallet, Transaction tx, Coin prevBalance, Coin newBalance) {
            // We received a relevant transaction. We MAY need to recalculate and resend the Bloom filter, but only
            // if we have received a transaction that includes a relevant pay-to-pubkey output.
            //
            // The reason is that pay-to-pubkey outputs, when spent, will not repeat any data we can predict in their
            // inputs. So a remote peer will update the Bloom filter for us when such an output is seen matching the
            // existing filter, so that it includes the tx hash in which the pay-to-pubkey output was observed. Thus
            // the spending transaction will always match (due to the outpoint structure).
            //
            // Unfortunately, whilst this is required for correct sync of the chain in blocks, there are two edge cases.
            //
            // (1) If a wallet receives a relevant, confirmed p2pubkey output that was not broadcast across the network,
            // for example in a coinbase transaction, then the node that's serving us the chain will update its filter
            // but the rest will not. If another transaction then spends it, the other nodes won't match/relay it.
            //
            // (2) If we receive a p2pubkey output broadcast across the network, all currently connected nodes will see
            // it and update their filter themselves, but any newly connected nodes will receive the last filter we
            // calculated, which would not include this transaction.
            //
            // For this reason we check if the transaction contained any relevant pay to pubkeys and force a recalc
            // and possibly retransmit if so. The recalculation process will end up including the tx hash into the
            // filter. In case (1), we need to retransmit the filter to the connected peers. In case (2), we don't
            // and shouldn't, we should just recalculate and cache the new filter for next time.
<span class="fc bfc" id="L204" title="All 2 branches covered.">            for (TransactionOutput output : tx.getOutputs()) {</span>
<span class="pc bpc" id="L205" title="1 of 4 branches missed.">                if (output.getScriptPubKey().isSentToRawPubKey() &amp;&amp; output.isMine(wallet)) {</span>
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">                    if (tx.getConfidence().getConfidenceType() == TransactionConfidence.ConfidenceType.BUILDING)</span>
<span class="nc" id="L207">                        recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
                    else
<span class="fc" id="L209">                        recalculateFastCatchupAndFilter(FilterRecalculateMode.DONT_SEND);</span>
<span class="fc" id="L210">                    return;</span>
                }
<span class="fc" id="L212">            }</span>
<span class="fc" id="L213">        }</span>
    };

    // Exponential backoff for peers starts at 1 second and maxes at 10 minutes.
<span class="fc" id="L217">    private final ExponentialBackoff.Params peerBackoffParams = new ExponentialBackoff.Params(1000, 1.5f, 10 * 60 * 1000);</span>
    // Tracks failures globally in case of a network failure.
<span class="fc" id="L219">    @GuardedBy(&quot;lock&quot;) private ExponentialBackoff groupBackoff = new ExponentialBackoff(new ExponentialBackoff.Params(1000, 1.5f, 10 * 1000));</span>

    // This is a synchronized set, so it locks on itself. We use it to prevent TransactionBroadcast objects from
    // being garbage collected if nothing in the apps code holds on to them transitively. See the discussion
    // in broadcastTransaction.
    private final Set&lt;TransactionBroadcast&gt; runningBroadcasts;

    private class PeerListener implements GetDataEventListener, BlocksDownloadedEventListener {

<span class="fc" id="L228">        public PeerListener() {</span>
<span class="fc" id="L229">        }</span>

        @Override
        public List&lt;Message&gt; getData(Peer peer, GetDataMessage m) {
<span class="nc" id="L233">            return handleGetData(m);</span>
        }

        @Override
        public void onBlocksDownloaded(Peer peer, Block block, @Nullable FilteredBlock filteredBlock, int blocksLeft) {
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">            if (chain == null) return;</span>
<span class="fc" id="L239">            final double rate = chain.getFalsePositiveRate();</span>
<span class="fc" id="L240">            final double target = bloomFilterMerger.getBloomFilterFPRate() * MAX_FP_RATE_INCREASE;</span>
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">            if (rate &gt; target) {</span>
                // TODO: Avoid hitting this path if the remote peer didn't acknowledge applying a new filter yet.
<span class="nc bnc" id="L243" title="All 2 branches missed.">                if (log.isDebugEnabled())</span>
<span class="nc" id="L244">                    log.debug(&quot;Force update Bloom filter due to high false positive rate ({} vs {})&quot;, rate, target);</span>
<span class="nc" id="L245">                recalculateFastCatchupAndFilter(FilterRecalculateMode.FORCE_SEND_FOR_REFRESH);</span>
            }
<span class="fc" id="L247">        }</span>
    }

<span class="fc" id="L250">    private class PeerStartupListener implements PeerConnectedEventListener, PeerDisconnectedEventListener {</span>
        @Override
        public void onPeerConnected(Peer peer, int peerCount) {
<span class="fc" id="L253">            handleNewPeer(peer);</span>
<span class="fc" id="L254">        }</span>

        @Override
        public void onPeerDisconnected(Peer peer, int peerCount) {
            // The channel will be automatically removed from channels.
<span class="fc" id="L259">            handlePeerDeath(peer, null);</span>
<span class="fc" id="L260">        }</span>
    }

<span class="fc" id="L263">    private final PeerStartupListener startupListener = new PeerStartupListener();</span>

    /**
     * The default Bloom filter false positive rate, which is selected to be extremely low such that you hardly ever
     * download false positives. This provides maximum performance. Although this default can be overridden to push
     * the FP rate higher, due to &lt;a href=&quot;https://groups.google.com/forum/#!msg/guldenj/Ys13qkTwcNg/9qxnhwnkeoIJ&quot;&gt;
     * various complexities&lt;/a&gt; there are still ways a remote peer can deanonymize the users wallet. This is why the
     * FP rate is chosen for performance rather than privacy. If a future version of guldenj fixes the known
     * de-anonymization attacks this FP rate may rise again (or more likely, become expressed as a bandwidth allowance).
     */
    public static final double DEFAULT_BLOOM_FILTER_FP_RATE = 0.00001;
    /** Maximum increase in FP rate before forced refresh of the bloom filter */
    public static final double MAX_FP_RATE_INCREASE = 10.0f;
    // An object that calculates bloom filters given a list of filter providers, whilst tracking some state useful
    // for privacy purposes.
    private final FilterMerger bloomFilterMerger;

    /** The default timeout between when a connection attempt begins and version message exchange completes */
    public static final int DEFAULT_CONNECT_TIMEOUT_MILLIS = 5000;
<span class="fc" id="L282">    private volatile int vConnectTimeoutMillis = DEFAULT_CONNECT_TIMEOUT_MILLIS;</span>
    
    /** Whether bloom filter support is enabled when using a non FullPrunedBlockchain*/
<span class="fc" id="L285">    private volatile boolean vBloomFilteringEnabled = true;</span>

    /** See {@link #PeerGroup(Context)} */
    public PeerGroup(NetworkParameters params) {
<span class="nc" id="L289">        this(params, null);</span>
<span class="nc" id="L290">    }</span>

    /**
     * Creates a PeerGroup with the given context. No chain is provided so this node will report its chain height
     * as zero to other peers. This constructor is useful if you just want to explore the network but aren't interested
     * in downloading block data.
     */
    public PeerGroup(Context context) {
<span class="nc" id="L298">        this(context, null);</span>
<span class="nc" id="L299">    }</span>

    /** See {@link #PeerGroup(Context, AbstractBlockChain)} */
    public PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain) {
<span class="nc" id="L303">        this(Context.getOrCreate(params), chain, new NioClientManager());</span>
<span class="nc" id="L304">    }</span>

    /**
     * Creates a PeerGroup for the given context and chain. Blocks will be passed to the chain as they are broadcast
     * and downloaded. This is probably the constructor you want to use.
     */
    public PeerGroup(Context context, @Nullable AbstractBlockChain chain) {
<span class="nc" id="L311">        this(context, chain, new NioClientManager());</span>
<span class="nc" id="L312">    }</span>

    /** See {@link #newWithTor(Context, AbstractBlockChain, TorClient)} */
    public static PeerGroup newWithTor(NetworkParameters params, @Nullable AbstractBlockChain chain, TorClient torClient) throws TimeoutException {
<span class="nc" id="L316">        return newWithTor(Context.getOrCreate(params), chain, torClient);</span>
    }

    /**
     * &lt;p&gt;Creates a PeerGroup that accesses the network via the Tor network. The provided TorClient is used so you can
     * preconfigure it beforehand. It should not have been already started. You can just use &quot;new TorClient()&quot; if
     * you don't have any particular configuration requirements.&lt;/p&gt;
     *
     * &lt;p&gt;Peer discovery is automatically configured to use DNS seeds resolved via a random selection of exit nodes.
     * If running on the Oracle JDK the unlimited strength jurisdiction checks will also be overridden,
     * as they no longer apply anyway and can cause startup failures due to the requirement for AES-256.&lt;/p&gt;
     *
     * &lt;p&gt;The user does not need any additional software for this: it's all pure Java. As of April 2014 &lt;b&gt;this mode
     * is experimental&lt;/b&gt;.&lt;/p&gt;
     *
     * @throws TimeoutException if Tor fails to start within 20 seconds.
     */
    public static PeerGroup newWithTor(Context context, @Nullable AbstractBlockChain chain, TorClient torClient) throws TimeoutException {
<span class="nc" id="L334">        return newWithTor(context, chain, torClient, true);</span>
    }

    /**
     * &lt;p&gt;Creates a PeerGroup that accesses the network via the Tor network. The provided TorClient is used so you can
     * preconfigure it beforehand. It should not have been already started. You can just use &quot;new TorClient()&quot; if
     * you don't have any particular configuration requirements.&lt;/p&gt;
     *
     * &lt;p&gt;If running on the Oracle JDK the unlimited strength jurisdiction checks will also be overridden,
     * as they no longer apply anyway and can cause startup failures due to the requirement for AES-256.&lt;/p&gt;
     *
     * &lt;p&gt;The user does not need any additional software for this: it's all pure Java. As of April 2014 &lt;b&gt;this mode
     * is experimental&lt;/b&gt;.&lt;/p&gt;
     *
     * @param doDiscovery if true, DNS or HTTP peer discovery will be performed via Tor: this is almost always what you want.
     * @throws java.util.concurrent.TimeoutException if Tor fails to start within 20 seconds.
     */
    public static PeerGroup newWithTor(Context context, @Nullable AbstractBlockChain chain, TorClient torClient, boolean doDiscovery) throws TimeoutException {
<span class="nc" id="L352">        checkNotNull(torClient);</span>
<span class="nc" id="L353">        DRMWorkaround.maybeDisableExportControls();</span>
<span class="nc" id="L354">        BlockingClientManager manager = new BlockingClientManager(torClient.getSocketFactory());</span>
<span class="nc" id="L355">        final int CONNECT_TIMEOUT_MSEC = TOR_TIMEOUT_SECONDS * 1000;</span>
<span class="nc" id="L356">        manager.setConnectTimeoutMillis(CONNECT_TIMEOUT_MSEC);</span>
<span class="nc" id="L357">        PeerGroup result = new PeerGroup(context, chain, manager, torClient);</span>
<span class="nc" id="L358">        result.setConnectTimeoutMillis(CONNECT_TIMEOUT_MSEC);</span>

<span class="nc bnc" id="L360" title="All 2 branches missed.">        if (doDiscovery) {</span>
<span class="nc" id="L361">            NetworkParameters params = context.getParams();</span>
<span class="nc" id="L362">            HttpDiscovery.Details[] httpSeeds = params.getHttpSeeds();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">            if (httpSeeds.length &gt; 0) {</span>
                // Use HTTP discovery when Tor is active and there is a Cartographer seed, for a much needed speed boost.
<span class="nc" id="L365">                OkHttpClient httpClient = new OkHttpClient();</span>
<span class="nc" id="L366">                httpClient.setSocketFactory(torClient.getSocketFactory());</span>
<span class="nc" id="L367">                List&lt;PeerDiscovery&gt; discoveries = Lists.newArrayList();</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">                for (HttpDiscovery.Details httpSeed : httpSeeds)</span>
<span class="nc" id="L369">                    discoveries.add(new HttpDiscovery(params, httpSeed, httpClient));</span>
<span class="nc" id="L370">                result.addPeerDiscovery(new MultiplexingDiscovery(params, discoveries));</span>
<span class="nc" id="L371">            } else {</span>
<span class="nc" id="L372">                result.addPeerDiscovery(new TorDiscovery(params, torClient));</span>
            }
        }
<span class="nc" id="L375">        return result;</span>
    }

    /** See {@link #PeerGroup(Context, AbstractBlockChain, ClientConnectionManager)} */
    public PeerGroup(NetworkParameters params, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager) {
<span class="fc" id="L380">        this(Context.getOrCreate(params), chain, connectionManager, null);</span>
<span class="fc" id="L381">    }</span>

    /**
     * Creates a new PeerGroup allowing you to specify the {@link ClientConnectionManager} which is used to create new
     * connections and keep track of existing ones.
     */
    public PeerGroup(Context context, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager) {
<span class="nc" id="L388">        this(context, chain, connectionManager, null);</span>
<span class="nc" id="L389">    }</span>

    /**
     * Creates a new PeerGroup allowing you to specify the {@link ClientConnectionManager} which is used to create new
     * connections and keep track of existing ones.
     */
<span class="fc" id="L395">    private PeerGroup(Context context, @Nullable AbstractBlockChain chain, ClientConnectionManager connectionManager, @Nullable TorClient torClient) {</span>
<span class="fc" id="L396">        checkNotNull(context);</span>
<span class="fc" id="L397">        this.params = context.getParams();</span>
<span class="fc" id="L398">        this.chain = chain;</span>
<span class="fc" id="L399">        fastCatchupTimeSecs = params.getGenesisBlock().getTimeSeconds();</span>
<span class="fc" id="L400">        wallets = new CopyOnWriteArrayList&lt;Wallet&gt;();</span>
<span class="fc" id="L401">        peerFilterProviders = new CopyOnWriteArrayList&lt;PeerFilterProvider&gt;();</span>
<span class="fc" id="L402">        this.torClient = torClient;</span>

<span class="fc" id="L404">        executor = createPrivateExecutor();</span>

        // This default sentinel value will be overridden by one of two actions:
        //   - adding a peer discovery source sets it to the default
        //   - using connectTo() will increment it by one
<span class="fc" id="L409">        maxConnections = 0;</span>

<span class="pc bpc" id="L411" title="1 of 2 branches missed.">        int height = chain == null ? 0 : chain.getBestChainHeight();</span>
<span class="fc" id="L412">        versionMessage = new VersionMessage(params, height);</span>
        // We never request that the remote node wait for a bloom filter yet, as we have no wallets
<span class="fc" id="L414">        versionMessage.relayTxesBeforeFilter = true;</span>

<span class="fc" id="L416">        downloadTxDependencies = true;</span>

<span class="fc" id="L418">        inactives = new PriorityQueue&lt;PeerAddress&gt;(1, new Comparator&lt;PeerAddress&gt;() {</span>
            @SuppressWarnings(&quot;FieldAccessNotGuarded&quot;)   // only called when inactives is accessed, and lock is held then.
            @Override
            public int compare(PeerAddress a, PeerAddress b) {
<span class="fc" id="L422">                checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L423">                int result = backoffMap.get(a).compareTo(backoffMap.get(b));</span>
                // Sort by port if otherwise equals - for testing
<span class="fc bfc" id="L425" title="All 2 branches covered.">                if (result == 0)</span>
<span class="fc" id="L426">                    result = Ints.compare(a.getPort(), b.getPort());</span>
<span class="fc" id="L427">                return result;</span>
            }
        });
<span class="fc" id="L430">        backoffMap = new HashMap&lt;PeerAddress, ExponentialBackoff&gt;();</span>
<span class="fc" id="L431">        peers = new CopyOnWriteArrayList&lt;Peer&gt;();</span>
<span class="fc" id="L432">        pendingPeers = new CopyOnWriteArrayList&lt;Peer&gt;();</span>
<span class="fc" id="L433">        channels = connectionManager;</span>
<span class="fc" id="L434">        peerDiscoverers = new CopyOnWriteArraySet&lt;PeerDiscovery&gt;();</span>
<span class="fc" id="L435">        runningBroadcasts = Collections.synchronizedSet(new HashSet&lt;TransactionBroadcast&gt;());</span>
<span class="fc" id="L436">        bloomFilterMerger = new FilterMerger(DEFAULT_BLOOM_FILTER_FP_RATE);</span>
<span class="fc" id="L437">        vMinRequiredProtocolVersion = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.BLOOM_FILTER);</span>
<span class="fc" id="L438">    }</span>

<span class="fc" id="L440">    private CountDownLatch executorStartupLatch = new CountDownLatch(1);</span>

    protected ListeningScheduledExecutorService createPrivateExecutor() {
<span class="nc" id="L443">        ListeningScheduledExecutorService result = MoreExecutors.listeningDecorator(</span>
                new ScheduledThreadPoolExecutor(1, new ContextPropagatingThreadFactory(&quot;PeerGroup Thread&quot;))
        );
        // Hack: jam the executor so jobs just queue up until the user calls start() on us. For example, adding a wallet
        // results in a bloom filter recalc being queued, but we don't want to do that until we're actually started.
<span class="nc" id="L448">        result.execute(new Runnable() {</span>
            @Override
            public void run() {
<span class="nc" id="L451">                Uninterruptibles.awaitUninterruptibly(executorStartupLatch);</span>
<span class="nc" id="L452">            }</span>
        });
<span class="nc" id="L454">        return result;</span>
    }

    /**
     * This is how many milliseconds we wait for peer discoveries to return their results.
     */
    public void setPeerDiscoveryTimeoutMillis(long peerDiscoveryTimeoutMillis) {
<span class="nc" id="L461">        this.vPeerDiscoveryTimeoutMillis = peerDiscoveryTimeoutMillis;</span>
<span class="nc" id="L462">    }</span>

    /**
     * Adjusts the desired number of connections that we will create to peers. Note that if there are already peers
     * open and the new value is lower than the current number of peers, those connections will be terminated. Likewise
     * if there aren't enough current connections to meet the new requested max size, some will be added.
     */
    public void setMaxConnections(int maxConnections) {
        int adjustment;
<span class="fc" id="L471">        lock.lock();</span>
        try {
<span class="fc" id="L473">            this.maxConnections = maxConnections;</span>
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">            if (!isRunning()) return;</span>
        } finally {
<span class="pc" id="L476">            lock.unlock();</span>
<span class="nc" id="L477">        }</span>
        // We may now have too many or too few open connections. Add more or drop some to get to the right amount.
<span class="nc" id="L479">        adjustment = maxConnections - channels.getConnectedClientCount();</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">        if (adjustment &gt; 0)</span>
<span class="nc" id="L481">            triggerConnections();</span>

<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (adjustment &lt; 0)</span>
<span class="nc" id="L484">            channels.closeConnections(-adjustment);</span>
<span class="nc" id="L485">    }</span>

    /**
     * Switch for enabling download of pending transaction dependencies. A change of value only takes effect for newly
     * connected peers.
     */
    public void setDownloadTxDependencies(boolean downloadTxDependencies) {
<span class="nc" id="L492">        lock.lock();</span>
        try {
<span class="nc" id="L494">            this.downloadTxDependencies = downloadTxDependencies;</span>
        } finally {
<span class="nc" id="L496">            lock.unlock();</span>
<span class="nc" id="L497">        }</span>
<span class="nc" id="L498">    }</span>

<span class="fc" id="L500">    private Runnable triggerConnectionsJob = new Runnable() {</span>
<span class="fc" id="L501">        private boolean firstRun = true;</span>
        private final static long MIN_PEER_DISCOVERY_INTERVAL = 1000L;

        @Override
        public void run() {
            try {
<span class="fc" id="L507">                go();</span>
<span class="fc" id="L508">            } catch (Throwable e) {</span>
<span class="fc" id="L509">                log.error(&quot;Exception when trying to build connections&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L510">            }</span>
<span class="fc" id="L511">        }</span>

        public void go() {
<span class="fc bfc" id="L514" title="All 2 branches covered.">            if (!vRunning) return;</span>

<span class="fc" id="L516">            boolean doDiscovery = false;</span>
<span class="fc" id="L517">            long now = Utils.currentTimeMillis();</span>
<span class="fc" id="L518">            lock.lock();</span>
            try {
                // First run: try and use a local node if there is one, for the additional security it can provide.
                // But, not on Android as there are none for this platform: it could only be a malicious app trying
                // to hijack our traffic.
<span class="pc bpc" id="L523" title="3 of 8 branches missed.">                if (!Utils.isAndroidRuntime() &amp;&amp; useLocalhostPeerWhenPossible &amp;&amp; maybeCheckForLocalhostPeer() &amp;&amp; firstRun) {</span>
<span class="fc" id="L524">                    log.info(&quot;Localhost peer detected, trying to use it instead of P2P discovery&quot;);</span>
<span class="fc" id="L525">                    maxConnections = 0;</span>
<span class="fc" id="L526">                    connectToLocalHost();</span>
<span class="fc" id="L527">                    return;</span>
                }

<span class="pc bpc" id="L530" title="1 of 4 branches missed.">                boolean havePeerWeCanTry = !inactives.isEmpty() &amp;&amp; backoffMap.get(inactives.peek()).getRetryTime() &lt;= now;</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">                doDiscovery = !havePeerWeCanTry;</span>
            } finally {
<span class="pc" id="L533">                firstRun = false;</span>
<span class="pc" id="L534">                lock.unlock();</span>
<span class="fc" id="L535">            }</span>

            // Don't hold the lock across discovery as this process can be very slow.
<span class="fc" id="L538">            boolean discoverySuccess = false;</span>
<span class="pc bpc" id="L539" title="1 of 2 branches missed.">            if (doDiscovery) {</span>
                try {
<span class="fc bfc" id="L541" title="All 2 branches covered.">                    discoverySuccess = discoverPeers() &gt; 0;</span>
<span class="fc" id="L542">                } catch (PeerDiscoveryException e) {</span>
<span class="fc" id="L543">                    log.error(&quot;Peer discovery failure&quot;, e);</span>
<span class="fc" id="L544">                }</span>
            }

            long retryTime;
            PeerAddress addrToTry;
<span class="fc" id="L549">            lock.lock();</span>
            try {
<span class="pc bpc" id="L551" title="1 of 2 branches missed.">                if (doDiscovery) {</span>
                    // Require that we have enough connections, to consider this
                    // a success, or we just constantly test for new peers
<span class="pc bpc" id="L554" title="1 of 4 branches missed.">                    if (discoverySuccess &amp;&amp; countConnectedAndPendingPeers() &gt;= getMaxConnections()) {</span>
<span class="nc" id="L555">                        groupBackoff.trackSuccess();</span>
                    } else {
<span class="fc" id="L557">                        groupBackoff.trackFailure();</span>
                    }
                }
                // Inactives is sorted by backoffMap time.
<span class="fc bfc" id="L561" title="All 2 branches covered.">                if (inactives.isEmpty()) {</span>
<span class="fc bfc" id="L562" title="All 2 branches covered.">                    if (countConnectedAndPendingPeers() &lt; getMaxConnections()) {</span>
<span class="fc" id="L563">                        long interval = Math.max(groupBackoff.getRetryTime() - now, MIN_PEER_DISCOVERY_INTERVAL);</span>
<span class="fc" id="L564">                        log.info(&quot;Peer discovery didn't provide us any more peers, will try again in &quot;</span>
                            + interval + &quot;ms.&quot;);
<span class="fc" id="L566">                        executor.schedule(this, interval, TimeUnit.MILLISECONDS);</span>
                    } else {
                        // We have enough peers and discovery provided no more, so just settle down. Most likely we
                        // were given a fixed set of addresses in some test scenario.
                    }
<span class="fc" id="L571">                    return;</span>
                } else {
                    do {
<span class="fc" id="L574">                        addrToTry = inactives.poll();</span>
<span class="pc bpc" id="L575" title="3 of 4 branches missed.">                    } while (ipv6Unreachable &amp;&amp; addrToTry.getAddr() instanceof Inet6Address);</span>
<span class="fc" id="L576">                    retryTime = backoffMap.get(addrToTry).getRetryTime();</span>
                }
<span class="fc" id="L578">                retryTime = Math.max(retryTime, groupBackoff.getRetryTime());</span>
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">                if (retryTime &gt; now) {</span>
<span class="fc" id="L580">                    long delay = retryTime - now;</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">                    log.info(&quot;Waiting {} msec before next connect attempt {}&quot;, delay, addrToTry == null ? &quot;&quot; : &quot;to &quot; + addrToTry);</span>
<span class="fc" id="L582">                    inactives.add(addrToTry);</span>
<span class="fc" id="L583">                    executor.schedule(this, delay, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L584">                    return;</span>
                }
<span class="nc" id="L586">                connectTo(addrToTry, false, vConnectTimeoutMillis);</span>
            } finally {
<span class="pc" id="L588">                lock.unlock();</span>
<span class="nc" id="L589">            }</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">            if (countConnectedAndPendingPeers() &lt; getMaxConnections()) {</span>
<span class="nc" id="L591">                executor.execute(this);   // Try next peer immediately.</span>
            }
<span class="nc" id="L593">        }</span>
    };

    private void triggerConnections() {
        // Run on a background thread due to the need to potentially retry and back off in the background.
<span class="fc bfc" id="L598" title="All 2 branches covered.">        if (!executor.isShutdown())</span>
<span class="fc" id="L599">            executor.execute(triggerConnectionsJob);</span>
<span class="fc" id="L600">    }</span>

    /** The maximum number of connections that we will create to peers. */
    public int getMaxConnections() {
<span class="fc" id="L604">        lock.lock();</span>
        try {
<span class="fc" id="L606">            return maxConnections;</span>
        } finally {
<span class="pc" id="L608">            lock.unlock();</span>
        }
    }

    private List&lt;Message&gt; handleGetData(GetDataMessage m) {
        // Scans the wallets and memory pool for transactions in the getdata message and returns them.
        // Runs on peer threads.
<span class="nc" id="L615">        lock.lock();</span>
        try {
<span class="nc" id="L617">            LinkedList&lt;Message&gt; transactions = new LinkedList&lt;Message&gt;();</span>
<span class="nc" id="L618">            LinkedList&lt;InventoryItem&gt; items = new LinkedList&lt;InventoryItem&gt;(m.getItems());</span>
<span class="nc" id="L619">            Iterator&lt;InventoryItem&gt; it = items.iterator();</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L621">                InventoryItem item = it.next();</span>
                // Check the wallets.
<span class="nc bnc" id="L623" title="All 2 branches missed.">                for (Wallet w : wallets) {</span>
<span class="nc" id="L624">                    Transaction tx = w.getTransaction(item.hash);</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">                    if (tx == null) continue;</span>
<span class="nc" id="L626">                    transactions.add(tx);</span>
<span class="nc" id="L627">                    it.remove();</span>
<span class="nc" id="L628">                    break;</span>
                }
<span class="nc" id="L630">            }</span>
<span class="nc" id="L631">            return transactions;</span>
        } finally {
<span class="nc" id="L633">            lock.unlock();</span>
        }
    }

    /**
     * Sets the {@link VersionMessage} that will be announced on newly created connections. A version message is
     * primarily interesting because it lets you customize the &quot;subVer&quot; field which is used a bit like the User-Agent
     * field from HTTP. It means your client tells the other side what it is, see
     * &lt;a href=&quot;https://github.com/bitcoin/bips/blob/master/bip-0014.mediawiki&quot;&gt;BIP 14&lt;/a&gt;.
     *
     * The VersionMessage you provide is copied and the best chain height/time filled in for each new connection,
     * therefore you don't have to worry about setting that. The provided object is really more of a template.
     */
    public void setVersionMessage(VersionMessage ver) {
<span class="nc" id="L647">        lock.lock();</span>
        try {
<span class="nc" id="L649">            versionMessage = ver;</span>
        } finally {
<span class="nc" id="L651">            lock.unlock();</span>
<span class="nc" id="L652">        }</span>
<span class="nc" id="L653">    }</span>

    /**
     * Returns the version message provided by setVersionMessage or a default if none was given.
     */
    public VersionMessage getVersionMessage() {
<span class="fc" id="L659">        lock.lock();</span>
        try {
<span class="fc" id="L661">            return versionMessage;</span>
        } finally {
<span class="pc" id="L663">            lock.unlock();</span>
        }
    }

    /**
     * Sets information that identifies this software to remote nodes. This is a convenience wrapper for creating 
     * a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     * and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that. See the docs for
     * {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     */
    public void setUserAgent(String name, String version, @Nullable String comments) {
        //TODO Check that height is needed here (it wasnt, but it should be, no?)
<span class="nc bnc" id="L675" title="All 2 branches missed.">        int height = chain == null ? 0 : chain.getBestChainHeight();</span>
<span class="nc" id="L676">        VersionMessage ver = new VersionMessage(params, height);</span>
<span class="nc" id="L677">        ver.relayTxesBeforeFilter = false;</span>
<span class="nc" id="L678">        updateVersionMessageRelayTxesBeforeFilter(ver);</span>
<span class="nc" id="L679">        ver.appendToSubVer(name, version, comments);</span>
<span class="nc" id="L680">        setVersionMessage(ver);</span>
<span class="nc" id="L681">    }</span>
    
    // Updates the relayTxesBeforeFilter flag of ver
    private void updateVersionMessageRelayTxesBeforeFilter(VersionMessage ver) {
        // We will provide the remote node with a bloom filter (ie they shouldn't relay yet)
        // if chain == null || !chain.shouldVerifyTransactions() and a wallet is added and bloom filters are enabled
        // Note that the default here means that no tx invs will be received if no wallet is ever added
<span class="fc" id="L688">        lock.lock();</span>
        try {
<span class="pc bpc" id="L690" title="2 of 4 branches missed.">            boolean spvMode = chain != null &amp;&amp; !chain.shouldVerifyTransactions();</span>
<span class="pc bpc" id="L691" title="3 of 6 branches missed.">            boolean willSendFilter = spvMode &amp;&amp; peerFilterProviders.size() &gt; 0 &amp;&amp; vBloomFilteringEnabled;</span>
<span class="pc bpc" id="L692" title="1 of 2 branches missed.">            ver.relayTxesBeforeFilter = !willSendFilter;</span>
        } finally {
<span class="pc" id="L694">            lock.unlock();</span>
<span class="fc" id="L695">        }</span>
<span class="fc" id="L696">    }</span>

    /**
     * Sets information that identifies this software to remote nodes. This is a convenience wrapper for creating
     * a new {@link VersionMessage}, calling {@link VersionMessage#appendToSubVer(String, String, String)} on it,
     * and then calling {@link PeerGroup#setVersionMessage(VersionMessage)} on the result of that. See the docs for
     * {@link VersionMessage#appendToSubVer(String, String, String)} for information on what the fields should contain.
     */
    public void setUserAgent(String name, String version) {
<span class="nc" id="L705">        setUserAgent(name, version, null);</span>
<span class="nc" id="L706">    }</span>

    /** Use the more specific listener methods instead */
    @Deprecated @SuppressWarnings(&quot;deprecation&quot;)
    public void addEventListener(AbstractPeerEventListener listener, Executor executor) {
<span class="nc" id="L711">        addBlocksDownloadedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L712">        addChainDownloadStartedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L713">        addConnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L714">        addDisconnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L715">        addDiscoveredEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L716">        addGetDataEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L717">        addOnTransactionBroadcastListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L718">        addPreMessageReceivedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L719">    }</span>

    /** Use the more specific listener methods instead */
    @Deprecated @SuppressWarnings(&quot;deprecation&quot;)
    public void addEventListener(AbstractPeerEventListener listener) {
<span class="nc" id="L724">        addBlocksDownloadedEventListener(executor, listener);</span>
<span class="nc" id="L725">        addChainDownloadStartedEventListener(executor, listener);</span>
<span class="nc" id="L726">        addConnectedEventListener(executor, listener);</span>
<span class="nc" id="L727">        addDisconnectedEventListener(executor, listener);</span>
<span class="nc" id="L728">        addDiscoveredEventListener(executor, listener);</span>
<span class="nc" id="L729">        addGetDataEventListener(executor, listener);</span>
<span class="nc" id="L730">        addOnTransactionBroadcastListener(executor, listener);</span>
<span class="nc" id="L731">        addPreMessageReceivedEventListener(executor, listener);</span>
<span class="nc" id="L732">    }</span>

    /** See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)} */
    public void addBlocksDownloadedEventListener(BlocksDownloadedEventListener listener) {
<span class="nc" id="L736">        addBlocksDownloadedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L737">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * blocks are downloaded by the download peer.&lt;/p&gt;
     * @see Peer#addBlocksDownloadedEventListener(Executor, BlocksDownloadedEventListener)
     */
    public void addBlocksDownloadedEventListener(Executor executor, BlocksDownloadedEventListener listener) {
<span class="nc" id="L745">        peersBlocksDownloadedEventListeners.add(new ListenerRegistration&lt;BlocksDownloadedEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L747">            peer.addBlocksDownloadedEventListener(executor, listener);</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L749">            peer.addBlocksDownloadedEventListener(executor, listener);</span>
<span class="nc" id="L750">    }</span>

    /** See {@link Peer#addBlocksDownloadedEventListener(BlocksDownloadedEventListener)} */
    public void addChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener) {
<span class="nc" id="L754">        addChainDownloadStartedEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L755">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * chain download starts.&lt;/p&gt;
     */
    public void addChainDownloadStartedEventListener(Executor executor, ChainDownloadStartedEventListener listener) {
<span class="nc" id="L762">        peersChainDownloadStartedEventListeners.add(new ListenerRegistration&lt;ChainDownloadStartedEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L764">            peer.addChainDownloadStartedEventListener(executor, listener);</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L766">            peer.addChainDownloadStartedEventListener(executor, listener);</span>
<span class="nc" id="L767">    }</span>

    /** See {@link Peer#addConnectedEventListener(PeerConnectedEventListener)} */
    public void addConnectedEventListener(PeerConnectedEventListener listener) {
<span class="fc" id="L771">        addConnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L772">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * new peers are connected to.&lt;/p&gt;
     */
    public void addConnectedEventListener(Executor executor, PeerConnectedEventListener listener) {
<span class="fc" id="L779">        peerConnectedEventListeners.add(new ListenerRegistration&lt;PeerConnectedEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L781">            peer.addConnectedEventListener(executor, listener);</span>
<span class="pc bpc" id="L782" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L783">            peer.addConnectedEventListener(executor, listener);</span>
<span class="fc" id="L784">    }</span>

    /** See {@link Peer#addDisconnectedEventListener(PeerDisconnectedEventListener)} */
    public void addDisconnectedEventListener(PeerDisconnectedEventListener listener) {
<span class="fc" id="L788">        addDisconnectedEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L789">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when
     * peers are disconnected from.&lt;/p&gt;
     */
    public void addDisconnectedEventListener(Executor executor, PeerDisconnectedEventListener listener) {
<span class="fc" id="L796">        peerDisconnectedEventListeners.add(new ListenerRegistration&lt;PeerDisconnectedEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="pc bpc" id="L797" title="1 of 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L798">            peer.addDisconnectedEventListener(executor, listener);</span>
<span class="pc bpc" id="L799" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L800">            peer.addDisconnectedEventListener(executor, listener);</span>
<span class="fc" id="L801">    }</span>

    /** See {@link Peer#addDiscoveredEventListener(PeerDiscoveredEventListener)} */
    public void addDiscoveredEventListener(PeerDiscoveredEventListener listener) {
<span class="fc" id="L805">        addDiscoveredEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L806">    }</span>

    /**
     * &lt;p&gt;Adds a listener that will be notified on the given executor when new
     * peers are discovered.&lt;/p&gt;
     */
    public void addDiscoveredEventListener(Executor executor, PeerDiscoveredEventListener listener) {
<span class="fc" id="L813">        peerDiscoveredEventListeners.add(new ListenerRegistration&lt;PeerDiscoveredEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="fc" id="L814">    }</span>

    /** See {@link Peer#addGetDataEventListener(GetDataEventListener)} */
    public void addGetDataEventListener(GetDataEventListener listener) {
<span class="nc" id="L818">        addGetDataEventListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L819">    }</span>

    /** See {@link Peer#addGetDataEventListener(Executor, GetDataEventListener)} */
    public void addGetDataEventListener(final Executor executor, final GetDataEventListener listener) {
<span class="nc" id="L823">        peerGetDataEventListeners.add(new ListenerRegistration&lt;GetDataEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="nc bnc" id="L824" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L825">            peer.addGetDataEventListener(executor, listener);</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L827">            peer.addGetDataEventListener(executor, listener);</span>
<span class="nc" id="L828">    }</span>

    /** See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)} */
    public void addOnTransactionBroadcastListener(OnTransactionBroadcastListener listener) {
<span class="nc" id="L832">        addOnTransactionBroadcastListener(Threading.USER_THREAD, listener);</span>
<span class="nc" id="L833">    }</span>

    /** See {@link Peer#addOnTransactionBroadcastListener(OnTransactionBroadcastListener)} */
    public void addOnTransactionBroadcastListener(Executor executor, OnTransactionBroadcastListener listener) {
<span class="fc" id="L837">        peersTransactionBroadastEventListeners.add(new ListenerRegistration&lt;OnTransactionBroadcastListener&gt;(checkNotNull(listener), executor));</span>
<span class="pc bpc" id="L838" title="1 of 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L839">            peer.addOnTransactionBroadcastListener(executor, listener);</span>
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L841">            peer.addOnTransactionBroadcastListener(executor, listener);</span>
<span class="fc" id="L842">    }</span>

    /** See {@link Peer#addPreMessageReceivedEventListener(PreMessageReceivedEventListener)} */
    public void addPreMessageReceivedEventListener(PreMessageReceivedEventListener listener) {
<span class="fc" id="L846">        addPreMessageReceivedEventListener(Threading.USER_THREAD, listener);</span>
<span class="fc" id="L847">    }</span>

    /** See {@link Peer#addPreMessageReceivedEventListener(Executor, PreMessageReceivedEventListener)} */
    public void addPreMessageReceivedEventListener(Executor executor, PreMessageReceivedEventListener listener) {
<span class="fc" id="L851">        peersPreMessageReceivedEventListeners.add(new ListenerRegistration&lt;PreMessageReceivedEventListener&gt;(checkNotNull(listener), executor));</span>
<span class="fc bfc" id="L852" title="All 2 branches covered.">        for (Peer peer : getConnectedPeers())</span>
<span class="fc" id="L853">            peer.addPreMessageReceivedEventListener(executor, listener);</span>
<span class="pc bpc" id="L854" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L855">            peer.addPreMessageReceivedEventListener(executor, listener);</span>
<span class="fc" id="L856">    }</span>

    /** Use the more specific listener methods instead */
    @Deprecated @SuppressWarnings(&quot;deprecation&quot;)
    public void removeEventListener(AbstractPeerEventListener listener) {
<span class="nc" id="L861">        removeBlocksDownloadedEventListener(listener);</span>
<span class="nc" id="L862">        removeChainDownloadStartedEventListener(listener);</span>
<span class="nc" id="L863">        removeConnectedEventListener(listener);</span>
<span class="nc" id="L864">        removeDisconnectedEventListener(listener);</span>
<span class="nc" id="L865">        removeDiscoveredEventListener(listener);</span>
<span class="nc" id="L866">        removeGetDataEventListener(listener);</span>
<span class="nc" id="L867">        removeOnTransactionBroadcastListener(listener);</span>
<span class="nc" id="L868">        removePreMessageReceivedEventListener(listener);</span>
<span class="nc" id="L869">    }</span>

    public boolean removeBlocksDownloadedEventListener(BlocksDownloadedEventListener listener) {
<span class="nc" id="L872">        boolean result = ListenerRegistration.removeFromList(listener, peersBlocksDownloadedEventListeners);</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L874">            peer.removeBlocksDownloadedEventListener(listener);</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L876">            peer.removeBlocksDownloadedEventListener(listener);</span>
<span class="nc" id="L877">        return result;</span>
    }

    public boolean removeChainDownloadStartedEventListener(ChainDownloadStartedEventListener listener) {
<span class="nc" id="L881">        boolean result = ListenerRegistration.removeFromList(listener, peersChainDownloadStartedEventListeners);</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L883">            peer.removeChainDownloadStartedEventListener(listener);</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L885">            peer.removeChainDownloadStartedEventListener(listener);</span>
<span class="nc" id="L886">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeConnectedEventListener(PeerConnectedEventListener listener) {
<span class="fc" id="L891">        boolean result = ListenerRegistration.removeFromList(listener, peerConnectedEventListeners);</span>
<span class="fc bfc" id="L892" title="All 2 branches covered.">        for (Peer peer : getConnectedPeers())</span>
<span class="fc" id="L893">            peer.removeConnectedEventListener(listener);</span>
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L895">            peer.removeConnectedEventListener(listener);</span>
<span class="fc" id="L896">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeDisconnectedEventListener(PeerDisconnectedEventListener listener) {
<span class="fc" id="L901">        boolean result = ListenerRegistration.removeFromList(listener, peerDisconnectedEventListeners);</span>
<span class="pc bpc" id="L902" title="1 of 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L903">            peer.removeDisconnectedEventListener(listener);</span>
<span class="pc bpc" id="L904" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L905">            peer.removeDisconnectedEventListener(listener);</span>
<span class="fc" id="L906">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeDiscoveredEventListener(PeerDiscoveredEventListener listener) {
<span class="nc" id="L911">        boolean result = ListenerRegistration.removeFromList(listener, peerDiscoveredEventListeners);</span>
<span class="nc" id="L912">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeGetDataEventListener(GetDataEventListener listener) {
<span class="nc" id="L917">        boolean result = ListenerRegistration.removeFromList(listener, peerGetDataEventListeners);</span>
<span class="nc bnc" id="L918" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L919">            peer.removeGetDataEventListener(listener);</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L921">            peer.removeGetDataEventListener(listener);</span>
<span class="nc" id="L922">        return result;</span>
    }

    /** The given event listener will no longer be called with events. */
    public boolean removeOnTransactionBroadcastListener(OnTransactionBroadcastListener listener) {
<span class="nc" id="L927">        boolean result = ListenerRegistration.removeFromList(listener, peersTransactionBroadastEventListeners);</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">        for (Peer peer : getConnectedPeers())</span>
<span class="nc" id="L929">            peer.removeOnTransactionBroadcastListener(listener);</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L931">            peer.removeOnTransactionBroadcastListener(listener);</span>
<span class="nc" id="L932">        return result;</span>
    }

    public boolean removePreMessageReceivedEventListener(PreMessageReceivedEventListener listener) {
<span class="fc" id="L936">        boolean result = ListenerRegistration.removeFromList(listener, peersPreMessageReceivedEventListeners);</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">        for (Peer peer : getConnectedPeers())</span>
<span class="fc" id="L938">            peer.removePreMessageReceivedEventListener(listener);</span>
<span class="pc bpc" id="L939" title="1 of 2 branches missed.">        for (Peer peer : getPendingPeers())</span>
<span class="nc" id="L940">            peer.removePreMessageReceivedEventListener(listener);</span>
<span class="fc" id="L941">        return result;</span>
    }

    /**
     * Returns a newly allocated list containing the currently connected peers. If all you care about is the count,
     * use numConnectedPeers().
     */
    public List&lt;Peer&gt; getConnectedPeers() {
<span class="fc" id="L949">        lock.lock();</span>
        try {
<span class="fc" id="L951">            return new ArrayList&lt;Peer&gt;(peers);</span>
        } finally {
<span class="pc" id="L953">            lock.unlock();</span>
        }
    }

    /**
     * Returns a list containing Peers that did not complete connection yet.
     */
    public List&lt;Peer&gt; getPendingPeers() {
<span class="fc" id="L961">        lock.lock();</span>
        try {
<span class="fc" id="L963">            return new ArrayList&lt;Peer&gt;(pendingPeers);</span>
        } finally {
<span class="pc" id="L965">            lock.unlock();</span>
        }
    }

    /**
     * Add an address to the list of potential peers to connect to. It won't necessarily be used unless there's a need
     * to build new connections to reach the max connection count.
     *
     * @param peerAddress IP/port to use.
     */
    public void addAddress(PeerAddress peerAddress) {
        int newMax;
<span class="nc" id="L977">        lock.lock();</span>
        try {
<span class="nc" id="L979">            addInactive(peerAddress);</span>
<span class="nc" id="L980">            newMax = getMaxConnections() + 1;</span>
        } finally {
<span class="nc" id="L982">            lock.unlock();</span>
<span class="nc" id="L983">        }</span>
<span class="nc" id="L984">        setMaxConnections(newMax);</span>
<span class="nc" id="L985">    }</span>

    private void addInactive(PeerAddress peerAddress) {
<span class="fc" id="L988">        lock.lock();</span>
        try {
            // Deduplicate
<span class="pc bpc" id="L991" title="1 of 2 branches missed.">            if (backoffMap.containsKey(peerAddress))</span>
<span class="nc" id="L992">                return;</span>
<span class="fc" id="L993">            backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams));</span>
<span class="fc" id="L994">            inactives.offer(peerAddress);</span>
        } finally {
<span class="pc" id="L996">            lock.unlock();</span>
<span class="fc" id="L997">        }</span>
<span class="fc" id="L998">    }</span>

    /**
     * Convenience for connecting only to peers that can serve specific services. It will configure suitable peer
     * discoveries.
     * @param requiredServices Required services as a bitmask, e.g. {@link VersionMessage#NODE_NETWORK}.
     */
    public void setRequiredServices(long requiredServices) {
<span class="nc" id="L1006">        lock.lock();</span>
        try {
<span class="nc" id="L1008">            this.requiredServices = requiredServices;</span>
<span class="nc" id="L1009">            peerDiscoverers.clear();</span>
<span class="nc" id="L1010">            addPeerDiscovery(MultiplexingDiscovery.forServices(params, requiredServices));</span>
        } finally {
<span class="nc" id="L1012">            lock.unlock();</span>
<span class="nc" id="L1013">        }</span>
<span class="nc" id="L1014">    }</span>

    /** Convenience method for addAddress(new PeerAddress(address, params.port)); */
    public void addAddress(InetAddress address) {
<span class="nc" id="L1018">        addAddress(new PeerAddress(params, address, params.getPort()));</span>
<span class="nc" id="L1019">    }</span>

    /**
     * Add addresses from a discovery source to the list of potential peers to connect to. If max connections has not
     * been configured, or set to zero, then it's set to the default at this point.
     */
    public void addPeerDiscovery(PeerDiscovery peerDiscovery) {
<span class="fc" id="L1026">        lock.lock();</span>
        try {
<span class="fc bfc" id="L1028" title="All 2 branches covered.">            if (getMaxConnections() == 0)</span>
<span class="fc" id="L1029">                setMaxConnections(DEFAULT_CONNECTIONS);</span>
<span class="fc" id="L1030">            peerDiscoverers.add(peerDiscovery);</span>
        } finally {
<span class="pc" id="L1032">            lock.unlock();</span>
<span class="fc" id="L1033">        }</span>
<span class="fc" id="L1034">    }</span>

    /** Returns number of discovered peers. */
    protected int discoverPeers() throws PeerDiscoveryException {
        // Don't hold the lock whilst doing peer discovery: it can take a long time and cause high API latency.
<span class="pc bpc" id="L1039" title="1 of 2 branches missed.">        checkState(!lock.isHeldByCurrentThread());</span>
<span class="fc" id="L1040">        int maxPeersToDiscoverCount = this.vMaxPeersToDiscoverCount;</span>
<span class="fc" id="L1041">        long peerDiscoveryTimeoutMillis = this.vPeerDiscoveryTimeoutMillis;</span>
<span class="fc" id="L1042">        final Stopwatch watch = Stopwatch.createStarted();</span>
<span class="fc" id="L1043">        final List&lt;PeerAddress&gt; addressList = Lists.newLinkedList();</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">        for (PeerDiscovery peerDiscovery : peerDiscoverers /* COW */) {</span>
            InetSocketAddress[] addresses;
<span class="fc" id="L1046">            addresses = peerDiscovery.getPeers(requiredServices, peerDiscoveryTimeoutMillis, TimeUnit.MILLISECONDS);</span>
<span class="fc bfc" id="L1047" title="All 2 branches covered.">            for (InetSocketAddress address : addresses) addressList.add(new PeerAddress(params, address));</span>
<span class="fc bfc" id="L1048" title="All 2 branches covered.">            if (addressList.size() &gt;= maxPeersToDiscoverCount) break;</span>
<span class="fc" id="L1049">        }</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">        if (!addressList.isEmpty()) {</span>
<span class="fc bfc" id="L1051" title="All 2 branches covered.">            for (PeerAddress address : addressList) {</span>
<span class="fc" id="L1052">                addInactive(address);</span>
<span class="fc" id="L1053">            }</span>
<span class="fc" id="L1054">            final ImmutableSet&lt;PeerAddress&gt; peersDiscoveredSet = ImmutableSet.copyOf(addressList);</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">            for (final ListenerRegistration&lt;PeerDiscoveredEventListener&gt; registration : peerDiscoveredEventListeners /* COW */) {</span>
<span class="fc" id="L1056">                registration.executor.execute(new Runnable() {</span>
                    @Override
                    public void run() {
<span class="fc" id="L1059">                        registration.listener.onPeersDiscovered(peersDiscoveredSet);</span>
<span class="fc" id="L1060">                    }</span>
                });
<span class="fc" id="L1062">            }</span>
        }
<span class="fc" id="L1064">        watch.stop();</span>
<span class="fc" id="L1065">        log.info(&quot;Peer discovery took {} and returned {} items&quot;, watch, addressList.size());</span>
<span class="fc" id="L1066">        return addressList.size();</span>
    }

    @VisibleForTesting
    void waitForJobQueue() {
<span class="fc" id="L1071">        Futures.getUnchecked(executor.submit(Runnables.doNothing()));</span>
<span class="fc" id="L1072">    }</span>

    private int countConnectedAndPendingPeers() {
<span class="fc" id="L1075">        lock.lock();</span>
        try {
<span class="fc" id="L1077">            return peers.size() + pendingPeers.size();</span>
        } finally {
<span class="pc" id="L1079">            lock.unlock();</span>
        }
    }

<span class="pc" id="L1083">    private enum LocalhostCheckState {</span>
<span class="fc" id="L1084">        NOT_TRIED,</span>
<span class="fc" id="L1085">        FOUND,</span>
<span class="fc" id="L1086">        FOUND_AND_CONNECTED,</span>
<span class="fc" id="L1087">        NOT_THERE</span>
    }
<span class="fc" id="L1089">    private LocalhostCheckState localhostCheckState = LocalhostCheckState.NOT_TRIED;</span>

    private boolean maybeCheckForLocalhostPeer() {
<span class="fc" id="L1092">        checkState(lock.isHeldByCurrentThread());</span>
<span class="pc bpc" id="L1093" title="1 of 2 branches missed.">        if (localhostCheckState == LocalhostCheckState.NOT_TRIED) {</span>
            // Do a fast blocking connect to see if anything is listening.
<span class="fc" id="L1095">            Socket socket = null;</span>
            try {
<span class="fc" id="L1097">                socket = new Socket();</span>
<span class="fc" id="L1098">                socket.connect(new InetSocketAddress(InetAddresses.forString(&quot;127.0.0.1&quot;), params.getPort()), vConnectTimeoutMillis);</span>
<span class="fc" id="L1099">                localhostCheckState = LocalhostCheckState.FOUND;</span>
<span class="fc" id="L1100">                return true;</span>
<span class="nc" id="L1101">            } catch (IOException e) {</span>
<span class="nc" id="L1102">                log.info(&quot;Localhost peer not detected.&quot;);</span>
<span class="nc" id="L1103">                localhostCheckState = LocalhostCheckState.NOT_THERE;</span>
            } finally {
<span class="pc bpc" id="L1105" title="5 of 6 branches missed.">                if (socket != null) {</span>
                    try {
<span class="pc" id="L1107">                        socket.close();</span>
<span class="nc" id="L1108">                    } catch (IOException e) {</span>
                        // Ignore.
<span class="pc" id="L1110">                    }</span>
                }
            }
        }
<span class="nc" id="L1114">        return false;</span>
    }

    /**
     * Starts the PeerGroup and begins network activity.
     * @return A future that completes when first connection activity has been triggered (note: not first connection made).
     */
    public ListenableFuture startAsync() {
        // This is run in a background thread by the Service implementation.
<span class="pc bpc" id="L1123" title="1 of 2 branches missed.">        if (chain == null) {</span>
            // Just try to help catch what might be a programming error.
<span class="nc" id="L1125">            log.warn(&quot;Starting up with no attached block chain. Did you forget to pass one to the constructor?&quot;);</span>
        }
<span class="pc bpc" id="L1127" title="1 of 2 branches missed.">        checkState(!vUsedUp, &quot;Cannot start a peer group twice&quot;);</span>
<span class="fc" id="L1128">        vRunning = true;</span>
<span class="fc" id="L1129">        vUsedUp = true;</span>
<span class="fc" id="L1130">        executorStartupLatch.countDown();</span>
        // We do blocking waits during startup, so run on the executor thread.
<span class="fc" id="L1132">        return executor.submit(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L1136">                    log.info(&quot;Starting ...&quot;);</span>
<span class="pc bpc" id="L1137" title="1 of 2 branches missed.">                    if (torClient != null) {</span>
<span class="nc" id="L1138">                        log.info(&quot;Starting Tor/Orchid ...&quot;);</span>
<span class="nc" id="L1139">                        torClient.start();</span>
                        try {
<span class="nc" id="L1141">                            torClient.waitUntilReady(TOR_TIMEOUT_SECONDS * 1000);</span>
<span class="nc" id="L1142">                        } catch (Exception e) {</span>
<span class="nc" id="L1143">                            throw new RuntimeException(e);</span>
<span class="nc" id="L1144">                        }</span>
<span class="nc" id="L1145">                        log.info(&quot;Tor ready&quot;);</span>
                    }
<span class="fc" id="L1147">                    channels.startAsync();</span>
<span class="fc" id="L1148">                    channels.awaitRunning();</span>
<span class="fc" id="L1149">                    triggerConnections();</span>
<span class="fc" id="L1150">                    setupPinging();</span>
<span class="nc" id="L1151">                } catch (Throwable e) {</span>
<span class="nc" id="L1152">                    log.error(&quot;Exception when starting up&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L1153">                }</span>
<span class="fc" id="L1154">            }</span>
        });
    }

    /** Does a blocking startup. */
    public void start() {
<span class="fc" id="L1160">        Futures.getUnchecked(startAsync());</span>
<span class="fc" id="L1161">    }</span>

    /** Can just use start() for a blocking start here instead of startAsync/awaitRunning: PeerGroup is no longer a Guava service. */
    @Deprecated
    public void awaitRunning() {
<span class="nc" id="L1166">        waitForJobQueue();</span>
<span class="nc" id="L1167">    }</span>

    public ListenableFuture stopAsync() {
<span class="fc" id="L1170">        checkState(vRunning);</span>
<span class="fc" id="L1171">        vRunning = false;</span>
<span class="fc" id="L1172">        ListenableFuture future = executor.submit(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L1176">                    log.info(&quot;Stopping ...&quot;);</span>
                    // Blocking close of all sockets.
<span class="fc" id="L1178">                    channels.stopAsync();</span>
<span class="fc" id="L1179">                    channels.awaitTerminated();</span>
<span class="fc bfc" id="L1180" title="All 2 branches covered.">                    for (PeerDiscovery peerDiscovery : peerDiscoverers) {</span>
<span class="fc" id="L1181">                        peerDiscovery.shutdown();</span>
<span class="fc" id="L1182">                    }</span>
<span class="pc bpc" id="L1183" title="1 of 2 branches missed.">                    if (torClient != null) {</span>
<span class="nc" id="L1184">                        torClient.stop();</span>
                    }
<span class="fc" id="L1186">                    vRunning = false;</span>
<span class="fc" id="L1187">                    log.info(&quot;Stopped.&quot;);</span>
<span class="nc" id="L1188">                } catch (Throwable e) {</span>
<span class="nc" id="L1189">                    log.error(&quot;Exception when shutting down&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L1190">                }</span>
<span class="fc" id="L1191">            }</span>
        });
<span class="fc" id="L1193">        executor.shutdown();</span>
<span class="fc" id="L1194">        return future;</span>
    }

    /** Does a blocking stop */
    public void stop() {
        try {
<span class="fc" id="L1200">            stopAsync();</span>
<span class="fc" id="L1201">            log.info(&quot;Awaiting PeerGroup shutdown ...&quot;);</span>
<span class="fc" id="L1202">            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span>
<span class="nc" id="L1203">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1204">            throw new RuntimeException(e);</span>
<span class="fc" id="L1205">        }</span>
<span class="fc" id="L1206">    }</span>

    /** Can just use stop() here instead of stopAsync/awaitTerminated: PeerGroup is no longer a Guava service. */
    @Deprecated
    public void awaitTerminated() {
        try {
<span class="nc" id="L1212">            executor.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);</span>
<span class="nc" id="L1213">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1214">            throw new RuntimeException(e);</span>
<span class="nc" id="L1215">        }</span>
<span class="nc" id="L1216">    }</span>

    /**
     * &lt;p&gt;Link the given wallet to this PeerGroup. This is used for three purposes:&lt;/p&gt;
     *
     * &lt;ol&gt;
     *   &lt;li&gt;So the wallet receives broadcast transactions.&lt;/li&gt;
     *   &lt;li&gt;Announcing pending transactions that didn't get into the chain yet to our peers.&lt;/li&gt;
     *   &lt;li&gt;Set the fast catchup time using {@link PeerGroup#setFastCatchupTimeSecs(long)}, to optimize chain
     *       download.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;Note that this should be done before chain download commences because if you add a wallet with keys earlier
     * than the current chain head, the relevant parts of the chain won't be redownloaded for you.&lt;/p&gt;
     *
     * &lt;p&gt;The Wallet will have an event listener registered on it, so to avoid leaks remember to use
     * {@link PeerGroup#removeWallet(Wallet)} on it if you wish to keep the Wallet but lose the PeerGroup.&lt;/p&gt;
     */
    public void addWallet(Wallet wallet) {
<span class="fc" id="L1235">        lock.lock();</span>
        try {
<span class="fc" id="L1237">            checkNotNull(wallet);</span>
<span class="pc bpc" id="L1238" title="1 of 2 branches missed.">            checkState(!wallets.contains(wallet));</span>
<span class="fc" id="L1239">            wallets.add(wallet);</span>
<span class="fc" id="L1240">            wallet.setTransactionBroadcaster(this);</span>
<span class="fc" id="L1241">            wallet.addCoinsReceivedEventListener(Threading.SAME_THREAD, walletCoinsReceivedEventListener);</span>
<span class="fc" id="L1242">            wallet.addKeyChainEventListener(Threading.SAME_THREAD, walletKeyEventListener);</span>
<span class="fc" id="L1243">            wallet.addScriptChangeEventListener(Threading.SAME_THREAD, walletScriptEventListener);</span>
<span class="fc" id="L1244">            addPeerFilterProvider(wallet);</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">            for (Peer peer : peers) {</span>
<span class="fc" id="L1246">                peer.addWallet(wallet);</span>
<span class="fc" id="L1247">            }</span>
        } finally {
<span class="pc" id="L1249">            lock.unlock();</span>
<span class="fc" id="L1250">        }</span>
<span class="fc" id="L1251">    }</span>

    /**
     * &lt;p&gt;Link the given PeerFilterProvider to this PeerGroup. DO NOT use this for Wallets, use
     * {@link PeerGroup#addWallet(Wallet)} instead.&lt;/p&gt;
     *
     * &lt;p&gt;Note that this should be done before chain download commences because if you add a listener with keys earlier
     * than the current chain head, the relevant parts of the chain won't be redownloaded for you.&lt;/p&gt;
     *
     * &lt;p&gt;This method invokes {@link PeerGroup#recalculateFastCatchupAndFilter(FilterRecalculateMode)}.
     * The return value of this method is the &lt;code&gt;ListenableFuture&lt;/code&gt; returned by that invocation.&lt;/p&gt;
     *
     * @return a future that completes once each &lt;code&gt;Peer&lt;/code&gt; in this group has had its
     *         &lt;code&gt;BloomFilter&lt;/code&gt; (re)set.
     */
    public ListenableFuture&lt;BloomFilter&gt; addPeerFilterProvider(PeerFilterProvider provider) {
<span class="fc" id="L1267">        lock.lock();</span>
        try {
<span class="fc" id="L1269">            checkNotNull(provider);</span>
<span class="pc bpc" id="L1270" title="1 of 2 branches missed.">            checkState(!peerFilterProviders.contains(provider));</span>
            // Insert provider at the start. This avoids various concurrency problems that could occur because we need
            // all providers to be in a consistent, unchanging state whilst the filter is built. Providers can give
            // this guarantee by taking a lock in their begin method, but if we add to the end of the list here, it
            // means we establish a lock ordering a &gt; b &gt; c if that's the order the providers were added in. Given that
            // the main wallet will usually be first, this establishes an ordering wallet &gt; other-provider, which means
            // other-provider can then not call into the wallet itself. Other providers installed by the API user should
            // come first so the expected ordering is preserved. This can also manifest itself in providers that use
            // synchronous RPCs into an actor instead of locking, but the same issue applies.
<span class="fc" id="L1279">            peerFilterProviders.add(0, provider);</span>

            // Don't bother downloading block bodies before the oldest keys in all our wallets. Make sure we recalculate
            // if a key is added. Of course, by then we may have downloaded the chain already. Ideally adding keys would
            // automatically rewind the block chain and redownload the blocks to find transactions relevant to those keys,
            // all transparently and in the background. But we are a long way from that yet.
<span class="fc" id="L1285">            ListenableFuture&lt;BloomFilter&gt; future = recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
<span class="fc" id="L1286">            updateVersionMessageRelayTxesBeforeFilter(getVersionMessage());</span>
<span class="fc" id="L1287">            return future;</span>
        } finally {
<span class="pc" id="L1289">            lock.unlock();</span>
        }
    }

    /**
     * Opposite of {@link #addPeerFilterProvider(PeerFilterProvider)}. Again, don't use this for wallets. Does not
     * trigger recalculation of the filter.
     */
    public void removePeerFilterProvider(PeerFilterProvider provider) {
<span class="nc" id="L1298">        lock.lock();</span>
        try {
<span class="nc" id="L1300">            checkNotNull(provider);</span>
<span class="nc" id="L1301">            checkArgument(peerFilterProviders.remove(provider));</span>
        } finally {
<span class="nc" id="L1303">            lock.unlock();</span>
<span class="nc" id="L1304">        }</span>
<span class="nc" id="L1305">    }</span>

    /**
     * Unlinks the given wallet so it no longer receives broadcast transactions or has its transactions announced.
     */
    public void removeWallet(Wallet wallet) {
<span class="fc" id="L1311">        wallets.remove(checkNotNull(wallet));</span>
<span class="fc" id="L1312">        peerFilterProviders.remove(wallet);</span>
<span class="fc" id="L1313">        wallet.removeCoinsReceivedEventListener(walletCoinsReceivedEventListener);</span>
<span class="fc" id="L1314">        wallet.removeKeyChainEventListener(walletKeyEventListener);</span>
<span class="fc" id="L1315">        wallet.removeScriptChangeEventListener(walletScriptEventListener);</span>
<span class="fc" id="L1316">        wallet.setTransactionBroadcaster(null);</span>
<span class="fc bfc" id="L1317" title="All 2 branches covered.">        for (Peer peer : peers) {</span>
<span class="fc" id="L1318">            peer.removeWallet(wallet);</span>
<span class="fc" id="L1319">        }        </span>
<span class="fc" id="L1320">    }</span>

<span class="pc" id="L1322">    public enum FilterRecalculateMode {</span>
<span class="fc" id="L1323">        SEND_IF_CHANGED,</span>
<span class="fc" id="L1324">        FORCE_SEND_FOR_REFRESH,</span>
<span class="fc" id="L1325">        DONT_SEND,</span>
    }

<span class="fc" id="L1328">    private final Map&lt;FilterRecalculateMode, SettableFuture&lt;BloomFilter&gt;&gt; inFlightRecalculations = Maps.newHashMap();</span>

    /**
     * Recalculates the bloom filter given to peers as well as the timestamp after which full blocks are downloaded
     * (instead of only headers). Note that calls made one after another may return the same future, if the request
     * wasn't processed yet (i.e. calls are deduplicated).
     *
     * @param mode In what situations to send the filter to connected peers.
     * @return a future that completes once the filter has been calculated (note: this does not mean acknowledged by remote peers).
     */
    public ListenableFuture&lt;BloomFilter&gt; recalculateFastCatchupAndFilter(final FilterRecalculateMode mode) {
<span class="fc" id="L1339">        final SettableFuture&lt;BloomFilter&gt; future = SettableFuture.create();</span>
<span class="fc" id="L1340">        synchronized (inFlightRecalculations) {</span>
<span class="fc bfc" id="L1341" title="All 2 branches covered.">            if (inFlightRecalculations.get(mode) != null)</span>
<span class="fc" id="L1342">                return inFlightRecalculations.get(mode);</span>
<span class="fc" id="L1343">            inFlightRecalculations.put(mode, future);</span>
<span class="pc" id="L1344">        }</span>
<span class="fc" id="L1345">        Runnable command = new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="fc" id="L1349">                    go();</span>
<span class="nc" id="L1350">                } catch (Throwable e) {</span>
<span class="nc" id="L1351">                    log.error(&quot;Exception when trying to recalculate Bloom filter&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L1352">                }</span>
<span class="fc" id="L1353">            }</span>

            public void go() {
<span class="pc bpc" id="L1356" title="1 of 2 branches missed.">                checkState(!lock.isHeldByCurrentThread());</span>
                // Fully verifying mode doesn't use this optimization (it can't as it needs to see all transactions).
<span class="pc bpc" id="L1358" title="3 of 6 branches missed.">                if ((chain != null &amp;&amp; chain.shouldVerifyTransactions()) || !vBloomFilteringEnabled)</span>
<span class="nc" id="L1359">                    return;</span>
                // We only ever call bloomFilterMerger.calculate on jobQueue, so we cannot be calculating two filters at once.
<span class="fc" id="L1361">                FilterMerger.Result result = bloomFilterMerger.calculate(ImmutableList.copyOf(peerFilterProviders /* COW */));</span>
                boolean send;
<span class="pc bpc" id="L1363" title="2 of 4 branches missed.">                switch (mode) {</span>
                    case SEND_IF_CHANGED:
<span class="fc" id="L1365">                        send = result.changed;</span>
<span class="fc" id="L1366">                        break;</span>
                    case DONT_SEND:
<span class="fc" id="L1368">                        send = false;</span>
<span class="fc" id="L1369">                        break;</span>
                    case FORCE_SEND_FOR_REFRESH:
<span class="nc" id="L1371">                        send = true;</span>
<span class="nc" id="L1372">                        break;</span>
                    default:
<span class="nc" id="L1374">                        throw new UnsupportedOperationException();</span>
                }
<span class="fc bfc" id="L1376" title="All 2 branches covered.">                if (send) {</span>
<span class="fc bfc" id="L1377" title="All 2 branches covered.">                    for (Peer peer : peers /* COW */) {</span>
                        // Only query the mempool if this recalculation request is not in order to lower the observed FP
                        // rate. There's no point querying the mempool when doing this because the FP rate can only go
                        // down, and we will have seen all the relevant txns before: it's pointless to ask for them again.
<span class="pc bpc" id="L1381" title="1 of 2 branches missed.">                        peer.setBloomFilter(result.filter, mode != FilterRecalculateMode.FORCE_SEND_FOR_REFRESH);</span>
<span class="fc" id="L1382">                    }</span>
                    // Reset the false positive estimate so that we don't send a flood of filter updates
                    // if the estimate temporarily overshoots our threshold.
<span class="pc bpc" id="L1385" title="1 of 2 branches missed.">                    if (chain != null)</span>
<span class="fc" id="L1386">                        chain.resetFalsePositiveEstimate();</span>
                }
                // Do this last so that bloomFilter is already set when it gets called.
<span class="fc" id="L1389">                setFastCatchupTimeSecs(result.earliestKeyTimeSecs);</span>
<span class="fc" id="L1390">                synchronized (inFlightRecalculations) {</span>
<span class="fc" id="L1391">                    inFlightRecalculations.put(mode, null);</span>
<span class="pc" id="L1392">                }</span>
<span class="fc" id="L1393">                future.set(result.filter);</span>
<span class="fc" id="L1394">            }</span>
        };
        try {
<span class="fc" id="L1397">            executor.execute(command);</span>
<span class="nc" id="L1398">        } catch (RejectedExecutionException e) {</span>
            // Can happen during shutdown.
<span class="fc" id="L1400">        }</span>
<span class="fc" id="L1401">        return future;</span>
    }
    
    /**
     * &lt;p&gt;Sets the false positive rate of bloom filters given to peers. The default is {@link #DEFAULT_BLOOM_FILTER_FP_RATE}.&lt;/p&gt;
     *
     * &lt;p&gt;Be careful regenerating the bloom filter too often, as it decreases anonymity because remote nodes can
     * compare transactions against both the new and old filters to significantly decrease the false positive rate.&lt;/p&gt;
     * 
     * &lt;p&gt;See the docs for {@link BloomFilter#BloomFilter(int, double, long, BloomFilter.BloomUpdate)} for a brief
     * explanation of anonymity when using bloom filters.&lt;/p&gt;
     */
    public void setBloomFilterFalsePositiveRate(double bloomFilterFPRate) {
<span class="nc" id="L1414">        lock.lock();</span>
        try {
<span class="nc" id="L1416">            bloomFilterMerger.setBloomFilterFPRate(bloomFilterFPRate);</span>
<span class="nc" id="L1417">            recalculateFastCatchupAndFilter(FilterRecalculateMode.SEND_IF_CHANGED);</span>
        } finally {
<span class="nc" id="L1419">            lock.unlock();</span>
<span class="nc" id="L1420">        }</span>
<span class="nc" id="L1421">    }</span>

    /**
     * Returns the number of currently connected peers. To be informed when this count changes, register a 
     * {@link org.guldenj.core.listeners.PeerConnectionEventListener} and use the onPeerConnected/onPeerDisconnected methods.
     */
    public int numConnectedPeers() {
<span class="fc" id="L1428">        return peers.size();</span>
    }

    /**
     * Connect to a peer by creating a channel to the destination address.  This should not be
     * used normally - let the PeerGroup manage connections through {@link #start()}
     * 
     * @param address destination IP and port.
     * @return The newly created Peer object or null if the peer could not be connected.
     *         Use {@link org.guldenj.core.Peer#getConnectionOpenFuture()} if you
     *         want a future which completes when the connection is open.
     */
    @Nullable
    public Peer connectTo(InetSocketAddress address) {
<span class="fc" id="L1442">        lock.lock();</span>
        try {
<span class="fc" id="L1444">            PeerAddress peerAddress = new PeerAddress(params, address);</span>
<span class="fc" id="L1445">            backoffMap.put(peerAddress, new ExponentialBackoff(peerBackoffParams));</span>
<span class="fc" id="L1446">            return connectTo(peerAddress, true, vConnectTimeoutMillis);</span>
        } finally {
<span class="pc" id="L1448">            lock.unlock();</span>
        }
    }

    /**
     * Helper for forcing a connection to localhost. Useful when using regtest mode. Returns the peer object.
     */
    @Nullable
    public Peer connectToLocalHost() {
<span class="fc" id="L1457">        lock.lock();</span>
        try {
<span class="fc" id="L1459">            final PeerAddress localhost = PeerAddress.localhost(params);</span>
<span class="fc" id="L1460">            backoffMap.put(localhost, new ExponentialBackoff(peerBackoffParams));</span>
<span class="fc" id="L1461">            return connectTo(localhost, true, vConnectTimeoutMillis);</span>
        } finally {
<span class="pc" id="L1463">            lock.unlock();</span>
        }
    }

    /**
     * Creates a version message to send, constructs a Peer object and attempts to connect it. Returns the peer on
     * success or null on failure.
     * @param address Remote network address
     * @param incrementMaxConnections Whether to consider this connection an attempt to fill our quota, or something
     *                                explicitly requested.
     * @return Peer or null.
     */
    @Nullable @GuardedBy(&quot;lock&quot;)
    protected Peer connectTo(PeerAddress address, boolean incrementMaxConnections, int connectTimeoutMillis) {
<span class="fc" id="L1477">        checkState(lock.isHeldByCurrentThread());</span>
<span class="fc" id="L1478">        VersionMessage ver = getVersionMessage().duplicate();</span>
<span class="pc bpc" id="L1479" title="1 of 2 branches missed.">        ver.bestHeight = chain == null ? 0 : chain.getBestChainHeight();</span>
<span class="fc" id="L1480">        ver.time = Utils.currentTimeSeconds();</span>

<span class="fc" id="L1482">        Peer peer = createPeer(address, ver);</span>
<span class="fc" id="L1483">        peer.addConnectedEventListener(Threading.SAME_THREAD, startupListener);</span>
<span class="fc" id="L1484">        peer.addDisconnectedEventListener(Threading.SAME_THREAD, startupListener);</span>
<span class="fc" id="L1485">        peer.setMinProtocolVersion(vMinRequiredProtocolVersion);</span>
<span class="fc" id="L1486">        pendingPeers.add(peer);</span>

        try {
<span class="fc" id="L1489">            log.info(&quot;Attempting connection to {}     ({} connected, {} pending, {} max)&quot;, address,</span>
<span class="fc" id="L1490">                    peers.size(), pendingPeers.size(), maxConnections);</span>
<span class="fc" id="L1491">            ListenableFuture&lt;SocketAddress&gt; future = channels.openConnection(address.toSocketAddress(), peer);</span>
<span class="fc bfc" id="L1492" title="All 2 branches covered.">            if (future.isDone())</span>
<span class="fc" id="L1493">                Uninterruptibles.getUninterruptibly(future);</span>
<span class="nc" id="L1494">        } catch (ExecutionException e) {</span>
<span class="nc" id="L1495">            Throwable cause = Throwables.getRootCause(e);</span>
<span class="nc" id="L1496">            log.warn(&quot;Failed to connect to &quot; + address + &quot;: &quot; + cause.getMessage());</span>
<span class="nc" id="L1497">            handlePeerDeath(peer, cause);</span>
<span class="nc" id="L1498">            return null;</span>
<span class="fc" id="L1499">        }</span>
<span class="fc" id="L1500">        peer.setSocketTimeout(connectTimeoutMillis);</span>
        // When the channel has connected and version negotiated successfully, handleNewPeer will end up being called on
        // a worker thread.
<span class="pc bpc" id="L1503" title="1 of 2 branches missed.">        if (incrementMaxConnections) {</span>
            // We don't use setMaxConnections here as that would trigger a recursive attempt to establish a new
            // outbound connection.
<span class="fc" id="L1506">            maxConnections++;</span>
        }
<span class="fc" id="L1508">        return peer;</span>
    }

    /** You can override this to customise the creation of {@link Peer} objects. */
    @GuardedBy(&quot;lock&quot;)
    protected Peer createPeer(PeerAddress address, VersionMessage ver) {
<span class="fc" id="L1514">        return new Peer(params, ver, address, chain, downloadTxDependencies);</span>
    }

    /**
     * Sets the timeout between when a connection attempt to a peer begins and when the version message exchange
     * completes. This does not apply to currently pending peers.
     */
    public void setConnectTimeoutMillis(int connectTimeoutMillis) {
<span class="fc" id="L1522">        this.vConnectTimeoutMillis = connectTimeoutMillis;</span>
<span class="fc" id="L1523">    }</span>

    /**
     * &lt;p&gt;Start downloading the blockchain from the first available peer.&lt;/p&gt;
     *
     * &lt;p&gt;If no peers are currently connected, the download will be started once a peer starts.  If the peer dies,
     * the download will resume with another peer.&lt;/p&gt;
     *
     * @param listener a listener for chain download events, may not be null
     */
    public void startBlockChainDownload(PeerDataEventListener listener) {
<span class="fc" id="L1534">        lock.lock();</span>
        try {
<span class="pc bpc" id="L1536" title="1 of 2 branches missed.">            if (downloadPeer != null) {</span>
<span class="pc bpc" id="L1537" title="1 of 2 branches missed.">                if (this.downloadListener != null) {</span>
<span class="nc" id="L1538">                    removeDataEventListenerFromPeer(downloadPeer, this.downloadListener);</span>
                }
<span class="fc bfc" id="L1540" title="All 2 branches covered.">                if (listener != null) {</span>
<span class="fc" id="L1541">                    addDataEventListenerToPeer(Threading.USER_THREAD, downloadPeer, listener);</span>
                }
            }
<span class="fc" id="L1544">            this.downloadListener = listener;</span>
            // TODO: be more nuanced about which peer to download from.  We can also try
            // downloading from multiple peers and handle the case when a new peer comes along
            // with a longer chain after we thought we were done.
<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">            if (!peers.isEmpty()) {</span>
<span class="fc" id="L1549">                startBlockChainDownloadFromPeer(peers.iterator().next()); // Will add the new download listener</span>
            }
        } finally {
<span class="pc" id="L1552">            lock.unlock();</span>
<span class="fc" id="L1553">        }</span>
<span class="fc" id="L1554">    }</span>

    /**
     * Register a data event listener against a single peer (i.e. for blockchain
     * download). Handling registration/deregistration on peer death/add is
     * outside the scope of these methods.
     */
    private static void addDataEventListenerToPeer(Executor executor, Peer peer, PeerDataEventListener downloadListener) {
<span class="fc" id="L1562">        peer.addBlocksDownloadedEventListener(executor, downloadListener);</span>
<span class="fc" id="L1563">        peer.addChainDownloadStartedEventListener(executor, downloadListener);</span>
<span class="fc" id="L1564">        peer.addGetDataEventListener(executor, downloadListener);</span>
<span class="fc" id="L1565">        peer.addPreMessageReceivedEventListener(executor, downloadListener);</span>
<span class="fc" id="L1566">    }</span>

    /**
     * Remove a registered data event listener against a single peer (i.e. for
     * blockchain download). Handling registration/deregistration on peer death/add is
     * outside the scope of these methods.
     */
    private static void removeDataEventListenerFromPeer(Peer peer, PeerDataEventListener listener) {
<span class="fc" id="L1574">        peer.removeBlocksDownloadedEventListener(listener);</span>
<span class="fc" id="L1575">        peer.removeChainDownloadStartedEventListener(listener);</span>
<span class="fc" id="L1576">        peer.removeGetDataEventListener(listener);</span>
<span class="fc" id="L1577">        peer.removePreMessageReceivedEventListener(listener);</span>
<span class="fc" id="L1578">    }</span>

    /**
     * Download the blockchain from peers. Convenience that uses a {@link DownloadProgressTracker} for you.&lt;p&gt;
     * 
     * This method waits until the download is complete.  &quot;Complete&quot; is defined as downloading
     * from at least one peer all the blocks that are in that peer's inventory.
     */
    public void downloadBlockChain() {
<span class="nc" id="L1587">        DownloadProgressTracker listener = new DownloadProgressTracker();</span>
<span class="nc" id="L1588">        startBlockChainDownload(listener);</span>
        try {
<span class="nc" id="L1590">            listener.await();</span>
<span class="nc" id="L1591">        } catch (InterruptedException e) {</span>
<span class="nc" id="L1592">            throw new RuntimeException(e);</span>
<span class="nc" id="L1593">        }</span>
<span class="nc" id="L1594">    }</span>

    protected void handleNewPeer(final Peer peer) {
<span class="fc" id="L1597">        int newSize = -1;</span>
<span class="fc" id="L1598">        lock.lock();</span>
        try {
<span class="fc" id="L1600">            groupBackoff.trackSuccess();</span>
<span class="fc" id="L1601">            backoffMap.get(peer.getAddress()).trackSuccess();</span>

            // Sets up the newly connected peer so it can do everything it needs to.
<span class="fc" id="L1604">            pendingPeers.remove(peer);</span>
<span class="fc" id="L1605">            peers.add(peer);</span>
<span class="fc" id="L1606">            newSize = peers.size();</span>
<span class="fc" id="L1607">            log.info(&quot;{}: New peer      ({} connected, {} pending, {} max)&quot;, peer, newSize, pendingPeers.size(), maxConnections);</span>
            // Give the peer a filter that can be used to probabilistically drop transactions that
            // aren't relevant to our wallet. We may still receive some false positives, which is
            // OK because it helps improve wallet privacy. Old nodes will just ignore the message.
<span class="pc bpc" id="L1611" title="1 of 2 branches missed.">            if (bloomFilterMerger.getLastFilter() != null) peer.setBloomFilter(bloomFilterMerger.getLastFilter());</span>
<span class="fc" id="L1612">            peer.setDownloadData(false);</span>
            // TODO: The peer should calculate the fast catchup time from the added wallets here.
<span class="fc bfc" id="L1614" title="All 2 branches covered.">            for (Wallet wallet : wallets)</span>
<span class="fc" id="L1615">                peer.addWallet(wallet);</span>
<span class="fc bfc" id="L1616" title="All 2 branches covered.">            if (downloadPeer == null) {</span>
                // Kick off chain download if we aren't already doing it.
<span class="fc" id="L1618">                setDownloadPeer(selectDownloadPeer(peers));</span>
<span class="pc bpc" id="L1619" title="3 of 4 branches missed.">                boolean shouldDownloadChain = downloadListener != null &amp;&amp; chain != null;</span>
<span class="pc bpc" id="L1620" title="1 of 2 branches missed.">                if (shouldDownloadChain) {</span>
<span class="nc" id="L1621">                    startBlockChainDownloadFromPeer(downloadPeer);</span>
                }
            }
            // Make sure the peer knows how to upload transactions that are requested from us.
<span class="fc" id="L1625">            peer.addBlocksDownloadedEventListener(Threading.SAME_THREAD, peerListener);</span>
<span class="fc" id="L1626">            peer.addGetDataEventListener(Threading.SAME_THREAD, peerListener);</span>

            // And set up event listeners for clients. This will allow them to find out about new transactions and blocks.
<span class="pc bpc" id="L1629" title="1 of 2 branches missed.">            for (ListenerRegistration&lt;BlocksDownloadedEventListener&gt; registration : peersBlocksDownloadedEventListeners)</span>
<span class="nc" id="L1630">                peer.addBlocksDownloadedEventListener(registration.executor, registration.listener);</span>
<span class="pc bpc" id="L1631" title="1 of 2 branches missed.">            for (ListenerRegistration&lt;ChainDownloadStartedEventListener&gt; registration : peersChainDownloadStartedEventListeners)</span>
<span class="nc" id="L1632">                peer.addChainDownloadStartedEventListener(registration.executor, registration.listener);</span>
<span class="fc bfc" id="L1633" title="All 2 branches covered.">            for (ListenerRegistration&lt;PeerConnectedEventListener&gt; registration : peerConnectedEventListeners)</span>
<span class="fc" id="L1634">                peer.addConnectedEventListener(registration.executor, registration.listener);</span>
            // We intentionally do not add disconnect listeners to peers
<span class="pc bpc" id="L1636" title="1 of 2 branches missed.">            for (ListenerRegistration&lt;GetDataEventListener&gt; registration : peerGetDataEventListeners)</span>
<span class="nc" id="L1637">                peer.addGetDataEventListener(registration.executor, registration.listener);</span>
<span class="fc bfc" id="L1638" title="All 2 branches covered.">            for (ListenerRegistration&lt;OnTransactionBroadcastListener&gt; registration : peersTransactionBroadastEventListeners)</span>
<span class="fc" id="L1639">                peer.addOnTransactionBroadcastListener(registration.executor, registration.listener);</span>
<span class="fc bfc" id="L1640" title="All 2 branches covered.">            for (ListenerRegistration&lt;PreMessageReceivedEventListener&gt; registration : peersPreMessageReceivedEventListeners)</span>
<span class="fc" id="L1641">                peer.addPreMessageReceivedEventListener(registration.executor, registration.listener);</span>
        } finally {
<span class="pc" id="L1643">            lock.unlock();</span>
<span class="fc" id="L1644">        }</span>

<span class="fc" id="L1646">        final int fNewSize = newSize;</span>
<span class="fc bfc" id="L1647" title="All 2 branches covered.">        for (final ListenerRegistration&lt;PeerConnectedEventListener&gt; registration : peerConnectedEventListeners) {</span>
<span class="fc" id="L1648">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1651">                    registration.listener.onPeerConnected(peer, fNewSize);</span>
<span class="fc" id="L1652">                }</span>
            });
<span class="fc" id="L1654">        }</span>
<span class="fc" id="L1655">    }</span>

    @Nullable private volatile ListenableScheduledFuture&lt;?&gt; vPingTask;

    @SuppressWarnings(&quot;NonAtomicOperationOnVolatileField&quot;)
    private void setupPinging() {
<span class="fc bfc" id="L1661" title="All 2 branches covered.">        if (getPingIntervalMsec() &lt;= 0)</span>
<span class="fc" id="L1662">            return;  // Disabled.</span>

<span class="fc" id="L1664">        vPingTask = executor.scheduleAtFixedRate(new Runnable() {</span>
            @Override
            public void run() {
                try {
<span class="pc bpc" id="L1668" title="1 of 2 branches missed.">                    if (getPingIntervalMsec() &lt;= 0) {</span>
<span class="nc" id="L1669">                        ListenableScheduledFuture&lt;?&gt; task = vPingTask;</span>
<span class="nc bnc" id="L1670" title="All 2 branches missed.">                        if (task != null) {</span>
<span class="nc" id="L1671">                            task.cancel(false);</span>
<span class="nc" id="L1672">                            vPingTask = null;</span>
                        }
<span class="nc" id="L1674">                        return;  // Disabled.</span>
                    }
<span class="fc bfc" id="L1676" title="All 2 branches covered.">                    for (Peer peer : getConnectedPeers()) {</span>
<span class="pc bpc" id="L1677" title="1 of 2 branches missed.">                        if (peer.getPeerVersionMessage().clientVersion &lt; params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.PONG))</span>
<span class="nc" id="L1678">                            continue;</span>
<span class="fc" id="L1679">                        peer.ping();</span>
<span class="fc" id="L1680">                    }</span>
<span class="nc" id="L1681">                } catch (Throwable e) {</span>
<span class="nc" id="L1682">                    log.error(&quot;Exception in ping loop&quot;, e);  // The executor swallows exceptions :(</span>
<span class="fc" id="L1683">                }</span>
<span class="fc" id="L1684">            }</span>
<span class="fc" id="L1685">        }, getPingIntervalMsec(), getPingIntervalMsec(), TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L1686">    }</span>

    private void setDownloadPeer(@Nullable Peer peer) {
<span class="fc" id="L1689">        lock.lock();</span>
        try {
<span class="fc bfc" id="L1691" title="All 2 branches covered.">            if (downloadPeer == peer)</span>
<span class="fc" id="L1692">                return;</span>
<span class="fc bfc" id="L1693" title="All 2 branches covered.">            if (downloadPeer != null) {</span>
<span class="fc" id="L1694">                log.info(&quot;Unsetting download peer: {}&quot;, downloadPeer);</span>
<span class="fc bfc" id="L1695" title="All 2 branches covered.">                if (downloadListener != null) {</span>
<span class="fc" id="L1696">                    removeDataEventListenerFromPeer(downloadPeer, downloadListener);</span>
                }
<span class="fc" id="L1698">                downloadPeer.setDownloadData(false);</span>
            }
<span class="fc" id="L1700">            downloadPeer = peer;</span>
<span class="fc bfc" id="L1701" title="All 2 branches covered.">            if (downloadPeer != null) {</span>
<span class="fc" id="L1702">                log.info(&quot;Setting download peer: {}&quot;, downloadPeer);</span>
<span class="fc bfc" id="L1703" title="All 2 branches covered.">                if (downloadListener != null) {</span>
<span class="fc" id="L1704">                    addDataEventListenerToPeer(Threading.SAME_THREAD, peer, downloadListener);</span>
                }
<span class="fc" id="L1706">                downloadPeer.setDownloadData(true);</span>
<span class="pc bpc" id="L1707" title="1 of 2 branches missed.">                if (chain != null)</span>
<span class="pc bpc" id="L1708" title="1 of 2 branches missed.">                    downloadPeer.setDownloadParameters(fastCatchupTimeSecs, bloomFilterMerger.getLastFilter() != null);</span>
            }
        } finally {
<span class="pc" id="L1711">            lock.unlock();</span>
<span class="fc" id="L1712">        }</span>
<span class="fc" id="L1713">    }</span>

    /** Use &quot;Context.get().getConfidenceTable()&quot; instead */
    @Deprecated @Nullable
    public TxConfidenceTable getMemoryPool() {
<span class="nc" id="L1718">        return Context.get().getConfidenceTable();</span>
    }

    /**
     * Tells the PeerGroup to download only block headers before a certain time and bodies after that. Call this
     * before starting block chain download.
     * Do not use a time &gt; NOW - 1 block, as it will break some block download logic.
     */
    public void setFastCatchupTimeSecs(long secondsSinceEpoch) {
<span class="fc" id="L1727">        lock.lock();</span>
        try {
<span class="pc bpc" id="L1729" title="2 of 4 branches missed.">            checkState(chain == null || !chain.shouldVerifyTransactions(), &quot;Fast catchup is incompatible with fully verifying&quot;);</span>
<span class="fc" id="L1730">            fastCatchupTimeSecs = secondsSinceEpoch;</span>
<span class="fc bfc" id="L1731" title="All 2 branches covered.">            if (downloadPeer != null) {</span>
<span class="pc bpc" id="L1732" title="1 of 2 branches missed.">                downloadPeer.setDownloadParameters(secondsSinceEpoch, bloomFilterMerger.getLastFilter() != null);</span>
            }
        } finally {
<span class="pc" id="L1735">            lock.unlock();</span>
<span class="fc" id="L1736">        }</span>
<span class="fc" id="L1737">    }</span>

    /**
     * Returns the current fast catchup time. The contents of blocks before this time won't be downloaded as they
     * cannot contain any interesting transactions. If you use {@link PeerGroup#addWallet(Wallet)} this just returns
     * the min of the wallets earliest key times.
     * @return a time in seconds since the epoch
     */
    public long getFastCatchupTimeSecs() {
<span class="fc" id="L1746">        lock.lock();</span>
        try {
<span class="fc" id="L1748">            return fastCatchupTimeSecs;</span>
        } finally {
<span class="pc" id="L1750">            lock.unlock();</span>
        }
    }

    protected void handlePeerDeath(final Peer peer, @Nullable Throwable exception) {
        // Peer deaths can occur during startup if a connect attempt after peer discovery aborts immediately.
<span class="fc bfc" id="L1756" title="All 2 branches covered.">        if (!isRunning()) return;</span>

        int numPeers;
<span class="fc" id="L1759">        int numConnectedPeers = 0;</span>
<span class="fc" id="L1760">        lock.lock();</span>
        try {
<span class="fc" id="L1762">            pendingPeers.remove(peer);</span>
<span class="fc" id="L1763">            peers.remove(peer);</span>

<span class="fc" id="L1765">            PeerAddress address = peer.getAddress();</span>

<span class="fc" id="L1767">            log.info(&quot;{}: Peer died      ({} connected, {} pending, {} max)&quot;, address, peers.size(), pendingPeers.size(), maxConnections);</span>
<span class="fc bfc" id="L1768" title="All 2 branches covered.">            if (peer == downloadPeer) {</span>
<span class="fc" id="L1769">                log.info(&quot;Download peer died. Picking a new one.&quot;);</span>
<span class="fc" id="L1770">                setDownloadPeer(null);</span>
                // Pick a new one and possibly tell it to download the chain.
<span class="fc" id="L1772">                final Peer newDownloadPeer = selectDownloadPeer(peers);</span>
<span class="fc bfc" id="L1773" title="All 2 branches covered.">                if (newDownloadPeer != null) {</span>
<span class="fc" id="L1774">                    setDownloadPeer(newDownloadPeer);</span>
<span class="fc bfc" id="L1775" title="All 2 branches covered.">                    if (downloadListener != null) {</span>
<span class="fc" id="L1776">                        startBlockChainDownloadFromPeer(newDownloadPeer);</span>
                    }
                }
            }
<span class="fc" id="L1780">            numPeers = peers.size() + pendingPeers.size();</span>
<span class="fc" id="L1781">            numConnectedPeers = peers.size();</span>

<span class="fc" id="L1783">            groupBackoff.trackFailure();</span>

<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">            if (exception instanceof NoRouteToHostException) {</span>
<span class="nc bnc" id="L1786" title="All 4 branches missed.">                if (address.getAddr() instanceof Inet6Address &amp;&amp; !ipv6Unreachable) {</span>
<span class="nc" id="L1787">                    ipv6Unreachable = true;</span>
<span class="nc" id="L1788">                    log.warn(&quot;IPv6 peer connect failed due to routing failure, ignoring IPv6 addresses from now on&quot;);</span>
                }
            } else {
<span class="fc" id="L1791">                backoffMap.get(address).trackFailure();</span>
                // Put back on inactive list
<span class="fc" id="L1793">                inactives.offer(address);</span>
            }

<span class="pc bpc" id="L1796" title="1 of 2 branches missed.">            if (numPeers &lt; getMaxConnections()) {</span>
<span class="fc" id="L1797">                triggerConnections();</span>
            }
        } finally {
<span class="fc" id="L1800">            lock.unlock();</span>
<span class="fc" id="L1801">        }</span>

<span class="fc" id="L1803">        peer.removeBlocksDownloadedEventListener(peerListener);</span>
<span class="fc" id="L1804">        peer.removeGetDataEventListener(peerListener);</span>
<span class="fc bfc" id="L1805" title="All 2 branches covered.">        for (Wallet wallet : wallets) {</span>
<span class="fc" id="L1806">            peer.removeWallet(wallet);</span>
<span class="fc" id="L1807">        }</span>

<span class="fc" id="L1809">        final int fNumConnectedPeers = numConnectedPeers;</span>

<span class="pc bpc" id="L1811" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;BlocksDownloadedEventListener&gt; registration: peersBlocksDownloadedEventListeners)</span>
<span class="nc" id="L1812">            peer.removeBlocksDownloadedEventListener(registration.listener);</span>
<span class="pc bpc" id="L1813" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;ChainDownloadStartedEventListener&gt; registration: peersChainDownloadStartedEventListeners)</span>
<span class="nc" id="L1814">            peer.removeChainDownloadStartedEventListener(registration.listener);</span>
<span class="pc bpc" id="L1815" title="1 of 2 branches missed.">        for (ListenerRegistration&lt;GetDataEventListener&gt; registration: peerGetDataEventListeners)</span>
<span class="nc" id="L1816">            peer.removeGetDataEventListener(registration.listener);</span>
<span class="fc bfc" id="L1817" title="All 2 branches covered.">        for (ListenerRegistration&lt;PreMessageReceivedEventListener&gt; registration: peersPreMessageReceivedEventListeners)</span>
<span class="fc" id="L1818">            peer.removePreMessageReceivedEventListener(registration.listener);</span>
<span class="fc bfc" id="L1819" title="All 2 branches covered.">        for (ListenerRegistration&lt;OnTransactionBroadcastListener&gt; registration : peersTransactionBroadastEventListeners)</span>
<span class="fc" id="L1820">            peer.removeOnTransactionBroadcastListener(registration.listener);</span>
<span class="fc bfc" id="L1821" title="All 2 branches covered.">        for (final ListenerRegistration&lt;PeerDisconnectedEventListener&gt; registration : peerDisconnectedEventListeners) {</span>
<span class="fc" id="L1822">            registration.executor.execute(new Runnable() {</span>
                @Override
                public void run() {
<span class="fc" id="L1825">                    registration.listener.onPeerDisconnected(peer, fNumConnectedPeers);</span>
<span class="fc" id="L1826">                }</span>
            });
<span class="fc" id="L1828">            peer.removeDisconnectedEventListener(registration.listener);</span>
<span class="fc" id="L1829">        }</span>
<span class="fc" id="L1830">    }</span>

<span class="fc" id="L1832">    @GuardedBy(&quot;lock&quot;) private int stallPeriodSeconds = 10;</span>
<span class="fc" id="L1833">    @GuardedBy(&quot;lock&quot;) private int stallMinSpeedBytesSec = Block.HEADER_SIZE * 20;</span>

    /**
     * Configures the stall speed: the speed at which a peer is considered to be serving us the block chain
     * unacceptably slowly. Once a peer has served us data slower than the given data rate for the given
     * number of seconds, it is considered stalled and will be disconnected, forcing the chain download to continue
     * from a different peer. The defaults are chosen conservatively, but if you are running on a platform that is
     * CPU constrained or on a very slow network e.g. EDGE, the default settings may need adjustment to
     * avoid false stalls.
     *
     * @param periodSecs How many seconds the download speed must be below blocksPerSec, defaults to 10.
     * @param bytesPerSecond Download speed (only blocks/txns count) must be consistently below this for a stall, defaults to the bandwidth required for 20 block headers per second.
     */
    public void setStallThreshold(int periodSecs, int bytesPerSecond) {
<span class="nc" id="L1847">        lock.lock();</span>
        try {
<span class="nc" id="L1849">            stallPeriodSeconds = periodSecs;</span>
<span class="nc" id="L1850">            stallMinSpeedBytesSec = bytesPerSecond;</span>
        } finally {
<span class="nc" id="L1852">            lock.unlock();</span>
<span class="nc" id="L1853">        }</span>
<span class="nc" id="L1854">    }</span>

<span class="fc" id="L1856">    private class ChainDownloadSpeedCalculator implements BlocksDownloadedEventListener, Runnable {</span>
        private int blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond;
        private long bytesInLastSecond;

        // If we take more stalls than this, we assume we're on some kind of terminally slow network and the
        // stall threshold just isn't set properly. We give up on stall disconnects after that.
<span class="fc" id="L1862">        private int maxStalls = 3;</span>

        // How many seconds the peer has until we start measuring its speed.
<span class="fc" id="L1865">        private int warmupSeconds = -1;</span>

        // Used to calculate a moving average.
        private long[] samples;
        private int cursor;

        private boolean syncDone;

        @Override
        public synchronized void onBlocksDownloaded(Peer peer, Block block, @Nullable FilteredBlock filteredBlock, int blocksLeft) {
<span class="fc" id="L1875">            blocksInLastSecond++;</span>
<span class="fc" id="L1876">            bytesInLastSecond += Block.HEADER_SIZE;</span>
<span class="fc" id="L1877">            List&lt;Transaction&gt; blockTransactions = block.getTransactions();</span>
            // This whole area of the type hierarchy is a mess.
<span class="fc bfc" id="L1879" title="All 4 branches covered.">            int txCount = (blockTransactions != null ? countAndMeasureSize(blockTransactions) : 0) +</span>
<span class="fc" id="L1880">                          (filteredBlock != null ? countAndMeasureSize(filteredBlock.getAssociatedTransactions().values()) : 0);</span>
<span class="fc" id="L1881">            txnsInLastSecond = txnsInLastSecond + txCount;</span>
<span class="fc bfc" id="L1882" title="All 2 branches covered.">            if (filteredBlock != null)</span>
<span class="fc" id="L1883">                origTxnsInLastSecond += filteredBlock.getTransactionCount();</span>
<span class="fc" id="L1884">        }</span>

        private int countAndMeasureSize(Collection&lt;Transaction&gt; transactions) {
<span class="fc bfc" id="L1887" title="All 2 branches covered.">            for (Transaction transaction : transactions)</span>
<span class="fc" id="L1888">                bytesInLastSecond += transaction.getMessageSize();</span>
<span class="fc" id="L1889">            return transactions.size();</span>
        }

        @Override
        public void run() {
            try {
<span class="nc" id="L1895">                calculate();</span>
<span class="nc" id="L1896">            } catch (Throwable e) {</span>
<span class="nc" id="L1897">                log.error(&quot;Error in speed calculator&quot;, e);</span>
<span class="nc" id="L1898">            }</span>
<span class="nc" id="L1899">        }</span>

        private void calculate() {
            int minSpeedBytesPerSec;
            int period;

<span class="nc" id="L1905">            lock.lock();</span>
            try {
<span class="nc" id="L1907">                minSpeedBytesPerSec = stallMinSpeedBytesSec;</span>
<span class="nc" id="L1908">                period = stallPeriodSeconds;</span>
            } finally {
<span class="nc" id="L1910">                lock.unlock();</span>
<span class="nc" id="L1911">            }</span>

<span class="nc" id="L1913">            synchronized (this) {</span>
<span class="nc bnc" id="L1914" title="All 4 branches missed.">                if (samples == null || samples.length != period) {</span>
<span class="nc" id="L1915">                    samples = new long[period];</span>
                    // *2 because otherwise a single low sample could cause an immediate disconnect which is too harsh.
<span class="nc" id="L1917">                    Arrays.fill(samples, minSpeedBytesPerSec * 2);</span>
<span class="nc" id="L1918">                    warmupSeconds = 15;</span>
                }

<span class="nc bnc" id="L1921" title="All 4 branches missed.">                boolean behindPeers = chain != null &amp;&amp; chain.getBestChainHeight() &lt; getMostCommonChainHeight();</span>
<span class="nc bnc" id="L1922" title="All 2 branches missed.">                if (!behindPeers)</span>
<span class="nc" id="L1923">                    syncDone = true;</span>
<span class="nc bnc" id="L1924" title="All 2 branches missed.">                if (!syncDone) {</span>
<span class="nc bnc" id="L1925" title="All 2 branches missed.">                    if (warmupSeconds &lt; 0) {</span>
                        // Calculate the moving average.
<span class="nc" id="L1927">                        samples[cursor++] = bytesInLastSecond;</span>
<span class="nc bnc" id="L1928" title="All 2 branches missed.">                        if (cursor == samples.length) cursor = 0;</span>
<span class="nc" id="L1929">                        long average = 0;</span>
<span class="nc bnc" id="L1930" title="All 2 branches missed.">                        for (long sample : samples) average += sample;</span>
<span class="nc" id="L1931">                        average /= samples.length;</span>

<span class="nc" id="L1933">                        log.info(String.format(Locale.US, &quot;%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, avg/last %.2f/%.2f kilobytes per sec (stall threshold &lt;%.2f KB/sec for %d seconds)&quot;,</span>
<span class="nc" id="L1934">                                blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, average / 1024.0, bytesInLastSecond / 1024.0,</span>
<span class="nc" id="L1935">                                minSpeedBytesPerSec / 1024.0, samples.length));</span>

<span class="nc bnc" id="L1937" title="All 4 branches missed.">                        if (average &lt; minSpeedBytesPerSec &amp;&amp; maxStalls &gt; 0) {</span>
<span class="nc" id="L1938">                            maxStalls--;</span>
<span class="nc bnc" id="L1939" title="All 2 branches missed.">                            if (maxStalls == 0) {</span>
                                // We could consider starting to drop the Bloom filtering FP rate at this point, because
                                // we tried a bunch of peers and no matter what we don't seem to be able to go any faster.
                                // This implies we're bandwidth bottlenecked and might want to start using bandwidth
                                // more effectively. Of course if there's a MITM that is deliberately throttling us,
                                // this is a good way to make us take away all the FPs from our Bloom filters ... but
                                // as they don't give us a whole lot of privacy either way that's not inherently a big
                                // deal.
<span class="nc" id="L1947">                                log.warn(&quot;This network seems to be slower than the requested stall threshold - won't do stall disconnects any more.&quot;);</span>
                            } else {
<span class="nc" id="L1949">                                Peer peer = getDownloadPeer();</span>
<span class="nc" id="L1950">                                log.warn(String.format(Locale.US, &quot;Chain download stalled: received %.2f KB/sec for %d seconds, require average of %.2f KB/sec, disconnecting %s&quot;, average / 1024.0, samples.length, minSpeedBytesPerSec / 1024.0, peer));</span>
<span class="nc" id="L1951">                                peer.close();</span>
                                // Reset the sample buffer and give the next peer time to get going.
<span class="nc" id="L1953">                                samples = null;</span>
<span class="nc" id="L1954">                                warmupSeconds = period;</span>
                            }
                        }
<span class="nc" id="L1957">                    } else {</span>
<span class="nc" id="L1958">                        warmupSeconds--;</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">                        if (bytesInLastSecond &gt; 0)</span>
<span class="nc" id="L1960">                            log.info(String.format(Locale.US, &quot;%d blocks/sec, %d tx/sec, %d pre-filtered tx/sec, last %.2f kilobytes per sec&quot;,</span>
<span class="nc" id="L1961">                                    blocksInLastSecond, txnsInLastSecond, origTxnsInLastSecond, bytesInLastSecond / 1024.0));</span>
                    }
                }
<span class="nc" id="L1964">                blocksInLastSecond = 0;</span>
<span class="nc" id="L1965">                txnsInLastSecond = 0;</span>
<span class="nc" id="L1966">                origTxnsInLastSecond = 0;</span>
<span class="nc" id="L1967">                bytesInLastSecond = 0;</span>
<span class="nc" id="L1968">            }</span>
<span class="nc" id="L1969">        }</span>
    }
    @Nullable private ChainDownloadSpeedCalculator chainDownloadSpeedCalculator;

    private void startBlockChainDownloadFromPeer(Peer peer) {
<span class="fc" id="L1974">        lock.lock();</span>
        try {
<span class="fc" id="L1976">            setDownloadPeer(peer);</span>

<span class="fc bfc" id="L1978" title="All 2 branches covered.">            if (chainDownloadSpeedCalculator == null) {</span>
                // Every second, run the calculator which will log how fast we are downloading the chain.
<span class="fc" id="L1980">                chainDownloadSpeedCalculator = new ChainDownloadSpeedCalculator();</span>
<span class="fc" id="L1981">                executor.scheduleAtFixedRate(chainDownloadSpeedCalculator, 1, 1, TimeUnit.SECONDS);</span>
            }
<span class="fc" id="L1983">            peer.addBlocksDownloadedEventListener(Threading.SAME_THREAD, chainDownloadSpeedCalculator);</span>

            // startBlockChainDownload will setDownloadData(true) on itself automatically.
<span class="fc" id="L1986">            peer.startBlockChainDownload();</span>
        } finally {
<span class="pc" id="L1988">            lock.unlock();</span>
<span class="fc" id="L1989">        }</span>
<span class="fc" id="L1990">    }</span>

    /**
     * Returns a future that is triggered when the number of connected peers is equal to the given number of
     * peers. By using this with {@link org.guldenj.core.PeerGroup#getMaxConnections()} you can wait until the
     * network is fully online. To block immediately, just call get() on the result. Just calls
     * {@link #waitForPeersOfVersion(int, long)} with zero as the protocol version.
     *
     * @param numPeers How many peers to wait for.
     * @return a future that will be triggered when the number of connected peers &gt;= numPeers
     */
    public ListenableFuture&lt;List&lt;Peer&gt;&gt; waitForPeers(final int numPeers) {
<span class="fc" id="L2002">        return waitForPeersOfVersion(numPeers, 0);</span>
    }

    /**
     * Returns a future that is triggered when there are at least the requested number of connected peers that support
     * the given protocol version or higher. To block immediately, just call get() on the result.
     *
     * @param numPeers How many peers to wait for.
     * @param protocolVersion The protocol version the awaited peers must implement (or better).
     * @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher &gt;= numPeers
     */
    public ListenableFuture&lt;List&lt;Peer&gt;&gt; waitForPeersOfVersion(final int numPeers, final long protocolVersion) {
<span class="fc" id="L2014">        List&lt;Peer&gt; foundPeers = findPeersOfAtLeastVersion(protocolVersion);</span>
<span class="fc bfc" id="L2015" title="All 2 branches covered.">        if (foundPeers.size() &gt;= numPeers) {</span>
<span class="fc" id="L2016">            return Futures.immediateFuture(foundPeers);</span>
        }
<span class="fc" id="L2018">        final SettableFuture&lt;List&lt;Peer&gt;&gt; future = SettableFuture.create();</span>
<span class="fc" id="L2019">        addConnectedEventListener(new PeerConnectedEventListener() {</span>
            @Override
            public void onPeerConnected(Peer peer, int peerCount) {
<span class="fc" id="L2022">                final List&lt;Peer&gt; peers = findPeersOfAtLeastVersion(protocolVersion);</span>
<span class="fc bfc" id="L2023" title="All 2 branches covered.">                if (peers.size() &gt;= numPeers) {</span>
<span class="fc" id="L2024">                    future.set(peers);</span>
<span class="fc" id="L2025">                    removeConnectedEventListener(this);</span>
                }
<span class="fc" id="L2027">            }</span>
        });
<span class="fc" id="L2029">        return future;</span>
    }

    /**
     * Returns an array list of peers that implement the given protocol version or better.
     */
    public List&lt;Peer&gt; findPeersOfAtLeastVersion(long protocolVersion) {
<span class="fc" id="L2036">        lock.lock();</span>
        try {
<span class="fc" id="L2038">            ArrayList&lt;Peer&gt; results = new ArrayList&lt;Peer&gt;(peers.size());</span>
<span class="fc bfc" id="L2039" title="All 2 branches covered.">            for (Peer peer : peers)</span>
<span class="fc bfc" id="L2040" title="All 2 branches covered.">                if (peer.getPeerVersionMessage().clientVersion &gt;= protocolVersion)</span>
<span class="fc" id="L2041">                    results.add(peer);</span>
<span class="fc" id="L2042">            return results;</span>
        } finally {
<span class="pc" id="L2044">            lock.unlock();</span>
        }
    }

    /**
     * Returns a future that is triggered when there are at least the requested number of connected peers that support
     * the given protocol version or higher. To block immediately, just call get() on the result.
     *
     * @param numPeers How many peers to wait for.
     * @param mask An integer representing a bit mask that will be ANDed with the peers advertised service masks.
     * @return a future that will be triggered when the number of connected peers implementing protocolVersion or higher &gt;= numPeers
     */
    public ListenableFuture&lt;List&lt;Peer&gt;&gt; waitForPeersWithServiceMask(final int numPeers, final int mask) {
<span class="fc" id="L2057">        lock.lock();</span>
        try {
<span class="fc" id="L2059">            List&lt;Peer&gt; foundPeers = findPeersWithServiceMask(mask);</span>
<span class="fc bfc" id="L2060" title="All 2 branches covered.">            if (foundPeers.size() &gt;= numPeers)</span>
<span class="fc" id="L2061">                return Futures.immediateFuture(foundPeers);</span>
<span class="fc" id="L2062">            final SettableFuture&lt;List&lt;Peer&gt;&gt; future = SettableFuture.create();</span>
<span class="fc" id="L2063">            addConnectedEventListener(new PeerConnectedEventListener() {</span>
                @Override
                public void onPeerConnected(Peer peer, int peerCount) {
<span class="fc" id="L2066">                    final List&lt;Peer&gt; peers = findPeersWithServiceMask(mask);</span>
<span class="fc bfc" id="L2067" title="All 2 branches covered.">                    if (peers.size() &gt;= numPeers) {</span>
<span class="fc" id="L2068">                        future.set(peers);</span>
<span class="fc" id="L2069">                        removeConnectedEventListener(this);</span>
                    }
<span class="fc" id="L2071">                }</span>
            });
<span class="fc" id="L2073">            return future;</span>
        } finally {
<span class="pc" id="L2075">            lock.unlock();</span>
        }
    }

    /**
     * Returns an array list of peers that match the requested service bit mask.
     */
    public List&lt;Peer&gt; findPeersWithServiceMask(int mask) {
<span class="fc" id="L2083">        lock.lock();</span>
        try {
<span class="fc" id="L2085">            ArrayList&lt;Peer&gt; results = new ArrayList&lt;Peer&gt;(peers.size());</span>
<span class="fc bfc" id="L2086" title="All 2 branches covered.">            for (Peer peer : peers)</span>
<span class="fc bfc" id="L2087" title="All 2 branches covered.">                if ((peer.getPeerVersionMessage().localServices &amp; mask) == mask)</span>
<span class="fc" id="L2088">                    results.add(peer);</span>
<span class="fc" id="L2089">            return results;</span>
        } finally {
<span class="pc" id="L2091">            lock.unlock();</span>
        }
    }

    /**
     * Returns the number of connections that are required before transactions will be broadcast. If there aren't
     * enough, {@link PeerGroup#broadcastTransaction(Transaction)} will wait until the minimum number is reached so
     * propagation across the network can be observed. If no value has been set using
     * {@link PeerGroup#setMinBroadcastConnections(int)} a default of 80% of whatever
     * {@link org.guldenj.core.PeerGroup#getMaxConnections()} returns is used.
     */
    public int getMinBroadcastConnections() {
<span class="fc" id="L2103">        lock.lock();</span>
        try {
<span class="pc bpc" id="L2105" title="1 of 2 branches missed.">            if (minBroadcastConnections == 0) {</span>
<span class="nc" id="L2106">                int max = getMaxConnections();</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">                if (max &lt;= 1)</span>
<span class="nc" id="L2108">                    return max;</span>
                else
<span class="nc" id="L2110">                    return (int) Math.round(getMaxConnections() * 0.8);</span>
            }
<span class="fc" id="L2112">            return minBroadcastConnections;</span>
        } finally {
<span class="pc" id="L2114">            lock.unlock();</span>
        }
    }

    /**
     * See {@link org.guldenj.core.PeerGroup#getMinBroadcastConnections()}.
     */
    public void setMinBroadcastConnections(int value) {
<span class="fc" id="L2122">        lock.lock();</span>
        try {
<span class="fc" id="L2124">            minBroadcastConnections = value;</span>
        } finally {
<span class="pc" id="L2126">            lock.unlock();</span>
<span class="fc" id="L2127">        }</span>
<span class="fc" id="L2128">    }</span>

    /**
     * Calls {@link PeerGroup#broadcastTransaction(Transaction,int)} with getMinBroadcastConnections() as the number
     * of connections to wait for before commencing broadcast.
     */
    @Override
    public TransactionBroadcast broadcastTransaction(final Transaction tx) {
<span class="fc" id="L2136">        return broadcastTransaction(tx, Math.max(1, getMinBroadcastConnections()));</span>
    }

    /**
     * &lt;p&gt;Given a transaction, sends it un-announced to one peer and then waits for it to be received back from other
     * peers. Once all connected peers have announced the transaction, the future available via the
     * {@link org.guldenj.core.TransactionBroadcast#future()} method will be completed. If anything goes
     * wrong the exception will be thrown when get() is called, or you can receive it via a callback on the
     * {@link ListenableFuture}. This method returns immediately, so if you want it to block just call get() on the
     * result.&lt;/p&gt;
     *
     * &lt;p&gt;Note that if the PeerGroup is limited to only one connection (discovery is not activated) then the future
     * will complete as soon as the transaction was successfully written to that peer.&lt;/p&gt;
     *
     * &lt;p&gt;The transaction won't be sent until there are at least minConnections active connections available.
     * A good choice for proportion would be between 0.5 and 0.8 but if you want faster transmission during initial
     * bringup of the peer group you can lower it.&lt;/p&gt;
     *
     * &lt;p&gt;The returned {@link org.guldenj.core.TransactionBroadcast} object can be used to get progress feedback,
     * which is calculated by watching the transaction propagate across the network and be announced by peers.&lt;/p&gt;
     */
    public TransactionBroadcast broadcastTransaction(final Transaction tx, final int minConnections) {
        // If we don't have a record of where this tx came from already, set it to be ourselves so Peer doesn't end up
        // redownloading it from the network redundantly.
<span class="pc bpc" id="L2160" title="1 of 2 branches missed.">        if (tx.getConfidence().getSource().equals(TransactionConfidence.Source.UNKNOWN)) {</span>
<span class="nc" id="L2161">            tx.getConfidence().setSource(TransactionConfidence.Source.SELF);</span>
        }
<span class="fc" id="L2163">        final TransactionBroadcast broadcast = new TransactionBroadcast(this, tx);</span>
<span class="fc" id="L2164">        broadcast.setMinConnections(minConnections);</span>
        // Send the TX to the wallet once we have a successful broadcast.
<span class="fc" id="L2166">        Futures.addCallback(broadcast.future(), new FutureCallback&lt;Transaction&gt;() {</span>
            @Override
            public void onSuccess(Transaction transaction) {
<span class="fc" id="L2169">                runningBroadcasts.remove(broadcast);</span>
                // OK, now tell the wallet about the transaction. If the wallet created the transaction then
                // it already knows and will ignore this. If it's a transaction we received from
                // somebody else via a side channel and are now broadcasting, this will put it into the
                // wallet now we know it's valid.
<span class="fc bfc" id="L2174" title="All 2 branches covered.">                for (Wallet wallet : wallets) {</span>
                    // Assumption here is there are no dependencies of the created transaction.
                    //
                    // We may end up with two threads trying to do this in parallel - the wallet will
                    // ignore whichever one loses the race.
                    try {
<span class="fc" id="L2180">                        wallet.receivePending(transaction, null);</span>
<span class="nc" id="L2181">                    } catch (VerificationException e) {</span>
<span class="nc" id="L2182">                        throw new RuntimeException(e);   // Cannot fail to verify a tx we created ourselves.</span>
<span class="fc" id="L2183">                    }</span>
<span class="fc" id="L2184">                }</span>
<span class="fc" id="L2185">            }</span>

            @Override
            public void onFailure(Throwable throwable) {
                // This can happen if we get a reject message from a peer.
<span class="nc" id="L2190">                runningBroadcasts.remove(broadcast);</span>
<span class="nc" id="L2191">            }</span>
        });
        // Keep a reference to the TransactionBroadcast object. This is important because otherwise, the entire tree
        // of objects we just created would become garbage if the user doesn't hold on to the returned future, and
        // eventually be collected. This in turn could result in the transaction not being committed to the wallet
        // at all.
<span class="fc" id="L2197">        runningBroadcasts.add(broadcast);</span>
<span class="fc" id="L2198">        broadcast.broadcast();</span>
<span class="fc" id="L2199">        return broadcast;</span>
    }

    /**
     * Returns the period between pings for an individual peer. Setting this lower means more accurate and timely ping
     * times are available via {@link org.guldenj.core.Peer#getLastPingTime()} but it increases load on the
     * remote node. It defaults to 5000.
     */
    public long getPingIntervalMsec() {
<span class="fc" id="L2208">        lock.lock();</span>
        try {
<span class="fc" id="L2210">            return pingIntervalMsec;</span>
        } finally {
<span class="pc" id="L2212">            lock.unlock();</span>
        }
    }

    /**
     * Sets the period between pings for an individual peer. Setting this lower means more accurate and timely ping
     * times are available via {@link org.guldenj.core.Peer#getLastPingTime()} but it increases load on the
     * remote node. It defaults to {@link PeerGroup#DEFAULT_PING_INTERVAL_MSEC}.
     * Setting the value to be &lt;= 0 disables pinging entirely, although you can still request one yourself
     * using {@link org.guldenj.core.Peer#ping()}.
     */
    public void setPingIntervalMsec(long pingIntervalMsec) {
<span class="fc" id="L2224">        lock.lock();</span>
        try {
<span class="fc" id="L2226">            this.pingIntervalMsec = pingIntervalMsec;</span>
<span class="fc" id="L2227">            ListenableScheduledFuture&lt;?&gt; task = vPingTask;</span>
<span class="pc bpc" id="L2228" title="1 of 2 branches missed.">            if (task != null)</span>
<span class="nc" id="L2229">                task.cancel(false);</span>
<span class="fc" id="L2230">            setupPinging();</span>
        } finally {
<span class="pc" id="L2232">            lock.unlock();</span>
<span class="fc" id="L2233">        }</span>
<span class="fc" id="L2234">    }</span>

    /**
     * If a peer is connected to that claims to speak a protocol version lower than the given version, it will
     * be disconnected and another one will be tried instead.
     */
    public void setMinRequiredProtocolVersion(int minRequiredProtocolVersion) {
<span class="nc" id="L2241">        this.vMinRequiredProtocolVersion = minRequiredProtocolVersion;</span>
<span class="nc" id="L2242">    }</span>

    /** The minimum protocol version required: defaults to the version required for Bloom filtering. */
    public int getMinRequiredProtocolVersion() {
<span class="fc" id="L2246">        return vMinRequiredProtocolVersion;</span>
    }

    /**
     * Returns our peers most commonly reported chain height. If multiple heights are tied, the highest is returned.
     * If no peers are connected, returns zero.
     */
    public int getMostCommonChainHeight() {
<span class="fc" id="L2254">        lock.lock();</span>
        try {
<span class="fc" id="L2256">            return getMostCommonChainHeight(this.peers);</span>
        } finally {
<span class="pc" id="L2258">            lock.unlock();</span>
        }
    }

    /**
     * Returns most commonly reported chain height from the given list of {@link Peer}s.
     * If multiple heights are tied, the highest is returned. If no peers are connected, returns zero.
     */
    public static int getMostCommonChainHeight(final List&lt;Peer&gt; peers) {
<span class="pc bpc" id="L2267" title="1 of 2 branches missed.">        if (peers.isEmpty())</span>
<span class="nc" id="L2268">            return 0;</span>
<span class="fc" id="L2269">        List&lt;Integer&gt; heights = new ArrayList&lt;Integer&gt;(peers.size());</span>
<span class="fc bfc" id="L2270" title="All 2 branches covered.">        for (Peer peer : peers) heights.add((int) peer.getBestHeight());</span>
<span class="fc" id="L2271">        return Utils.maxOfMostFreq(heights);</span>
    }

    /**
     * Given a list of Peers, return a Peer to be used as the download peer. If you don't want PeerGroup to manage
     * download peer statuses for you, just override this and always return null.
     */
    @Nullable
    protected Peer selectDownloadPeer(List&lt;Peer&gt; peers) {
        // Characteristics to select for in order of importance:
        //  - Chain height is reasonable (majority of nodes)
        //  - High enough protocol version for the features we want (but we'll settle for less)
        //  - Randomly, to try and spread the load.
<span class="fc bfc" id="L2284" title="All 2 branches covered.">        if (peers.isEmpty())</span>
<span class="fc" id="L2285">            return null;</span>
        // Make sure we don't select a peer that is behind/synchronizing itself.
<span class="fc" id="L2287">        int mostCommonChainHeight = getMostCommonChainHeight(peers);</span>
<span class="fc" id="L2288">        List&lt;Peer&gt; candidates = new ArrayList&lt;Peer&gt;();</span>
<span class="fc bfc" id="L2289" title="All 2 branches covered.">        for (Peer peer : peers) {</span>
<span class="fc bfc" id="L2290" title="All 2 branches covered.">            if (peer.getBestHeight() == mostCommonChainHeight) candidates.add(peer);</span>
<span class="fc" id="L2291">        }</span>
        // Of the candidates, find the peers that meet the minimum protocol version we want to target. We could select
        // the highest version we've seen on the assumption that newer versions are always better but we don't want to
        // zap peers if they upgrade early. If we can't find any peers that have our preferred protocol version or
        // better then we'll settle for the highest we found instead.
<span class="fc" id="L2296">        int highestVersion = 0, preferredVersion = 0;</span>
        // If/when PREFERRED_VERSION is not equal to vMinRequiredProtocolVersion, reenable the last test in PeerGroupTest.downloadPeerSelection
<span class="fc" id="L2298">        final int PREFERRED_VERSION = params.getProtocolVersionNum(NetworkParameters.ProtocolVersion.BLOOM_FILTER);</span>
<span class="fc bfc" id="L2299" title="All 2 branches covered.">        for (Peer peer : candidates) {</span>
<span class="fc" id="L2300">            highestVersion = Math.max(peer.getPeerVersionMessage().clientVersion, highestVersion);</span>
<span class="fc" id="L2301">            preferredVersion = Math.min(highestVersion, PREFERRED_VERSION);</span>
<span class="fc" id="L2302">        }</span>
<span class="fc" id="L2303">        ArrayList&lt;Peer&gt; candidates2 = new ArrayList&lt;Peer&gt;(candidates.size());</span>
<span class="fc bfc" id="L2304" title="All 2 branches covered.">        for (Peer peer : candidates) {</span>
<span class="pc bpc" id="L2305" title="1 of 2 branches missed.">            if (peer.getPeerVersionMessage().clientVersion &gt;= preferredVersion) {</span>
<span class="fc" id="L2306">                candidates2.add(peer);</span>
            }
<span class="fc" id="L2308">        }</span>
<span class="fc" id="L2309">        int index = (int) (Math.random() * candidates2.size());</span>
<span class="fc" id="L2310">        return candidates2.get(index);</span>
    }

    /**
     * Returns the currently selected download peer. Bear in mind that it may have changed as soon as this method
     * returns. Can return null if no peer was selected.
     */
    public Peer getDownloadPeer() {
<span class="fc" id="L2318">        lock.lock();</span>
        try {
<span class="fc" id="L2320">            return downloadPeer;</span>
        } finally {
<span class="pc" id="L2322">            lock.unlock();</span>
        }
    }

    /**
     * Returns the {@link com.subgraph.orchid.TorClient} object for this peer group, if Tor is in use, null otherwise.
     */
    @Nullable
    public TorClient getTorClient() {
<span class="nc" id="L2331">        return torClient;</span>
    }

    /**
     * Returns the maximum number of {@link Peer}s to discover. This maximum is checked after
     * each {@link PeerDiscovery} so this max number can be surpassed.
     * @return the maximum number of peers to discover
     */
    public int getMaxPeersToDiscoverCount() {
<span class="nc" id="L2340">        return vMaxPeersToDiscoverCount;</span>
    }

    /**
     * Sets the maximum number of {@link Peer}s to discover. This maximum is checked after
     * each {@link PeerDiscovery} so this max number can be surpassed.
     * @param maxPeersToDiscoverCount the maximum number of peers to discover
     */
    public void setMaxPeersToDiscoverCount(int maxPeersToDiscoverCount) {
<span class="fc" id="L2349">        this.vMaxPeersToDiscoverCount = maxPeersToDiscoverCount;</span>
<span class="fc" id="L2350">    }</span>

    /** See {@link #setUseLocalhostPeerWhenPossible(boolean)} */
    public boolean getUseLocalhostPeerWhenPossible() {
<span class="nc" id="L2354">        lock.lock();</span>
        try {
<span class="nc" id="L2356">            return useLocalhostPeerWhenPossible;</span>
        } finally {
<span class="nc" id="L2358">            lock.unlock();</span>
        }
    }

    /**
     * When true (the default), PeerGroup will attempt to connect to a Bitcoin node running on localhost before
     * attempting to use the P2P network. If successful, only localhost will be used. This makes for a simple
     * and easy way for a user to upgrade a guldenj based app running in SPV mode to fully validating security.
     */
    public void setUseLocalhostPeerWhenPossible(boolean useLocalhostPeerWhenPossible) {
<span class="fc" id="L2368">        lock.lock();</span>
        try {
<span class="fc" id="L2370">            this.useLocalhostPeerWhenPossible = useLocalhostPeerWhenPossible;</span>
        } finally {
<span class="pc" id="L2372">            lock.unlock();</span>
<span class="fc" id="L2373">        }</span>
<span class="fc" id="L2374">    }</span>

    public boolean isRunning() {
<span class="fc" id="L2377">        return vRunning;</span>
    }

    /**
     * Can be used to disable Bloom filtering entirely, even in SPV mode. You are very unlikely to need this, it is
     * an optimisation for rare cases when full validation is not required but it's still more efficient to download
     * full blocks than filtered blocks.
     */
    public void setBloomFilteringEnabled(boolean bloomFilteringEnabled) {
<span class="nc" id="L2386">        this.vBloomFilteringEnabled = bloomFilteringEnabled;</span>
<span class="nc" id="L2387">    }</span>

    /** Returns whether the Bloom filtering protocol optimisation is in use: defaults to true. */
    public boolean isBloomFilteringEnabled() {
<span class="nc" id="L2391">        return vBloomFilteringEnabled;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>